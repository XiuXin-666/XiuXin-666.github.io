<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【UE4】击碎玻璃物体破裂效果</title>
      <link href="2021/05/28/%E3%80%90UE4%E3%80%91%E5%87%BB%E7%A2%8E%E7%8E%BB%E7%92%83%E7%89%A9%E4%BD%93%E7%A0%B4%E8%A3%82%E6%95%88%E6%9E%9C/"/>
      <url>2021/05/28/%E3%80%90UE4%E3%80%91%E5%87%BB%E7%A2%8E%E7%8E%BB%E7%92%83%E7%89%A9%E4%BD%93%E7%A0%B4%E8%A3%82%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1>【UE4】击碎玻璃物体破裂效果</h1><h2 id="步骤：">步骤：</h2><h3 id="首先要创建破碎物体的话，就需要开启一个插件，之前版本是可以直接创建的。">首先要创建破碎物体的话，就需要开启一个插件，之前版本是可以直接创建的。</h3><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210528222357137.png" alt="image-20210528222357137"></p><p>重启之后，找到相应目录并找到相应物体</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210528222812983.png" alt="image-20210528222812983"></p><p>右键SM_GlassWindow创建可破碎物体</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210528222911007.png" alt="image-20210528222911007"></p><p>创建之后，进入设置参数cell Site Count （可破裂的块数），破碎的声音。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210528223629910.png" alt="image-20210528223629910"></p><p>破裂的声音需要自己获取，<a href="http://xn--www-0v1ej96z.aigei.com">进入www.aigei.com</a> 下载一个玻璃破碎的声音。如果不是wav格式，就使用转换软件转换成wav，我这边推荐的是格式工厂。</p><p>创建一个文件夹，里面存音乐资源。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210528224729167.png" alt="image-20210528224729167"></p><p>然后回到破碎网格体中，设置细节参数：</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210528224958776.png" alt="image-20210528224958776"></p><p>声音资源文件好像应该放在第二个，第一个失效；其他参数可以查阅官方文档。</p><h3 id="创建玻璃Actor，BP-BrokenGlass">创建玻璃Actor，BP_BrokenGlass</h3><p>在其中添加destructable组件，添加完了之后，设置破碎网格体，设置玻璃材质。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210528225714412.png" alt="image-20210528225714412"></p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210528225737288.png" alt="image-20210528225737288"></p><h3 id="添加破碎响应事件">添加破碎响应事件</h3><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210528230407233.png" alt="image-20210528230407233"></p><p>这里Apply Radius Damage，应用半径伤害，Apply Damage 应用伤害，参数不同，应用场景应该也有差异。</p><p>以后应该会更新这篇文章，详细做笔记。</p><h3 id="看看效果">看看效果</h3><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E7%8E%BB%E7%92%83%E7%A0%B4%E7%A2%8E.gif" alt=""></p><p>一般击碎玻璃之后，会让它进行消失，节约内存。</p><p>在之前的蓝图节点加入两个结点</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210528231808894.png" alt="image-20210528231808894"></p><p>这个功能就暂时到这了，可以用于许多场景。</p>]]></content>
      
      
      <categories>
          
          <category> UE4蓝图小功能系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE4蓝图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【UE4】异步加载场景</title>
      <link href="2021/05/28/%E3%80%90UE4%E3%80%91%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%9C%BA%E6%99%AF/"/>
      <url>2021/05/28/%E3%80%90UE4%E3%80%91%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1>【UE4】异步加载场景</h1><h2 id="异步加载场景：">异步加载场景：</h2><h2 id="操作步骤：">操作步骤：</h2><ol><li><p>准备两个地图，一个地图用作跳转使用</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210528131001116.png" alt="image-20210528131001116"></p><p>这里我是使用ThirdPersonExampleMap作为主地图，Map_1 作为跳转地图。</p></li><li><p>在 Third 关卡蓝图中，添加begin事件，生成widget用于地图的加载UI</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210528132531315.png" alt=""></p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210528131314678.png" alt="image-20210528131314678"></p><p>添加按钮操作事件On Clicked</p></li><li><p>在这个事件中，作为异步加载场景的主要事件</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/W_Lobby-EventGraph.png" alt=""></p><p>异步加载资源：Async Load Asset ,指定要加载的资源。在加载的同时，需要在窗口界面上添加一个Loading界面，所以还需要创建一个加载UI，W_Loading。</p></li><li><p>加载的时候就显示加载窗口，Create Widget 并 add to viewport</p></li><li><p>当加载完成时，就移除掉加载窗口，并打开地图场景。</p></li><li><p>基本步骤已经完成，快去试试吧</p></li></ol><p>这个功能的应用场景有关卡切换，异步加载其他资源。有待开发。</p>]]></content>
      
      
      <categories>
          
          <category> UE4蓝图小功能系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE4蓝图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【UE4】制作网页浏览器</title>
      <link href="2021/05/27/%E3%80%90UE4%E3%80%91%E5%88%B6%E4%BD%9C%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>2021/05/27/%E3%80%90UE4%E3%80%91%E5%88%B6%E4%BD%9C%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1>【UE4】制作网页浏览器</h1><h2 id="先制作电脑的Actor">先制作电脑的Actor</h2><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210527164834135.png" alt="image-20210527164834135"></p><h2 id="再创建用于浏览器的UI界面">再创建用于浏览器的UI界面</h2><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210527164923961.png" alt="image-20210527164923961"></p><p>然后在Actor中的Widget中指定Widget实例</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210527165114380.png" alt="image-20210527165114380"></p><p>在插件管理器中搜索Web Browser ，开启并重启。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210527165303449.png" alt="image-20210527165303449"></p><p>在W_Web中添加 Webbrowser组件，将组件附加到Vecrtical box下面</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210527165710898.png" alt="image-20210527165710898"></p><p>Web Browser组件的属性：</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210527165958118.png" alt="image-20210527165958118"></p><p>初始链接地址，是否支持透明</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210527170207340.png" alt="image-20210527170207340"></p><p>相应事件的响应函数，我们可以在此进行事件的编写</p><p>On Url Changed : 当链接改变时，发生的事件</p><p>On Before Popup: 在窗口切换弹出时，发生的事件，用于浏览器上切换链接。</p><h2 id="下面开始事件函数的编写：">下面开始事件函数的编写：</h2><p>先给Actor添加碰撞检测盒子。</p><p>在BP_Computer中添加添加事件处理，因为要与Widget W_Web进行交互，运行其中的函数，所以要先强制转换，获取到Widget</p><p>的实例。</p><p>按F进入浏览器，所以要在BP_Computer类默认值中设置允许输入：</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210527224310638.png" alt="image-20210527224310638"></p><p>具体蓝图节点为以下：（蓝图节点为插件生成，之后可以使用插件在UE中直接生成）</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/BP_Computer-EventGraph.png" alt=""></p><p>W_Web具体蓝图节点如下：</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/W_Web-EventGraph.png" alt=""></p><p>运行结果如下：</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210527225307093.png" alt="image-20210527225307093"></p><p>走过去，碰撞检测成功则按F进入全屏状态。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210527225408055.png" alt="image-20210527225408055"></p><p>输入百度网址，进行检索，页面跳转的时候，后面背景会出现透明的现象，导致人物场景的出现。解决这个问题应该在WebBrowser组件下面添加一个白色画布就行了。</p><p>这个小功能可以适用在很多场景，比如街道播放大幻灯片，或者是播放视频，等等。</p>]]></content>
      
      
      <categories>
          
          <category> UE4蓝图小功能系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE4蓝图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android界面开发</title>
      <link href="2021/05/07/Android%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
      <url>2021/05/07/Android%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="界面布局"><a href="#界面布局" class="headerlink" title="界面布局"></a>界面布局</h1><h2 id="LinearLayout-线性布局"><a href="#LinearLayout-线性布局" class="headerlink" title="LinearLayout(线性布局)"></a>LinearLayout(线性布局)</h2><table><thead><tr><th>XML属性</th><th>相关方法</th><th>说  明</th></tr></thead><tbody><tr><td>Android：orientation</td><td>SetOrientation(int)</td><td>设置布局内组件的排列方式，可以设置为horizontal(水平排列）、vertical(垂直排列、默认值）两个值的其中之一</td></tr><tr><td>Android:gravity</td><td>setGravity(int)</td><td>设置布局内组件的对齐方式，可选值包括top、bottom、left、right、center_vertical、fill_vertical、center_horizonal、fill_horizontal、center、fill、clip_vertical和clip_horizontal.这些属性值可以同时指定，各属性之间用竖线隔开。如要指定组件靠左下角对齐，可以用left|botton</td></tr></tbody></table><h2 id="FrameLayout（框架布局）"><a href="#FrameLayout（框架布局）" class="headerlink" title="FrameLayout（框架布局）"></a>FrameLayout（框架布局）</h2><p>​        框架布局是组织视图控件最简单和最有效地布局之一。该布局一般只用来显示单视图或者层叠的多视图。</p><table><thead><tr><th>XML属性</th><th>相关方法</th><th>说  明</th></tr></thead><tbody><tr><td>Android：foreground</td><td>SetForeground(Drawable)</td><td>设置框架布局视窗的前景图像</td></tr><tr><td>Android：foregroundGravity</td><td>SetForegroundGravity(int)</td><td>定义绘制前景图像的gravity属性</td></tr></tbody></table><h2 id="TableLayout（表格布局）"><a href="#TableLayout（表格布局）" class="headerlink" title="TableLayout（表格布局）"></a>TableLayout（表格布局）</h2><p>​        表格布局中每一个TableRow对象或者View对象为一行。TableRow是一个容器，因此可以向TableRow中添加子控件，每添加一个子控件该表格就增加一列。</p><table><thead><tr><th>XML属性</th><th>相关方法</th><th>说  明</th></tr></thead><tbody><tr><td>Android：collapseColumns</td><td>SetColumnCollapsed(int,boolean)</td><td>设置需要被隐藏的列的列序号（序号从0开始），多个列序号之间用逗号“，”分隔。</td></tr><tr><td>Android：shrinkColumns</td><td>setShrinkAllColumns(boolean)</td><td>设置允许被收缩的列的列序号（序号从0开始），多个列序号之间用逗号“，”分隔。</td></tr><tr><td>Android：stretchColumns</td><td>setStretchAllColumns  (boolean)</td><td>设置允许被拉伸的列的列序号（序号从0开始），多个列序号之间用逗号“，”分隔。</td></tr></tbody></table><h2 id="GridLayout-网格布局"><a href="#GridLayout-网格布局" class="headerlink" title="GridLayout(网格布局)"></a>GridLayout(网格布局)</h2><h2 id="RelativeLayout-相对布局"><a href="#RelativeLayout-相对布局" class="headerlink" title="RelativeLayout(相对布局)"></a>RelativeLayout(相对布局)</h2><h2 id="AbsoluteLayout-绝对布局"><a href="#AbsoluteLayout-绝对布局" class="headerlink" title="AbsoluteLayout(绝对布局)"></a>AbsoluteLayout(绝对布局)</h2><h1 id="界面控件"><a href="#界面控件" class="headerlink" title="界面控件"></a>界面控件</h1><ol><li><h2 id="TextView-和-EditText"><a href="#TextView-和-EditText" class="headerlink" title="TextView 和 EditText"></a>TextView 和 EditText</h2><p>TextView只用于显示文本，EditText可编辑文本</p></li><li><h2 id="CheckBox-和-RadioButton"><a href="#CheckBox-和-RadioButton" class="headerlink" title="CheckBox 和 RadioButton"></a>CheckBox 和 RadioButton</h2><p> 添加RadioButton</p><p>添加之前要先设至一个RadioGroup，设置为一组,这样才能单选</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/clip_image002.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.sx5_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.Display;</span><br><span class="line"><span class="keyword">import</span> android.view.Menu;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Adapter;</span><br><span class="line"><span class="keyword">import</span> android.widget.AdapterView;</span><br><span class="line"><span class="keyword">import</span> android.widget.ArrayAdapter;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.CheckBox;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.RadioButton;</span><br><span class="line"><span class="keyword">import</span> android.widget.RadioGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.Spinner;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Button button = <span class="keyword">null</span>;</span><br><span class="line">String Name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">String Password = <span class="string">&quot;&quot;</span>;</span><br><span class="line">String gender = <span class="string">&quot;&quot;</span>;</span><br><span class="line">String Hobby = <span class="string">&quot;&quot;</span>;</span><br><span class="line">String Country = <span class="string">&quot;&quot;</span>;</span><br><span class="line">String City = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Spinner Countries,citites;</span></span><br><span class="line">String[] countryItem;</span><br><span class="line">String[] cityItem;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line"><span class="comment">//Spinner</span></span><br><span class="line">Spinner Countries = (Spinner)findViewById(R.id.spinner);</span><br><span class="line">Spinner Cities = (Spinner)findViewById(R.id.spinner2);</span><br><span class="line"><span class="comment">//绑定注册按钮</span></span><br><span class="line">button = (Button)findViewById(R.id.button2);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">EditText name = (EditText)findViewById(R.id.editTextTextMultiLine2);</span><br><span class="line">Name = <span class="string">&quot;姓名:&quot;</span> + name.getText().toString() +<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">EditText password = (EditText)findViewById(R.id.editTextTextMultiLine3);</span><br><span class="line">Password = <span class="string">&quot;密码:&quot;</span> + password.getText().toString() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">//根据ID找到RadioGroup实例</span></span><br><span class="line">RadioGroup group = (RadioGroup)findViewById(R.id.radiogroup);</span><br><span class="line"><span class="comment">//绑定一个匿名监听器</span></span><br><span class="line">group.setOnCheckedChangeListener(<span class="keyword">new</span> RadioGroup.OnCheckedChangeListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCheckedChanged</span><span class="params">(RadioGroup group, <span class="keyword">int</span> checkedId)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取变更后的选中项的ID</span></span><br><span class="line"><span class="keyword">int</span> radioButtonId = group.getCheckedRadioButtonId();</span><br><span class="line"><span class="comment">//根据ID获取RadioButton的实例</span></span><br><span class="line">RadioButton radiobutton = (RadioButton)MainActivity.<span class="keyword">this</span>.findViewById(radioButtonId);</span><br><span class="line"><span class="comment">//更新文本内容，已符合选中项</span></span><br><span class="line">gender = <span class="string">&quot;你的性别是:&quot;</span> + (String)radiobutton.getText() + <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Hobby = <span class="string">&quot;体育爱好:&quot;</span>;</span><br><span class="line">CheckBox checkbox1 = (CheckBox)findViewById(R.id.checkBox1);</span><br><span class="line">CheckBox checkbox2 = (CheckBox)findViewById(R.id.checkBox2);</span><br><span class="line">CheckBox checkbox3 = (CheckBox)findViewById(R.id.checkBox3);</span><br><span class="line">CheckBox checkbox4 = (CheckBox)findViewById(R.id.checkBox4);</span><br><span class="line"><span class="comment">//对选项进行确定</span></span><br><span class="line"><span class="keyword">if</span>(checkbox1.isChecked())&#123;</span><br><span class="line">Hobby = Hobby + checkbox1.getText()+<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(checkbox2.isChecked())&#123;</span><br><span class="line">Hobby = Hobby + checkbox2.getText()+<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(checkbox3.isChecked())&#123;</span><br><span class="line">Hobby = Hobby + checkbox3.getText()+<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(checkbox4.isChecked())&#123;</span><br><span class="line">Hobby = Hobby + checkbox4.getText()+<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">DisplayToast(Name + Password + Country + City + gender + Hobby);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Countries = findViewById(R.id.spinner);</span><br><span class="line"><span class="comment">//获取array中定义的值</span></span><br><span class="line">countryItem = getResources().getStringArray(R.array.countries);</span><br><span class="line"><span class="comment">//添加Spinner监听事件</span></span><br><span class="line">Countries.setOnItemSelectedListener(<span class="keyword">new</span> AdapterView.OnItemSelectedListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemSelected</span><span class="params">(AdapterView&lt;?&gt; parent, View view, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">Country = <span class="string">&quot;国籍:&quot;</span> + countryItem[position] + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNothingSelected</span><span class="params">(AdapterView&lt;?&gt; parent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Cities = findViewById(R.id.spinner2);</span><br><span class="line"><span class="comment">//获取array中定义的值</span></span><br><span class="line">cityItem = getResources().getStringArray(R.array.cities);</span><br><span class="line"><span class="comment">//添加Spinner监听事件</span></span><br><span class="line">Cities.setOnItemSelectedListener(<span class="keyword">new</span> AdapterView.OnItemSelectedListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemSelected</span><span class="params">(AdapterView&lt;?&gt; parent, View view, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">City = <span class="string">&quot;城市:&quot;</span> + cityItem[position] + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNothingSelected</span><span class="params">(AdapterView&lt;?&gt; parent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayToast</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">Toast.makeText(<span class="keyword">this</span>,str,Toast.LENGTH_LONG).show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">getMenuInflater().inflate(R.menu.activity_main,menu);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="Spinner"><a href="#Spinner" class="headerlink" title="Spinner"></a>Spinner</h2><p>添加Spinner组件，有两种方法，一种是在java代码中实现，一种是在xml中实现。对我来说肯定选择后者，方便快捷而且不会混乱。但要在res文件夹中values文件夹中创建两个xml文件，用来存放string数组，这个数组就是spinner的下拉item。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;string-array name=<span class="string">&quot;countries&quot;</span>&gt;</span><br><span class="line">        &lt;item&gt;中国&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;日本&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;美国&lt;/item&gt;</span><br><span class="line">    &lt;/string-array&gt;</span><br><span class="line">&lt;/resources&gt;  </span><br></pre></td></tr></table></figure><p>​     同时在spinner的xml代码中，要添加以下代码，类似spinner引用该数组。android:entries=”@array/countries”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Spinner</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;spinner&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;409dp&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;80dp&quot;</span><br><span class="line">    android:entries&#x3D;&quot;@array&#x2F;countries&quot;</span><br><span class="line">    app:layout_constraintStart_toStartOf&#x3D;&quot;parent&quot;</span><br><span class="line">    tools:layout_editor_absoluteY&#x3D;&quot;228dp&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><ol><li><h2 id="匿名内部类作为监听器类"><a href="#匿名内部类作为监听器类" class="headerlink" title="匿名内部类作为监听器类"></a>匿名内部类作为监听器类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bt.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setClass(OtherActivity.<span class="keyword">this</span>,MainActivity.class);</span><br><span class="line">        OtherActivity.<span class="keyword">this</span>.startActivity(intent);</span><br><span class="line">        OtherActivity.<span class="keyword">this</span>.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><h2 id="内部类作为事件监听器类"><a href="#内部类作为事件监听器类" class="headerlink" title="内部类作为事件监听器类"></a>内部类作为事件监听器类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部类，放在Acitvity类中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClickListener</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        DisplayToast(<span class="string">&quot;事件触发器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="外部类作为事件监听器类"><a href="#外部类作为事件监听器类" class="headerlink" title="外部类作为事件监听器类"></a>外部类作为事件监听器类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新建一个MyClickListner类作为外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClickListener</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_other);</span><br><span class="line">Button button = (Button)findViewById(R.id.XXX);</span><br><span class="line">    button.setOnClickListener(<span class="keyword">new</span> MyClickLister(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="Activity本身作为事件监听类"><a href="#Activity本身作为事件监听类" class="headerlink" title="Activity本身作为事件监听类"></a>Activity本身作为事件监听类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">OnClickListner</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//此时按钮响应事件就要改变了</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">            DisplayToast(<span class="string">&quot;事件触发成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 界面开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intent和IntentFilter</title>
      <link href="2021/05/06/Intent%E5%92%8CIntentFilter/"/>
      <url>2021/05/06/Intent%E5%92%8CIntentFilter/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="Intent概述"><a href="#Intent概述" class="headerlink" title="Intent概述"></a>Intent概述</h2><p>​        •Intent是Android的核心组件，利用消息实现应用程序间的交互机制，这种消息描述了应用中一次操作的动作、数据以及附加数据，系统通过该Intent的描述负责找到对应的组件，并将Intent传递给调用的组件，完成组件的调用。 </p><p>​        •Intent由动作、数据、分类、类型、组件和扩展信息等内容组成，每个组成都由相应的属性进行表示，并提供设置和获取相应属性的方法。</p><table><thead><tr><th align="center"><strong>组成</strong></th><th align="center"><strong>属性</strong></th><th align="center"><strong>设置属性方法</strong></th><th align="center"><strong>获取属性方法</strong></th></tr></thead><tbody><tr><td align="center"><strong>动作</strong></td><td align="center"><strong>Action</strong></td><td align="center"><strong>setAction()</strong></td><td align="center"><strong>getAction()</strong></td></tr><tr><td align="center"><strong>数据</strong></td><td align="center"><strong>Data</strong></td><td align="center">setData()</td><td align="center"><strong>getData</strong>()</td></tr><tr><td align="center"><strong>分类</strong></td><td align="center"><strong>Category</strong></td><td align="center"><strong>addCategory</strong>()</td><td align="center"><strong>getCategories()</strong></td></tr><tr><td align="center"><strong>类型</strong></td><td align="center"><strong>Type</strong></td><td align="center">setType()</td><td align="center"><strong>getType()</strong></td></tr><tr><td align="center"><strong>组件</strong></td><td align="center"><strong>Component</strong></td><td align="center">setComponent() setClass() setClassName()</td><td align="center"><strong>getComponent()</strong></td></tr><tr><td align="center"><strong>扩展信息</strong></td><td align="center"><strong>Extra</strong></td><td align="center"><strong>putExtra**</strong>()**</td><td align="center"><strong>getXXXExtra()获取不同数据类型的数据，如int类型则使用getIntExtra()，字符串则使用getStringExtra()</strong>  getExtras()获取Bundle包</td></tr></tbody></table><h3 id="Action属性"><a href="#Action属性" class="headerlink" title="Action属性"></a>Action属性</h3><p>​        •Action属性用于描述Intent要完成的动作，对要执行的动作进行一个简要描述。Intent类定义了一系列Action属性常量，用来标识一套标准动作，如ACTION_CALL（打电话）、ACTION_EDIT（编辑）等。</p><p>​        • Action属性常量 </p><table><thead><tr><th><strong>Action****常量</strong></th><th><strong>行为描述</strong></th><th><strong>使用组件（分类）</strong></th></tr></thead><tbody><tr><td><strong>ACTION_CALL</strong></td><td><strong>打电话，即直接呼叫</strong>Data中所带电话号码</td><td><strong>Activity</strong></td></tr><tr><td><strong>ACTION_ANSWER</strong></td><td><strong>接听来电</strong></td><td></td></tr><tr><td><strong>ACTION_SEND</strong></td><td><strong>由用户指定发送方式进行数据发送操作</strong></td><td></td></tr><tr><td><strong>ACTION_SENDTO</strong></td><td><strong>根据不同的</strong>Data类型，通过对应的软件发送数据</td><td></td></tr><tr><td><strong>ACTION_VIEW</strong></td><td><strong>根据不同的</strong>Data类型，通过对应的软件显示数据</td><td></td></tr><tr><td><strong>ACTION_EDIT</strong></td><td><strong>显示可编辑的数据</strong></td><td></td></tr><tr><td><strong>ACTION_MAIN</strong></td><td><strong>应用程序的入口</strong></td><td></td></tr><tr><td><strong>ACTION_SYNC</strong></td><td><strong>同步服务器与移动设备之间的数据</strong></td><td></td></tr><tr><td><strong>ACTION_BATTERY_LOW</strong></td><td><strong>警告设备电量低</strong></td><td><strong>Broadcast</strong></td></tr><tr><td><strong>ACTION_HEADSET_PLUG</strong></td><td><strong>插入或者拔出耳机</strong></td><td></td></tr><tr><td><strong>ACTION_SCREEN_ON</strong></td><td><strong>打开移动设备屏幕</strong></td><td></td></tr><tr><td><strong>ACTION_TIMEZONE_CHANGED</strong></td><td><strong>移动设备时区发生变化</strong></td><td></td></tr></tbody></table><h3 id="Data属性"><a href="#Data属性" class="headerlink" title="Data属性"></a>Data属性</h3><p>​        •Intent的Data属性是执行动作的URI和MIME类型</p><p>​        •Data属性常量 </p><table><thead><tr><th><strong>Data</strong>属性</th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>tel</strong>://</td><td><strong>号码数据格式，后跟电话号码</strong></td><td><strong>tel://123</strong></td></tr><tr><td><strong>mailto://</strong></td><td><strong>邮件数据格式，后跟邮件收件人地址</strong></td><td><strong>mailto://dh@163.com</strong></td></tr><tr><td><strong>smsto</strong>://</td><td><strong>短息数据格式，后跟短信接收号码</strong></td><td><strong>smsto://123</strong></td></tr><tr><td><strong>content://</strong></td><td><strong>内容数据格式，后跟需要读取的内容</strong></td><td><strong>content://contacts/people/1</strong></td></tr><tr><td><strong>file://</strong></td><td><strong>文件数据格式，后跟文件路径</strong></td><td><strong>file://sdcard/mymusic.mp3</strong></td></tr><tr><td><strong>geo://latitude,longitude</strong></td><td><strong>经纬数据格式，在地图上显示经纬度所指定的位置</strong></td><td><strong>geo://180,65</strong></td></tr></tbody></table><p>​    •Action和Data一般匹配使用，不同的Action由不同的Data数据指定 </p><table><thead><tr><th align="center">Action属性</th><th align="center">Data属性</th><th align="center"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center"><strong>ACTION_VIEW</strong></td><td align="center"><strong>content://contacts/people/1</strong></td><td align="center"><strong>显示</strong>_id为1的联系人信息</td></tr><tr><td align="center"><strong>ACTION_EDIT</strong></td><td align="center"><strong>content://contacts/people/1</strong></td><td align="center"><strong>编辑</strong>_id为1的联系人信息</td></tr><tr><td align="center"><strong>ACTION_VIEW</strong></td><td align="center"><strong>tel:123</strong></td><td align="center"><strong>显示电话为</strong>123的联系人信息</td></tr><tr><td align="center"><strong>ACTION_VIEW</strong></td><td align="center"><strong><a href="http://www.google.com/">http://www.google.com</a></strong></td><td align="center"><strong>在浏览器中浏览该网页</strong></td></tr><tr><td align="center"><strong>ACTION_VIEW</strong></td><td align="center"><strong>file:///sdcard/mymusic.mp3</strong></td><td align="center"><strong>播放</strong>MP3</td></tr></tbody></table><h3 id="Category属性"><a href="#Category属性" class="headerlink" title="Category属性"></a>Category属性</h3><p>​        •Category属性指明一个执行Action的分类</p><p>​        •Intent中定义了一系列Category属性常量 </p><table><thead><tr><th><strong>Category****属性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>CATEGORY_DEFAULT</strong></td><td><strong>默认的执行方式，按照普通</strong>Activity的执行方式执行</td></tr><tr><td><strong>CATEGORY_HOME</strong></td><td><strong>该组件为</strong>Home Activity</td></tr><tr><td><strong>CATEGORY_LAUNCHER</strong></td><td><strong>优先级最高的</strong>Activity，通常为入口ACTION_MAIN配合使用</td></tr><tr><td><strong>CATEGORY_BROWSABLE</strong></td><td><strong>可以使用浏览器启动</strong></td></tr><tr><td><strong>CATEGORY_GADGET</strong></td><td><strong>可以内嵌到另外的</strong>Activity中</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android资源使用</title>
      <link href="2021/05/06/Android%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8/"/>
      <url>2021/05/06/Android%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>在Android项目中，资源文件分别放在res和assets两个文件夹中</p><ol><li><p>res目录存放Android程序能通过R资源类直接访问的资源；</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210506184320254.png" alt="image-20210506184320254"></p></li><li><p>assets目录存放Android程序不能直接访问的资源（原生文件），如MP3文件，必须通过AssetManager类以二进制流的形式读取。</p></li></ol><p><strong>访问字符串资源：R.string.XXX 或 @string/XXX</strong></p><p><strong>访问图片资源：R.drawable.XXX   或 @drawable/XXX</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity详解</title>
      <link href="2021/05/06/Activity%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/05/06/Activity%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Activity概述"><a href="#Activity概述" class="headerlink" title="Activity概述"></a>Activity概述</h1><p>​        一个应用程序通常由多个彼此之间松耦合的Activity组成。通常，有一个Activity被指定为主Activity。当应用程序第一次启动的时候，该Activity会显示给用户。</p><p>​        每个Activity都可以启动其他Activity用于执行不同的动作（功能）。当一个新的Activity启动的时候，先前的那个Activity就会<strong>停止</strong>，但是系统会在<strong>堆栈</strong>中保存该Activity。</p><p>​        堆栈遵循<strong>后进先出</strong>的队列原则，因此，当用户使用完当前的Activity并按Back键时，该Activity将从堆栈中取出（并<strong>销毁，释放内存空间</strong>），然后先前的Activity恢复并获取焦点。</p><h1 id="创建和配置Activity"><a href="#创建和配置Activity" class="headerlink" title="创建和配置Activity"></a>创建和配置Activity</h1><p>​        条件：</p><ol><li><p>需要继承Activity基类或其子类</p></li><li><p>创建Activity需要实现一个或多个方法；</p><p>其中最常见的就是**onCreate(Bundle status)**方法，该方法将会在Activity创建时被回调，并可调用setContentView（View view）方法来显示要展示的View。 </p></li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AndroidManifest.xml</span></span><br><span class="line">&lt;activity android:name=<span class="string">&quot;.MainActivity&quot;</span> <span class="comment">//name : 指定Activity的实现类的类名（必须）</span></span><br><span class="line">    android:label=<span class="string">&quot;@string/app_name&quot;</span> &gt; <span class="comment">//标题显示文字</span></span><br><span class="line">    &lt;intent-filter&gt; <span class="comment">//配置Activity过滤条件</span></span><br><span class="line">     &lt;action android:name=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt; <span class="comment">//设为主Activity</span></span><br><span class="line"></span><br><span class="line">     &lt;category android:name=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt; <span class="comment">//设置附加信息</span></span><br><span class="line">         <span class="comment">//决定最先运行的launcher中那个activity，该属性会最先调用</span></span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>​        当用户离开Activity时，系统将会自动调用onPause()方法，但这并不意味这该Activity被销毁了。在该方法中，应该实现一些需要持久化的功能，因为用户可能不会再返回该Activity，该进程可能会被杀死。</p><h1 id="启动和关闭Activity"><a href="#启动和关闭Activity" class="headerlink" title="启动和关闭Activity"></a>启动和关闭Activity</h1><p>​        一个Android应用通常只有一个Activity会作为程序的入口。而应用中的其他Activity，通常都由入口Activity启动，或由入口Activity启动的Activity启动。</p><p>​        Activity启动其他Activity的方法如下：</p><ol><li>startActivity(Intent intent):启动其他Activity；</li><li>startActivityForResult(Intent intent,int requestCode)：程序将会得到新启动Activity的结果（通过重写onActivityResult（…）方法来获取），requestCode参数代表启动Activity的请求码。这个请求码的值由开发者根据业务自行设置，用于标识请求来源。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setClass(MainActivity.<span class="keyword">this</span>,OtherActivity.class);</span><br><span class="line">        <span class="comment">//通过Intent对象将数据传送到相应的Activity</span></span><br><span class="line">        MainActivity.<span class="keyword">this</span>.startActivity(intent);</span><br><span class="line">        MainActivity.<span class="keyword">this</span>.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>​        结束Activity：</p><ol><li><p><strong>finish()：结束当前Activity；</strong></p></li><li><p><strong>finishActivity（int requestCode)：结束以startActivityForResult(Intent  intent，int requestCode）方法启动的Activity。</strong></p><p>注意：大部分情况下，不建议显式调用这些方法关闭Activity。因为Android系统会为我们管理Activity的生命周期，调用这些方法可能会影响用户的预期体验。因此，只有当你不想用户再回到当前Activity的时候才去关闭它。</p></li></ol><h1 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h1><p>（1） onCreate():创建Activity时被调用；</p><p>（2） onStart():启动Activity时被调用；</p><p>（3） onRestart():重新启动Activity时被调用;</p><p>（4） onResume():恢复Activity时被调用；</p><p>（5） onPause():暂停Activity时被调用；</p><p>（6） onStop():停止Activity时被调用；</p><p>（7） onDestory: 销毁Activity时被调用；</p><p>Activity的三个主要状态：</p><ol><li><strong>Resumed:已恢复状态。此时Activity位于前台，并获得焦点，该状态也称为运行时状态。</strong></li><li><strong>Paused:暂停状态。在该状态下，其他Activity获得焦点，该Activity仍可见，即仍存在于内存中，保存着自身状态，与窗口管理器保持联系，但如果系统内存极度匮乏时，可能会被杀死。</strong></li><li><strong>Stopped:停止状态。在该状态下，该Activity完全被其他Activity覆盖，即仍存在于内存中，保存着自身状态，与窗口管理器失去联系， 系统在需要内存时，可以随时杀死该Activity。</strong></li></ol><p>Activity的生命周期的三个循环：</p><ol><li><p>整个生命周期：OnCrete - onDestroy</p><p><strong>从onCreate()开始到onDestroy()结束。Activity在onCreate()进行初始化，设置所有的“全局”状态，在onDestory()释放所有的资源。</strong></p></li><li><p>可见生命周期：OnStart - onStop</p><p><strong>从onStart()开始到onStop()结束。在这段时间，可以看到Activity在屏幕上，尽管有可能不在前台，不能和用户交互。在这两个方法之间，需要保持显示给用户的UI数据和资源等。</strong></p></li><li><p>前台生命周期：onResume - onPause</p><p><strong>从onResume()开始到onPause()结束。在这段时间里，该Activity处于所有 Activity的最前面，和用户进行交互。</strong>  <strong>Activity可以经常性地在resumed和paused状态之间切换</strong></p></li></ol><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210506211700004.png" alt="image-20210506211700004"></p><h1 id="Activity之间交换数据"><a href="#Activity之间交换数据" class="headerlink" title="Activity之间交换数据"></a>Activity之间交换数据</h1><p>​        利用Intent组件</p><p>Intent提供了多个重载方法来存放需要携带的数据，格式如下：</p><ol><li>putExtras(String name,XXX data):其中XXX代表数据类型，如int,long,String等。      </li><li>putExtras(Bundle data)：向intent中放入一个简单的数据携带包，该类提供了多个方法来存入数据。（查看Bundle） </li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//putExtra():</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">String str = edittext.getText().toString();</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClass(MainActivity.<span class="keyword">this</span>,OtherActivity.class);</span><br><span class="line">intent.putExtra(<span class="string">&quot;content&quot;</span>,str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Intent对象将数据传送到相应的Activity</span></span><br><span class="line">MainActivity.<span class="keyword">this</span>.startActivity(intent);</span><br><span class="line">MainActivity.<span class="keyword">this</span>.finish();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//OtherActivity.java</span></span><br><span class="line">Intent intent = <span class="keyword">this</span>.getIntent();</span><br><span class="line">String res = intent.getStringExtra(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">textview.setText(res);</span><br><span class="line"></span><br><span class="line"><span class="comment">//putExtras(bundle):</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">String str1 = edittext1.getText().toString();</span><br><span class="line">String str2 = edittext2.getText().toString();</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClass(MainActivity.<span class="keyword">this</span>,OtherActivity.class);</span><br><span class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle.putString(<span class="string">&quot;name&quot;</span>,str1);</span><br><span class="line">bundle.putString(<span class="string">&quot;pass&quot;</span>,str2);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Intent对象将数据传送到相应的Activity</span></span><br><span class="line">MainActivity.<span class="keyword">this</span>.startActivity(intent);</span><br><span class="line">MainActivity.<span class="keyword">this</span>.finish();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//OtherActivity.java</span></span><br><span class="line">Intent intent = <span class="keyword">this</span>.getIntent();</span><br><span class="line">Bundle bundle = intent.getExtras();</span><br><span class="line">String res = bundle.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">String res1 = bundle.getString(<span class="string">&quot;pass&quot;</span>);</span><br><span class="line">textview.setText(res + res1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Activity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android程序设计基础</title>
      <link href="2021/05/06/Android%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
      <url>2021/05/06/Android%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Android程序结构"><a href="#Android程序结构" class="headerlink" title="Android程序结构"></a>Android程序结构</h1><h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210506193325810.png" alt="image-20210506193325810" style="zoom:80%;" /><ol><li><p>src目录</p><p>source的简写，存放源文件的目录，即写有代码的以java为后缀的文件。</p></li><li><p>res目录</p><p>存放项目中的资源文件并将编译进应用程序中，包括图片、字符串、菜单、界面布局、样式等等。在向此目录添加的资源文件，都会被gen/R.java自动记录。</p></li><li><p>gen目录</p><p>取自Generated Java Files的前3个英文单词，存放ADT自动生成的java文件，例如R.java和BuildConfig.java文件。这个目录中的文件不建议作任何的改动，否则会出错，或ADT会再次自动生成。</p></li><li><p>bin目录</p><p>该目录存放编译器编译之后产生的所有文件。包括dex文件（java编译后生成的java字节码文件）、resources.ap_（所有资源文件的集合，实际上是zip格式）、dexedLibs（对应libs中引用的jar包）和可执行apk文件等等。一个apk文件内包含被编译的代码文件（.dex文件）、文件资源（res）、assets、证书（certificates）和清单文件（manifest file），它基于zip文件格式。</p></li><li><p>assets目录</p><p>该目录用来存放原始格式的文件，例如音频文件、视频文件等二进制格式文件。此目录中的资源不能被R.java文件索引，所以只能以字节流的形式读取。一般情况下该目录为空。</p></li><li><p>lib目录</p><p>lib是libraries的缩写，存放程序中引用到的库，和bin/dexedLibs里面的目录是一致的。比如要给一个应用加入广告，只要将广告商提供的jar文件导入到该目录下，调用该jar里的相应方法就可以在程序中嵌入广告了。</p></li><li><p>AndroidManifest.xml文件</p><p>该文件是Android项目的全局配置文件，记录应用中使用到各种全局的配置，是每个 android程序中必须的文件。它位于整个项目的根目录下，描述了程序中的全局数据，包括程序中用到的组件（activities、services等等），以及它们各自的实现类，各种能被处理的数据和启动位置等重要信息。</p></li><li><p>ic_launcher-web.png文件</p><p>这是为了google Play市场使用展示的图标，它需要的是512×512的高分辨率图标。</p></li><li><p>proguard-project.txt和project.properties文件</p><p>这两个文件是为了保护Android项目而做的代码混淆使用的。</p></li></ol><h1 id="Android核心组件"><a href="#Android核心组件" class="headerlink" title="Android核心组件"></a>Android核心组件</h1><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>​        Activity的整个生命周期中有活动、暂停、停止和非活动四种状态。活动状态，是在栈顶的Activity，它是可视的、有焦点、可接受用户输入。Android试图尽最大可能保持它活动状态，杀死其它Activity来确保当前活动Activity有足够的资源可使用。当另外一个Activity被激活时，它将被暂停。暂停状态，当Activity失去焦点，但仍然可见的状态，如被一个透明或者非全屏的Activity遮挡。若Activity变为完全隐藏，它将会变成停止状态。这时Activity仍然在内存中保存它所有的信息。停止状态的Activity将优先被终止，因此Activity停止后一个很重要的工作就是要保存好程序数据和UI状态。一旦Activity被用户关闭，以及暂时或停止状态的Activity被系统终止后，Activity便进入到非活动状态，它将被移除Activity栈。</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>​        Service是Android系统中一个非常重要的应用程序组件。Service的最大特点是它不可见，没有像Activity那样华丽的图形化界面。这也是与Activity相比最大的区别。Service在程序后台运行，拥有自己独立的生命周期，通常用来处理一些耗时长的操作。可以使用Service更新ContentPrivider，发送Intent以及启动系统的通知等等。但是Service不是一个单独的进程。也不是一个线程，如果Service里的代码阻塞了，会导致整个应用程序无响应。每一个Service在使用前与Activity一样，要在AndroidManifest.xml文件里进行声明。</p><h2 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h2><p>​        BroadcastReceiver是Android程序中的另一个重要的组件，其意为广播接收器，作用在于接收并响应Android应用中产生的各种广播消息。比如，当手机收到一条短信的时候，这时候就会产生一个收到短信的事件。它会向所有与它有关的已经注册的广播接收器广播这个事件。大部分广播消息是由系统产生的，例如时区改变、电池电量低和语言选项改变等等。使用广播接收器就必须先声明，它有两种声明的方法，一种是在AndroidManifest.xml文件里声明，另一种是用Java代码中的registReceiver()方法。</p><h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><p>​        在Android中，每一个应用程序运行在各自的进程中。当一个程序需要访问另一个应用程序的数据时，即<strong>在不同的虚拟机之间</strong>进行传递数据时，可以借助ContentProvider实现数据的交换，达到在不同的应用程序之间共享数据。</p><h2 id="Intent、IntentFilter"><a href="#Intent、IntentFilter" class="headerlink" title="Intent、IntentFilter"></a>Intent、IntentFilter</h2><p>​        Intent是一种轻量级的消息传递机制，这种消息描述了应用中一次操作的动作、动作涉及数据、附加数据。Android系统根据此Intent的描述，负责找到对应的组件，并将 Intent传递给调用的组件，并完成组件的调用。</p><p>​        Intent对象包含要接收此Intent组件需要的信息（例如需要的动作和动作需要的信息）和 android 系统需要的信息（要处理此Intent的组件的类别和怎样启动它）。每个组成部分都有相应的属性表示，并提供设置和获取相应属性的方法，</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210506195522992.png" alt="image-20210506195522992"></p><p>​        一个intent filter是一个IntentFilter类的实例。但是android系统必须在组件未启动的情况下就知道它的能力，因此<strong>intent filter一般不会在java代码中设置，而是在应用的AndroidManifest.xml文件中作为<intent-filter>元素的方式声明。</strong> <strong>Activity、Service和BroadcastReceiver可设置一个或者多个intent filter过滤器，来告诉Android系统哪个intent它们可以处理。每个过滤器描述了组件的一种能力，它过滤掉不想要的intent，留下想要的。</strong></p><p>​        <strong>一个intent filter中包含一个intent对象中的三个属性Action、Data和Catrgory，而Extra和Flag等属性在这方面不起作用。</strong></p><h1 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h1><h2 id="ADB调试桥"><a href="#ADB调试桥" class="headerlink" title="ADB调试桥"></a>ADB调试桥</h2><p>​        adb的全称为Android Debug Bridge，是起到调试桥的作用，用来管理模拟器和真机的通用调试工具。该工具功能强大，直接通过命令行使用adb命令。通过adb我们可以在Eclipse中通过DDMS来调试Android程序，因此它是debug工具，借助它我们可以管理设备或手机模拟器的状态，还可以进行很多手机操作，如安装软件、系统升级、运行shell命令等等。</p><h2 id="Logcat调试"><a href="#Logcat调试" class="headerlink" title="Logcat调试"></a>Logcat调试</h2><p>​        异常也称为例外，是在程序运行中发生的、会打断程序正常执行的事件。Java类库包含了系统定义的常见异常类，例如    算术异常（ArithmeticException），如除数为0；没有给对象开辟内存空间时会出现空指针异常（NullPointerException）；找不到文件异常（FileNotFoundException）；数组访问下标越界（ArrayIndexOutOfBoundsException）等等。当然，用户程序中特定的异常也可以通过用户自定义的异常类来进行处理。</p><h2 id="Dev-Tools"><a href="#Dev-Tools" class="headerlink" title="Dev Tools"></a>Dev Tools</h2><p>​        Dev Tools是用于调试和测试的工具，隐藏在Android模拟器中的。Dev Tools它为我们提供了强大的调试支持，包括了一系列用户各种用途的小工具：Development Settings、Exception Browser、Google Login Service、Instrumentation、Media Scanner、Package Browser、Pointer Location、Raw Image Viewer、Running processes和Terminal Emulator等</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android入门</title>
      <link href="2021/05/06/Android%E5%85%A5%E9%97%A8/"/>
      <url>2021/05/06/Android%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Android入门"><a href="#Android入门" class="headerlink" title="Android入门"></a>Android入门</h1><p>​        Android是基于<strong>Linux</strong>平台的开源手机操作系统，由操作系统、中间件、用户界面和应用软件组成，号称是<strong>首个</strong>为移动终端打造的真正开放和完整的移动软件。（这就是为什么我在我的说说页面上，用手机发动态，上面显示的Linux）</p><h2 id="Android体系结构"><a href="#Android体系结构" class="headerlink" title="Android体系结构"></a>Android体系结构</h2><ol><li><p>应用程序层</p><p>Android内有一系列的核心应用，包括<strong>短信程序</strong>、<strong>日历工具、网页浏览器</strong>等工具，以及基于Android平台的应用程序框架，所有的应用都是Java语言编写的。</p></li><li><p>应用程序框架层</p><p>开发者可以完全使用与那些内核应用程序相同的框架，这些框架用于简化和重用应用程序的组件。若某程序能够“暴露”其内容，则其他程序就可以使用这些内容。例如Android的四大组件：Activity、Service、ContentProvider、BroadcastReceiver。</p></li><li><p>系统库层</p><p>Android定义了一套C/C++开发库供Android平台的其他组件使用。这些功能通过Android应用程序框架提供给开发者，开发者是不能直接使用这些库的。</p></li><li><p>运行时环境</p></li><li><p>Linux内核层</p><p>Android的核心系统服务依赖于Linux2.6内核，如安全性、内存管理、进程管理、网络协议栈和驱动模型。Linux内核也同时作为硬件和软件栈之间的抽象层。</p></li></ol><h2 id="开发工具介绍"><a href="#开发工具介绍" class="headerlink" title="开发工具介绍"></a>开发工具介绍</h2><p>​        Java JDK（必须），Android SDK（必须），ADT（可选，运行环境为Eclipse时）；或集成开发环境 Android Studio。</p><h2 id="Android应用程序结构"><a href="#Android应用程序结构" class="headerlink" title="Android应用程序结构"></a>Android应用程序结构</h2><p>​        <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210506183730311.png" alt="Android项目程序结构"></p><h3 id="gen目录介绍"><a href="#gen目录介绍" class="headerlink" title="gen目录介绍"></a>gen目录介绍</h3><p>gen目录中存放ADT自动生成的文件,该目录中最主要的就是<strong>R.java</strong>文件。</p><p>Android开发工具会根据res目录中的xml文件、图片等资源，<strong>同步更新R.java</strong>文件。</p><p>R.java在应用中起着<strong>字典</strong>的作用，它包含各种资源的引用，通过R.java系统可以很方便地找到对应资源。</p><p>编绎器会根据R.java文件，检查资源是否被使用，<strong>没有使用的资源不会打包到安装文件中</strong>。 </p><h2 id="res目录介绍"><a href="#res目录介绍" class="headerlink" title="res目录介绍"></a>res目录介绍</h2><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210506184320254.png" alt="image-20210506184320254"></p><p><strong>assets</strong>与res、res/raw文件夹都用于存放资源文件，那它们之间有什么区别呢？</p><table><thead><tr><th><strong>比较项</strong></th><th><strong>assets</strong>文件夹</th><th><strong>res</strong>文件夹</th><th><strong>res/raw</strong>文件夹</th></tr></thead><tbody><tr><td>是否在R.java中生成资源标记</td><td><strong>否</strong></td><td><strong>是</strong></td><td><strong>是</strong></td></tr><tr><td>是否能任意创建子文件夹</td><td><strong>能</strong></td><td><strong>不能</strong></td><td><strong>不能</strong></td></tr><tr><td>是否会编译成二进制文件</td><td><strong>不会</strong></td><td><strong>会</strong></td><td><strong>不会</strong></td></tr><tr><td>是否完全打包到安装文件中</td><td><strong>是</strong></td><td><strong>需判断</strong></td><td><strong>需判断</strong></td></tr><tr><td>访问方式</td><td><strong>AssetManager</strong>类，通过文件流读取</td><td>R.XX.XXX引用，通过Resource类相应方法读取</td><td>R.raw.xxx引用，通过Resource类相应方法读取</td></tr></tbody></table><h3 id="清单文件Mainfest-xml"><a href="#清单文件Mainfest-xml" class="headerlink" title="清单文件Mainfest.xml"></a>清单文件Mainfest.xml</h3><p>主要包含的信息：</p><ol><li>应用程序<strong>名称</strong>、<strong>图标</strong>、<strong>版本号</strong></li><li>应用程序的<strong>包名</strong>，该包名将会作为该应用的唯一标识；</li><li>应用程序所包含的<strong>组件</strong>，如Activity、Service等；</li><li>应用程序兼容的<strong>最低版本</strong>；</li><li>应用程序使用<strong>系统所需的权限声明</strong>；</li><li>其他程序<strong>访问该程序所需的权限声明</strong></li></ol><h2 id="Android应用程序执行过程"><a href="#Android应用程序执行过程" class="headerlink" title="Android应用程序执行过程"></a>Android应用程序执行过程</h2><ol><li>读取<strong>AndroidManifest.xml</strong>清单文件，设置应用程序的基本信息；</li><li>根据配置找到入口Activity并创建该类对象，然后自动调用其onCreate()方法，设置显示界面；</li><li>根据界面控件的属性在设备上显示相应的界面。</li></ol><h2 id="Android模拟器也可以安装从网上下载的apk应用程序，主要是通过android提供的adb命令来完成。"><a href="#Android模拟器也可以安装从网上下载的apk应用程序，主要是通过android提供的adb命令来完成。" class="headerlink" title="Android模拟器也可以安装从网上下载的apk应用程序，主要是通过android提供的adb命令来完成。"></a>Android模拟器也可以安装从网上下载的apk应用程序，主要是通过android提供的adb命令来完成。</h2><p> 通过 adb install MyAndroid.apk 命令，将该应用安装到模拟器中</p><p>如果没有启动模拟器也没有连接Android手机，则会提示“<strong>device not found</strong>”错误，否则开始安装应用；</p><p>如果模拟器上已有该应用，则会提示：<strong>INSTALL_FAILED_ALREADY_ EXISTS</strong>失败信息，需要先卸载该应用，再进行安装；</p><p>命令行中出现<strong>Success</strong>时，表示该应用安装成功，可以在功能菜单中找到相应的应用图标，并启动它。</p><h2 id="Android四大基本核心组件"><a href="#Android四大基本核心组件" class="headerlink" title="Android四大基本核心组件"></a>Android四大基本核心组件</h2><p><strong>Activity:</strong> 在Android应用中负责与用户进行交互的组件，我们称之为“活动”，一个Activity就是一个屏幕。 </p><p><strong>Service:</strong> 代表一个单独的Android组件，Service与Activity的区别在于：Service通常位于后台运行，它一般不需要与用户交互，一些Service组件没有图形用户界面。 </p><p><strong>BroadcastReceiver</strong>:代表广播消息接收器，非常类似于事件编程中的监听器，所监听的事件源是Android应用中的其他组件。</p><p><strong>ContentProvider</strong>:提供一种跨应用的数据交换的标准。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉排序树</title>
      <link href="2021/04/22/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
      <url>2021/04/22/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><h2 id="二叉排序树-BST"><a href="#二叉排序树-BST" class="headerlink" title="二叉排序树(BST)"></a>二叉排序树(BST)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;二叉排序树又称二叉查找树。二叉排序树或是一棵空树，或是一棵具有下列特性的非空二叉树：</p><p>&emsp;&emsp;1）若左子树非空，则左子树上所有结点关键字值均小于根结点的关键字值。</p><p>&emsp;&emsp;2）若右子树非空，则右子树上所有结点关键字值均大于根结点的关键字值。</p><p>&emsp;&emsp;3）左、右子树本身也分别是一棵二叉排序树</p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/二叉排序树.jpg" style="zoom: 80%;" /><span id="more"></span><p>&emsp;&emsp;左子树结点值    &lt;    根结点值    &lt;    右子树结点值，对二叉排序树进行中序遍历，可以得到一个递增的有序序列。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>&emsp;&emsp;二叉排序树的查找是从根结点开始，沿某个分支逐层向下进行比较的过程。若二叉树非空，则将给定值与根结点的关键字比较；若相等，则查找成功；若不等，则当前结点的关键字值大于给定关键字值时，在根节点的左子树查找，否则在根节点的右子树中查找。这是一个递归的过程。</p><p>&emsp;&emsp;二叉排序树的递归查找算法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BSTNode* <span class="title">BST_Search</span><span class="params">(BitTree T, ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( T-&gt;data == key)&#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( T-&gt;data &gt; key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Search</span>(T-&gt;lchild, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( T-&gt;data &lt; key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Search</span>(T-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;二叉排序树的非递归查找算法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BSTNode* <span class="title">BST_Search</span><span class="params">(BitTree T, ElemType key, BSTNode* &amp;p)</span></span>&#123;</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>( T != <span class="literal">NULL</span> &amp;&amp; key != T-&gt;data )&#123;</span><br><span class="line">        p = T;</span><br><span class="line">        <span class="keyword">if</span>( key &lt; T-&gt;data )&#123;</span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>&emsp;&emsp;二叉排序树是一种动态几何，其特点是树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字值等于给定值的结点时在进行插入的。</p><p>&emsp;&emsp;由于二叉排序树是递归定义的，因此插入结点的过程如下：若二叉排序树为空，则直接插入结点；否则，若关键字k小于根结点关键字，则插入左子树，若关键字大于根结点关键字，则插入右子树。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BST_Insert</span><span class="params">(BitTree&amp; T, ElemType k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        T = (BitTree*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BitTree));</span><br><span class="line">        T-&gt;data = k;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( T-&gt;data == k)&#123;<span class="comment">//树中存在相同关键字的结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;        </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( k &lt; T-&gt;key )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;lchild, k);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( k &gt; T-&gt;data )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;rchild, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E6%8F%92%E5%85%A5.png"></p><h3 id="二叉排序树的构造"><a href="#二叉排序树的构造" class="headerlink" title="二叉排序树的构造"></a>二叉排序树的构造</h3><p>&emsp;&emsp;构造一棵二叉树就是依次输入数据元素，并将它们插入二叉排序树中适当位置上的过程。具体过程：每读入一个元素，就建立一个结点，若二叉排序树非空，则将新结点的值与根结点的值作比较，若小于根结点的值，则插入左子树，否则插入右子树；若二叉排序树为空，则将新结点作为二叉排序树的根结点。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST_Create</span><span class="params">(BitTree&amp; T, ElemType str[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = <span class="built_in"><span class="keyword">sizeof</span></span>(str)/<span class="built_in"><span class="keyword">sizeof</span></span>(str[<span class="number">0</span>]);</span><br><span class="line">    T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( i &lt; sz )&#123;</span><br><span class="line">        <span class="built_in">Create_BST</span>(T,str[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除（难点）"><a href="#删除（难点）" class="headerlink" title="删除（难点）"></a>删除（难点）</h3><p>&emsp;&emsp;在二叉排序树中删除一个结点时，不能把以结点为根的子树上的结点都删除，必须先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会丢失。</p><p>&emsp;&emsp;删除操作按三种情况来处理：</p><ol><li>若被删除结点 x 是叶结点，则直接删除，不会破坏二叉排序树的性质</li><li>若结点 x 只有一棵左子树或右子树，则让 x 的子树成为 x 父节点 的子树，替代 x 的位置</li><li>若结点 x 有左、右两棵子树，则令 x 的直接后继（或直接前驱）替代 x ，然后从二叉排序树中删除这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。</li></ol><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%88%A0%E9%99%A4.jpg"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历序列的下一个节点，即比当前节点大的最小节点，简称后继节点。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">successor</span><span class="params">(BSTTree* p)</span></span>&#123;</span><br><span class="line">    p = p-&gt;rchild;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;lchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历序列的前一个节点，即比当前节点小的最大节点，简称前驱节点。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">predecessor</span><span class="params">(BSTTree* p)</span></span>&#123;</span><br><span class="line">    p = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BSTNode* <span class="title">BST_Delete</span><span class="params">(BSTTree&amp; T, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( x &lt; T-&gt;data )&#123;<span class="comment">//要删除的在左边</span></span><br><span class="line">            T-&gt;lchild = <span class="built_in">BST_Delete</span>(T-&gt;lchild, x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( x &gt; T-&gt;data )&#123;<span class="comment">//要删除的在右边</span></span><br><span class="line">T-&gt;rchild = <span class="built_in">BST_Delete</span>(T-&gt;rchild, x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>( T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)&#123;<span class="comment">//叶子结点</span></span><br><span class="line">                T = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( T-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//如果该节点不是叶子节点且有右节点，则用它的后继结点的值替代，然后删除后继结点               </span></span><br><span class="line">                T-&gt;data = <span class="built_in">successor</span>(T);</span><br><span class="line">                T-&gt;rchild = <span class="built_in">BST_Delete</span>(T-&gt;rchild, T-&gt;data);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果该节点不是叶子节点且只有左节点，则用它的前驱节点的值替代，然后删除前驱节点               </span></span><br><span class="line">                T-&gt;data = <span class="built_in">predecessor</span>(T);</span><br><span class="line">                T-&gt;lchild = <span class="built_in">BST_Delete</span>(T-&gt;lchild, T-&gt;data);                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉排序树的查找效率"><a href="#二叉排序树的查找效率" class="headerlink" title="二叉排序树的查找效率"></a>二叉排序树的查找效率</h3><p>&emsp;&emsp;对于高度为h的二叉排序树，插入和删除操作的运行时间都是O(h)。但在最坏情况下，构造二叉排序树的输入序列是有序的，则会形成一个倾斜的单支树，此时二叉排序树的性能新竹变坏，树的高度也增加为元素个数n。</p><p>&emsp;&emsp;二叉排序树的查找算法平均查找长度，主要取决于树的高度，即与二叉树的形态有关。若退化成链表，则为O（n）;若为平衡二叉树，则为O（log<sub>2</sub>n)。</p><p>&emsp;&emsp;相同的关键字其插入顺序不同可能生成不同的二叉排序树。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列（Queue）</title>
      <link href="2021/04/22/%E9%98%9F%E5%88%97/"/>
      <url>2021/04/22/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h1><h2 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;队列（Queue）。队列简称队。是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为入队或进队；删除元素称为出队或离队。其操作特性为先进后出（First In Last Out，FIFO），并且只允许在队尾进，队头出。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E9%98%9F%E5%88%97.jpg"></p><p>&emsp;&emsp;队头（Front）：允许删除的一端，又称队首</p><p>&emsp;&emsp;队尾（Rear）：允许插入的一端</p><p>&emsp;&emsp;空队列：不包含任何元素的空表</p><span id="more"></span><h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><p>&emsp;&emsp;1）InitQueue（&amp;Q）：初始化队列，构造一个空队列Q</p><p>&emsp;&emsp;2）QueueEmpty（Q）：判断一个队列是否为空</p><p>&emsp;&emsp;3）EnQueue（&amp;Q，x）：入队，若队列未满，则将x加入使之成为新队尾</p><p>&emsp;&emsp;4）DeQueue（&amp;Q，&amp;x）：出队，若队列非空，则将队首元素删除，并用x返回</p><p>&emsp;&emsp;5）GetHead(Q，&amp;x)：读队头元素，若栈顶元素非空，则用x返回栈顶元素</p><h2 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h2><h3 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h3><p>&emsp;&emsp;队列的顺序实现市值分配一块连续的存储单元存放队列中的元素，并附设两个指针 front 和 rear 分别指示队头元素和队尾元素的位置。<strong>设队头指针指向队头元素，队尾指针指向队尾元素的下一个位置。</strong></p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E9%98%9F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C.jpg"></p><p>&emsp;&emsp;队列的顺序存储类型可描述为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;初始状态（队空）：Q.front == Q.rear == 0;</p><p>&emsp;&emsp;进队操作：队不满时，先送值到队尾元素，将队尾指针加1</p><p>&emsp;&emsp;出队操作：队非空时，先删除队头元素，再将队头指针加1</p><p>&emsp;&emsp;由上可知，Q.front == Q.rear == 0 可以作为队列的判空条件，但能否能用 Q.rear == MAXSIZE 作为队列已满的条件呢？显然是不行的，因为队尾指针可能已经到了最尾端，但是队头指针可能不在初始位置，而是在队列的中间，这时入队出现“上溢”，但这种溢出并不是真正的溢出，data数组中仍存在可以放置元素的位置，所以为“假溢出”。</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>&emsp;&emsp;前面指出了队列的缺点，这里就引出循环队列的概念。将队列臆造成一个环状的空间，即把存储队列元素的表从按逻辑上视为一个环，称为循环队列。当队首指针 Q.front  == MAXSIZE - 1,再前景一个位置就自动到0，这可以利用除法取余运算（%） 来实现。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.jpg"></p><p>&emsp;&emsp;初始化时：Q.front = Q.rear = 0；</p><p>&emsp;&emsp;队首指针进1：Q.front = （Q.front + 1) % MAXSIZE；</p><p>&emsp;&emsp;队尾指针进1：Q.rear = （Q.rear + 1）% MAXSIZE；</p><p>&emsp;&emsp;队列长度：（Q.front + MAXSIZE - Q.rear) % MAXSIZE；</p><p>循环队列如何判断队满还是队空？</p><p>&emsp;&emsp;1）一般的做法是：入队时少入对一个队列单元，约定“队尾指针的下一个标志是队头指针 作为 队满的标志“：</p><p>&emsp;&emsp;&emsp;&emsp;队空条件：Q.front  == Q.rear</p><p>&emsp;&emsp;&emsp;&emsp;队满条件：(Q.rear + 1) % MAXSIZE == Q.front</p><p>&emsp;&emsp;&emsp;&emsp;队列长度：（Q.rear - Q.front + MAXSIZE ）% MAXSIZE</p><p>&emsp;&emsp;2）在类型中添加表示成员个数的数据成员。队空时 Q.size == 0；队满时 Q.size == MAXSIZE</p><p>&emsp;&emsp;3）类型中添加tag 数据成员，以区分是队满还是对空。tag ==0 ，若因删除导致Q.front == Q.rear ,则为队空；若tag == 1，若因添加导致Q.front == Q.rear，则为队满。</p><h3 id="循环队列的操作"><a href="#循环队列的操作" class="headerlink" title="循环队列的操作"></a>循环队列的操作</h3><p>&emsp;&emsp;1、初始化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue&amp; Q)</span></span>&#123;</span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;2、判队空</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Q.front == Q.rear)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;3、入队</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue&amp; Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (Q.rear + <span class="number">1</span>) % MAXSIZE == Q.front )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = ( Q.rear + <span class="number">1</span>) % MAXSIZE;<span class="comment">//队尾指针加1取模，这步操作很容易写错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;4、出队</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue&amp; Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Q.rear == Q.front )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAXSIZE;<span class="comment">//队头指针加1取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><h3 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h3><p>&emsp;&emsp;队列的链式存储又称为 链队列，它实际上是一个同时带有一个队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向最后一个结点。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97.png"></p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;不带头结点的链式队列</p><p>&emsp;&emsp;队列的链式存储类型可描述为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front, *rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当Q.front  == nullptr 且 Q.rear == nullptr 时，链式队列为空。</p><p>&emsp;&emsp;出队时，若不空，则将队头元素删除，Q.front 指向下一个结点；入队时，新建一个结点，将新结点插入到链队列的尾端，并让Q.rear指向这个新插入的结点。</p><p>&emsp;&emsp;不带头结点的链式队列在操作上往往比较麻烦，因此通常将链式队列设计成一个带头结点的单链表，这样插入和删除就统一了。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97.jpg"></p><h3 id="链式队列的基本操作"><a href="#链式队列的基本操作" class="headerlink" title="链式队列的基本操作"></a>链式队列的基本操作</h3><p>&emsp;&emsp;1、初始化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，Q.front 和 Q.rear 同时指向头结点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;2、判队空</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Q.front == Q.rear)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;3、入队</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(LinkQueue&amp; Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先生成一个新结点</span></span><br><span class="line">    LinkNode* s = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LinkNode));</span><br><span class="line">    <span class="comment">//结点各个域赋值</span></span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//尾指针的next域指针指向新结点,将新结点插入到队尾</span></span><br><span class="line">    Q.rear-&gt;next = s;</span><br><span class="line">    <span class="comment">//修改队尾指针</span></span><br><span class="line">    Q.rear = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;4、出队</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue&amp; Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Q.rear == Q.front )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode* p = Q.front-&gt;next; <span class="comment">//因为有头结点，所以队头节点为Q.front-&gt;next</span></span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>( Q.rear == p )&#123;           <span class="comment">//只剩一个结点，删除后变空只剩头结点</span></span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>&emsp;&emsp;双端是允许两端都可以进行入队和出队操作的队列。逻辑结构仍然是线性结构，将队列的两端分别称为前端和后端，连段都可以入队和出队。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97.png"></p><p>&emsp;&emsp;在双端队列进队时，前端进的元素排列在队列中后端进的元素的前面，后端进的元素排在前端进的元素的后面。在双端队列中，无论是前端还是后段，先出去的元素排列在后出去的元素前面。</p><p>&emsp;<strong>&emsp;输出受限的双端队列</strong>：有一端不能进行删除，这样的双端队列叫做 输出受限的双端队列。</p><p>&emsp;&emsp;<strong>输入受限的双端队列</strong>：有一端不能进行插入，这样的双端队列叫做 输出受限的双端队列。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%8F%97%E9%99%90%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表</title>
      <link href="2021/04/22/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>2021/04/22/%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p>&emsp;&emsp;由于顺序表的插入、删除操作需要移动大量的元素，影响运行效率，由此引进了线性表的链式存储。链式存储线性表时，不需要使用地址连续的存储单元，对线性表的插入删除不需要移动元素，而只需要修改指针。</p><h2 id="单链表-1"><a href="#单链表-1" class="headerlink" title="单链表"></a>单链表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;每个链表结点，除了存放元素自身的信息外，还需要存放一个指向后继的指针。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;<span class="comment">//LNode,LinkList 其实是一样的，只是表示结点和链表更方便</span></span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="emsp-emsp-不带头结点的单链表"><a href="#emsp-emsp-不带头结点的单链表" class="headerlink" title="&emsp;&emsp;不带头结点的单链表"></a>&emsp;&emsp;不带头结点的单链表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitLinklist</span><span class="params">(LinkList&amp; L)</span></span>&#123;</span><br><span class="line">    L = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="带头结点的单链表"><a href="#带头结点的单链表" class="headerlink" title="带头结点的单链表"></a>带头结点的单链表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitLinkList</span><span class="params">(LinkList&amp; L)</span></span>&#123;</span><br><span class="line">    L = (Lnode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));<span class="comment">//生成一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>( L == <span class="literal">nullptr</span>)&#123;<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//头结点之后暂时没有任何结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>头结点和头指针的区别</strong>：</p><p>&emsp;&emsp;不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。</p><p>&emsp;&emsp;<strong>引入头结点后的优点</strong>：</p><p>&emsp;&emsp;1）由于头结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作和在链表的其他位置上的操作一致，无需进行特殊处理。</p><p>&emsp;&emsp;2）无论链表是否为空，其头指针都指向头结点的非空指针（空表中头指针的指针域为空），因此空表和非空表的处理也就得到了统一。</p><h3 id="建立单链表"><a href="#建立单链表" class="headerlink" title="建立单链表"></a>建立单链表</h3><h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%A4%B4%E6%8F%92%E6%B3%95.jpg"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList&amp; L,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">L-&gt;next = <span class="literal">nullptr</span>;  <span class="comment">//创建一个带头结点的空链表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));   <span class="comment">//新建一个结点</span></span><br><span class="line">cin &gt;&gt; s-&gt;data;</span><br><span class="line"></span><br><span class="line">s-&gt;next = L-&gt;next;  <span class="comment">//头结点后插入新结点</span></span><br><span class="line">L-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;头插法建立的链表时，读入数据的顺序与生成的链表数据是相反的，总的时间复杂度为O（n）。</p><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%B0%BE%E6%8F%92%E6%B3%95.jpg"></p><p>&emsp;&emsp;在尾插法的实现过程中，要创建一个链表尾指针，标注链表的最后一个节点，这样就与新加入的结点联系起来，方便操作。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(ListLink&amp; L, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    LNode* tail = (LNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));<span class="comment">//生成表尾指针</span></span><br><span class="line">    tail = L;<span class="comment">//表尾指针指向头结点</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));<span class="comment">//新建结点</span></span><br><span class="line">        cin &gt;&gt; s-&gt;data;</span><br><span class="line">        tail-&gt;next = s;<span class="comment">//将尾指针的下一个结点指向新建结点</span></span><br><span class="line">        tail = s;<span class="comment">//尾指针后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//尾指针后继设为空</span></span><br><span class="line">    reutrn L;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;尾插法建立链表时，读入数据的顺序和生成的链表数据是相反的，中的时间复杂度为O（n）。</p><h3 id="按序号查找结点值"><a href="#按序号查找结点值" class="headerlink" title="按序号查找结点值"></a>按序号查找结点值</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LNode* <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    LNode* p = L-&gt;next;<span class="comment">//指针p指向头结点</span></span><br><span class="line">    <span class="keyword">if</span>( i == <span class="number">0</span>)&#123;<span class="comment">//相当于返回头结点</span></span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( i &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">//i无效，返回空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( p &amp;&amp; count &lt; i)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;时间复杂度为O（n）。</p><h3 id="按值查找表结点"><a href="#按值查找表结点" class="headerlink" title="按值查找表结点"></a>按值查找表结点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LNode* <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span></span>&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>( p != <span class="literal">nullptr</span> &amp;&amp; p-&gt;data != e)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;时间复杂度为O（n）。</p><h3 id="插入结点（后插）"><a href="#插入结点（后插）" class="headerlink" title="插入结点（后插）"></a>插入结点（后插）</h3><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5.jpg"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListLNode_Insert</span><span class="params">(LinkList&amp; L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    LNode* p = <span class="built_in">GetElem</span>(L, i<span class="number">-1</span>);<span class="comment">//找到插入位置的前驱结点</span></span><br><span class="line">    LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该算法主要的时间花费在寻找第i-1个结点上，时间复杂度为O（n）,若在给定的结点后插入新结点，则时间复杂度为O（1）。</p><h3 id="插入结点（前插）"><a href="#插入结点（前插）" class="headerlink" title="插入结点（前插）"></a>插入结点（前插）</h3><p>&emsp;&emsp;前插操作：其实就是在该节点后面插入一个新结点，再将两个结点的数据域交换，就轻松的完成了后插。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListLNode_ForwardInsert</span><span class="params">(LinkList&amp; L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    LNode* p = <span class="built_in">GetElem</span>(L,i);<span class="comment">//找到第i个元素</span></span><br><span class="line">    LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="built_in">swap</span>(s-&gt;data,p-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListLNode_Delete</span><span class="params">(LinkList&amp; L, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    LNode* p = <span class="built_in">GeElem</span>(L,i<span class="number">-1</span>);<span class="comment">//找到第i-1个元素,即*q的前驱结点</span></span><br><span class="line">    LNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除结点-p"><a href="#删除结点-p" class="headerlink" title="删除结点 *p"></a>删除结点 *p</h3><p>&emsp;&emsp;删除结点 *p 的操作**可用删除 <em>p 的后继结点操作来实现，实际上就是将后继结点的值赋给 <em>p ，然后删除后继结点。</em></em></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListLNode_Delete</span><span class="params">(LinkList&amp; L, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    LNode* p = <span class="built_in">GeElem</span>(L,i);<span class="comment">//找到第i-1个元素,即*q的前驱结点</span></span><br><span class="line">    LNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;data = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要注意插入删除时链表边界情况的处理。</p><h3 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h3><p>&emsp;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkListLength</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显示链表所有结点信息"><a href="#显示链表所有结点信息" class="headerlink" title="显示链表所有结点信息"></a>显示链表所有结点信息</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Display</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>( p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将单链表逆转"><a href="#将单链表逆转" class="headerlink" title="将单链表逆转"></a>将单链表逆转</h3><p>&emsp;&emsp;第一种方法：双指针法</p><p>&emsp;&emsp;创建两个指针，cur和pre，pre 在右，cur在左。每次让pre的next指针指向cur，完成一次局部反转，之后两个指针同时向右移，直至链表尾。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E9%80%86%E8%BD%AC%E9%93%BE%E8%A1%A8.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Reverse</span><span class="params">(LinkList&amp; L)</span></span>&#123;</span><br><span class="line">    LNode* cur = Nullptr;<span class="comment">//最开始cur指向空</span></span><br><span class="line">    LNode* pre = L-&gt;next;<span class="comment">//pre指向链表中第一个存储信息的结点</span></span><br><span class="line">    <span class="keyword">while</span>( pre != <span class="literal">nullptr</span> )&#123;</span><br><span class="line">        LNode* temp = pre-&gt;next;<span class="comment">//创建临时结点temp，提前保存下一个结点的地址</span></span><br><span class="line">        pre-&gt;next = cur;</span><br><span class="line">        cur = pre;</span><br><span class="line">        pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二种方法：递归法</p><p>&emsp;&emsp;后续展开讲解。。。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建第一个窗口</title>
      <link href="2021/04/22/%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3/"/>
      <url>2021/04/22/%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="emsp-emsp"><a href="#emsp-emsp" class="headerlink" title="&emsp;&emsp;"></a>&emsp;&emsp;</h1>]]></content>
      
      
      <categories>
          
          <category> DirectX3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DirectX3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>财富自由之路</title>
      <link href="2021/04/22/%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/"/>
      <url>2021/04/22/%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="1、考虑自己的事业"><a href="#1、考虑自己的事业" class="headerlink" title="1、考虑自己的事业"></a>1、考虑自己的事业</h1><p><strong>1.</strong>   <strong>填制个人财务报表</strong></p><p><strong>2.</strong>   <strong>设定财务目标：</strong></p><ol><li>  在未来的12个月内：</li></ol><p>​          i.      我想减少我的债务   元</p><p>​         ii.      我想增加我名下资产的现金流或者增加被动收入  元/月</p><ol start="2"><li>  我的5年目标是：</li></ol><p>​          i.      增加我资产得到现金流到   元/月</p><p>​         ii.      在我的资产项目中拥有下列投资（如房地产、股票、企业、等等）</p><ol start="3"><li>  用5年目标改变你今天开始的5年内的损益表和资产负债表</li></ol> <span id="more"></span><h1 id="2、控制你的现金流"><a href="#2、控制你的现金流" class="headerlink" title="2、控制你的现金流"></a>2、控制你的现金流</h1><p><strong>1.</strong>   <strong>先支付自己</strong></p><p>​        从你的每份工资中或每份其他来源的收入中拿出一个固定份额，把这笔钱存入投资储蓄账户。一旦你的钱存入这个账户，就永远不要取出它，直到你准备用它投资为止。</p><p><strong>2.</strong>   <strong>集中精力减少你的个人债务</strong></p><h1 id="3、了解风险与冒险的区别"><a href="#3、了解风险与冒险的区别" class="headerlink" title="3、了解风险与冒险的区别"></a>3、了解风险与冒险的区别</h1><p>​        什么才是正确的现金流管理？</p><p>​        正确的现金流管理基于对资产和负债之间区别的认识，而不是你的银行经理告诉你的定义</p><p><strong>1.</strong>   <strong>用自己的话来定义风险</strong></p><p>​        拥有每月产生现金流的资产对你而言有风险吗？</p><p>​        花时间学习财务知识对你来说有风险吗？</p><p><strong>2.</strong>   <strong>每周花5个小时做下列事情中的一件或者更多件：</strong></p><p>​     i.      读报纸的商业版和《华尔街日报》</p><p>​    ii.      听电视或广播中的财经新闻</p><p>   iii.      听关于投资和财务知识的教学磁带</p><p>   iv.      读财经杂志</p><p>​    v.      玩现金流游戏</p><h1 id="4、决定你想成为那种类型的投资者"><a href="#4、决定你想成为那种类型的投资者" class="headerlink" title="4、决定你想成为那种类型的投资者"></a>4、决定你想成为那种类型的投资者</h1><p>在成为第5级或第6级投资者之前，你要先成为一名老练的第4投资者，小规模地开始并继续你的教育。</p><ol><li><p>   参加财务研讨班和学习班</p></li><li><p>   在你的地区寻找代售的房地产</p></li><li><p>  会见几位股票经纪人</p></li><li><p>  订阅投资通讯并研究</p></li><li><p>继续阅读、听磁带和看录像带，看财经类节目，玩现金流游戏**</p></li></ol><h1 id="5、寻找导师"><a href="#5、寻找导师" class="headerlink" title="5、寻找导师"></a>5、寻找导师</h1><ol><li>寻找导师—找出既在投资领域又在企业领域中的有可能成为你的导师的人</li></ol><p>​       找出榜样，向他们学习</p><p>​       找出反面的示范，从他们身上吸取教训</p><ol start="2"><li>  你与之交往的人就是你的未来</li></ol><p>​       列出一个名单，并写出他们所在的象限</p><h1 id="6、将失望转化为力量"><a href="#6、将失望转化为力量" class="headerlink" title="6、将失望转化为力量"></a>6、将失望转化为力量</h1><ol><li><p>犯错误</p></li><li><p>  投一点钱进去，从小规模开始</p></li><li><p>采取行动这一步的关键就是采取行动*</p></li></ol><h1 id="7、信心的力量（保持自信）"><a href="#7、信心的力量（保持自信）" class="headerlink" title="7、信心的力量（保持自信）"></a>7、信心的力量（保持自信）</h1>]]></content>
      
      
      <categories>
          
          <category> 财富自由 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 财富自由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win32基础</title>
      <link href="2021/04/22/Win32%E5%9F%BA%E7%A1%80/"/>
      <url>2021/04/22/Win32%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是窗口？"><a href="#什么是窗口？" class="headerlink" title="什么是窗口？"></a>什么是窗口？</h1><p>&emsp;&emsp;窗口很重要，windows操作系统与用户的交互其实主要靠这个窗口。通常的我们认为，就是我们打开windows应用程序时，弹出来的窗口，如下：</p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/window.png" style="zoom: 50%;" /><p>&emsp;&emsp;这种类型的窗口称为 应用程序窗口 或 主窗口。它通常具有带有标题栏，“<strong>最小化</strong>和<strong>最大化”</strong>按钮以及其他标准UI元素的框架。该框架称为窗口的非客户区，之所以这样称呼，是因为操作系统管理窗口的该部分。框架内的区域是客户区域。这是程序管理的窗口的一部分。</p><p>但你可能想不到，<span id="more"></span><img src="https://docs.microsoft.com/en-us/windows/win32/learnwin32/images/window02.png" alt="控制窗口的屏幕截图"> 这也是一种窗口，没错。UI控件和应用程序窗口之间的主要区别在于，控件本身并不存在。而是，控件相对于应用程序窗口放置。当您拖动应用程序窗口时，控件将随其移动。同样，控件和应用程序窗口可以相互通信。</p><p>&emsp;&emsp;当您考虑<em>窗口时</em>，不要简单地考虑应用程序窗口。取而代之的是，将窗口视为一种编程构造，它可以：</p><ul><li>占据屏幕的特定部分。</li><li>在给定的时刻可能可见或不可见。</li><li>知道如何绘制自己。</li><li>响应来自用户或操作系统的事件。</li></ul><h1 id="Parent窗口和Owner窗口"><a href="#Parent窗口和Owner窗口" class="headerlink" title="Parent窗口和Owner窗口"></a>Parent窗口和Owner窗口</h1><p>&emsp;&emsp;对于UI控件，控件窗口被称为应用程序窗口的<em>子级</em>。应用程序窗口是控制窗口的<em>父级</em>。父窗口提供用于定位子窗口的坐标系。拥有父窗口会影响窗口外观的各个方面；例如，子窗口将被剪切，以使子窗口的任何部分都不会出现在其父窗口的边界之外。</p><p>&emsp;&emsp;另一个关系是应用程序窗口和模式对话框窗口之间的关系。当应用程序显示模式对话框时，应用程序窗口是owner窗口，而该对话框是owned窗口。拥有的窗口始终显示在其owner窗口的前面。当所有者最小化时，它是隐藏的，并且与所有者同时被销毁。</p><p>&emsp;&emsp;简而言之就是：窗口和UI空间之间的关系就像 Parent/Child；窗口和模式对话框之间的关系就是Owner/Owned。</p><p>&emsp;&emsp;如下：</p><img src="https://docs.microsoft.com/en-us/windows/win32/learnwin32/images/window03.png" alt="带有对话框的应用程序的屏幕截图" style="zoom: 80%;" /><p>&emsp;&emsp;他们之间的关系：</p><img src="https://docs.microsoft.com/en-us/windows/win32/learnwin32/images/window04.png" alt="该图显示了父母/孩子和所有者/拥有的关系" style="zoom:80%;" /><h1 id="Window-Handles"><a href="#Window-Handles" class="headerlink" title="Window Handles"></a>Window Handles</h1><p>&emsp;&emsp;Windows是对象（它们同时具有代码和数据），但是它们不是C ++类。相反，程序使用称为<em>handle</em>的值来引用窗口。手柄是不透明的类型。本质上，它只是操作系统用来标识对象的数字。可以将Windows描绘成具有已创建的所有窗口的大表。它使用此表通过其句柄查找窗口。（是否确实是内部工作方式并不重要。）窗口句柄的数据类型为<strong>HWND</strong>，通常称为“ aitch-wind”。窗口句柄由创建窗口的函数（<a href="https://docs.microsoft.com/en-us/windows/desktop/DirectShow/cbasewindow-docreatewindow"><strong>CreateWindow</strong></a>和<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-createwindowexa"><strong>CreateWindowEx）返回</strong></a>。</p><p>  要在窗口上执行操作，通常会调用一些将<strong>HWND</strong>值作为参数的函数。例如，要在屏幕上重新放置窗口，请调用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-movewindow"><strong>MoveWindow</strong></a>函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MoveWindow</span><span class="params">(HWND hWnd, <span class="keyword">int</span> X, <span class="keyword">int</span> Y, <span class="keyword">int</span> nWidth, <span class="keyword">int</span> nHeight, BOOL bRepaint)</span></span>;</span><br></pre></td></tr></table></figure><p>  第一个参数是您要移动的窗口的句柄。其他参数指定窗口的新位置以及是否应重绘窗口。</p><p>  请记住，句柄不是指针。如果<em>hwnd</em>是包含句柄的变量，则尝试通过写入来取消引用该句柄<code>*hwnd</code>是错误的。</p><h1 id="屏幕和窗口坐标"><a href="#屏幕和窗口坐标" class="headerlink" title="屏幕和窗口坐标"></a>屏幕和窗口坐标</h1><p>&emsp;&emsp;坐标以与设备无关的像素为单位进行测量。</p><p>&emsp;&emsp;根据任务的不同，可能会测量相对于屏幕，相对于窗口（包括框架）或相对于窗口的工作区的坐标。例如，您将使用屏幕坐标将窗口放置在屏幕上，而您将使用客户端坐标在窗口内绘制。在每种情况下，原点（0，0）始终是该区域的左上角。</p><p><img src="https://docs.microsoft.com/en-us/windows/win32/learnwin32/images/coordinates01.png" alt="显示屏幕，窗口和客户坐标的插图"></p><h1 id="Win32常见宏定义"><a href="#Win32常见宏定义" class="headerlink" title="Win32常见宏定义"></a>Win32常见宏定义</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">wchar_t</span> WCHAR;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">Typedef</th><th align="center">Definition</th></tr></thead><tbody><tr><td align="center">CHAR</td><td align="center">char</td></tr><tr><td align="center">PSTR or LPSTR</td><td align="center">char*</td></tr><tr><td align="center">PCSTR or LPCSTR</td><td align="center">const char*</td></tr><tr><td align="center">PWSTR or LPWSTR</td><td align="center">wchar_t*</td></tr><tr><td align="center">PCWSTR or LPCWSTR</td><td align="center">const wchar_t*</td></tr></tbody></table><p>&emsp;&emsp; <strong>SetWindowTextA</strong>采用ANSI字符串。<strong>SetWindowTextW</strong>采用Unicode字符串。</p><p>在内部，ANSI版本将字符串转换为Unicode。Windows标头还定义了一个宏，当<code>UNICODE</code>定义了预处理器符号时，该宏可以解析为Unicode版本，否则为ANSI版本。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SetWindowText  SetWindowTextW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SetWindowText  SetWindowTextA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DirectX3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DirectX3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4网络基础</title>
      <link href="2021/04/22/UE4%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>2021/04/22/UE4%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Actor-replication可以简单的理解为："><a href="#Actor-replication可以简单的理解为：" class="headerlink" title="Actor replication可以简单的理解为："></a><strong>Actor replication</strong>可以简单的理解为：</h2><p>在服务器上面生成一份一模一样的actor或者是其他数据，然后传递给每个客户端，其他玩家就都可以看到这个物体。</p><p>C++开启方式：</p><p>​        在c++类 构造函数中，添加 ：bReplicates = true;</p><h2 id="Property-replicateion"><a href="#Property-replicateion" class="headerlink" title="Property replicateion :"></a><strong>Property replicateion</strong> :</h2><p>​        添加头文件：#include “Net/UnrealNetwork.h”</p><p>​        C++ 开启方式：</p><p>属性前面添加一个宏定义：UPROPERTY（Replicated）</p><p>在cpp 文件中，在 GetLifetimeReplicatedProps 函数中添加：DOREPLIFETIME（类名称，变量名）</p><p> 不需要声明该函数</p><span id="more"></span><h2 id="RepNotify："><a href="#RepNotify：" class="headerlink" title="RepNotify："></a><strong>RepNotify</strong>：</h2><p>如果一个变量设置为Rep_Notify，当变量发生复制时，服务端和收到该值的客户端都可以调用一个自定义的函数</p><p>​        注意C++的版本略有区别，仅在客户端调用函数</p><p>设置方法：</p><p>​        蓝图：设置为Rep_Notify</p><p>​        C++：UPROPERTY(ReplicatedUsing = 执行的函数名)</p><p>​        例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing = OnRep_Armor)</span><br><span class="line"><span class="keyword">float</span> Armor = <span class="number">100.f</span>;</span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRep_Armor</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同时也不要忘记加上PropertyReplicattion 的一些设置</p><p>​                </p>]]></content>
      
      
      <categories>
          
          <category> Unreal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE4网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈（Stack）</title>
      <link href="2021/04/22/%E6%A0%88/"/>
      <url>2021/04/22/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h1><h2 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;只允许在一端进行插入或删除操作的线性表。首先，栈是一种线性表，但限定这种线性表只能在某一段进行插入和删除操作。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E6%A0%88.jpg"></p><p>&emsp;&emsp;栈顶（Top）：线性表允许进行插入和删除的一端。</p><p>&emsp;&emsp;栈底（Bottom）：固定的，不允许进行插入和删除的另一端。</p><p>&emsp;&emsp;空栈：不含任何元素。</p><span id="more"></span><p>&emsp;&emsp;如上图：a1为栈底元素，an为栈顶元素。由于栈只能在栈顶进行插入和删除操作，故进栈次序依次为a1，a2，… ,an 而出栈次序为an，…，a2，a1。栈的明显的操作特征为后进先出（Last In First Out，LIFO）,故又称 后进先出的线性表。</p><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><p>&emsp;&emsp;1）InitStack（&amp;S）：初始化空栈S</p><p>&emsp;&emsp;2）StackEmpty（S）：判断一个栈是否为空</p><p>&emsp;&emsp;3）Push（&amp;S，x）：进栈，若栈未满，则将x加入使之成为新栈顶</p><p>&emsp;&emsp;4）Pop（&amp;S，&amp;x）：出栈，若栈非空，则将栈顶元素，并用x返回</p><p>&emsp;&emsp;5）GetTop(S，&amp;x)：读栈顶元素，若栈顶元素非空，则用x返回栈顶元素</p><p>&emsp;&emsp;6）DestroyStack(&amp;S)：销毁栈，并释放栈S占用的存储空间</p><h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><h3 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h3><p>&emsp;&emsp;采用顺序存储的栈称为<strong>顺序栈</strong>，它是利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶的位置。</p><p>&emsp;&emsp;栈的顺序存储类型可以用以下表示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100<span class="comment">//栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MAXSIZE];<span class="comment">//存放栈中元素</span></span><br><span class="line">    <span class="keyword">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;栈顶指针：S.top，初始时设置S.top = -1；栈顶元素：S.data[S.top]；</p><p>&emsp;&emsp;进栈操作：栈不满时，栈指针加1，再送值到栈顶元素</p><p>&emsp;&emsp;出栈操作：栈非空时，先去栈顶元素值，再将栈顶指针减1</p><p>&emsp;&emsp;栈空条件：S.top == -1</p><p>&emsp;&emsp;栈满条件：S.top == MAXSIZE - 1</p><p>&emsp;&emsp;栈长：S.top + 1</p><h3 id="顺序栈的基本运算"><a href="#顺序栈的基本运算" class="headerlink" title="顺序栈的基本运算"></a>顺序栈的基本运算</h3><p>&emsp;&emsp;<img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E8%BF%9B%E6%A0%88.jpg"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack&amp; S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;<span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判栈空"><a href="#判栈空" class="headerlink" title="判栈空"></a>判栈空</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack&amp; S)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( S.top == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack&amp; S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S.top == MAXSIZE - <span class="number">1</span> )&#123;<span class="comment">//栈满，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    S.top ++ ;<span class="comment">//栈顶指针加1</span></span><br><span class="line">    S.data[S.top] = x;<span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack&amp; S, ElemType&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S.top == <span class="number">-1</span> )&#123;<span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    S.top --;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读栈顶元素"><a href="#读栈顶元素" class="headerlink" title="读栈顶元素"></a>读栈顶元素</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack&amp; S,ElemType&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S.top == <span class="number">-1</span> )&#123;<span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意：若栈顶指针初始化为S.top = 0，即栈顶指针指向栈顶元素的下一个位置，则入栈操作变为S.data[S.top++]，出栈操作为x = S.data[–S.top]。因为栈顶指针若初始化为 0 时，则栈顶指针始终指向顺序栈将要入栈的位置，也就是栈顶指针的下标就是入栈元素的下标。</p><h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><p>&emsp;&emsp;利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数据空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%85%B1%E4%BA%AB%E6%A0%88.png"></p><p>&emsp;&emsp;两个栈的栈顶指针都指向栈顶元素，top1 = -1 时，stack1 为空，top2 = MAXSIZE - 1 时，stack2 为空；仅当两个栈顶指针相邻（top1 - top2 == 1)时，判断栈满。当stack1进栈时top1先加1再赋值，stack2进栈时top2先减1再赋值；出栈正好相反。</p><p>&emsp;&emsp;共享栈是为了更有效地利用存储空间，两个栈的空间正好互相调节，只有在整个存储空间被占满时才发生上溢。存取数据的时间复杂度均为O(1)，所以对存取效率没有什么影响。</p><h2 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h2><p>&emsp;&emsp;采用链式存储的栈称为<strong>链栈</strong>，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头结点，top指向栈顶元素，</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E9%93%BE%E6%A0%88.jpg"></p><p>&emsp;&emsp;链栈的存储类型可描述为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode, *LinkStack;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列的应用（括号匹配，表达式求值，层次遍历）</title>
      <link href="2021/04/22/%E5%BA%94%E7%94%A8/"/>
      <url>2021/04/22/%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h1><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="验证括号的正确性"><a href="#验证括号的正确性" class="headerlink" title="验证括号的正确性"></a>验证括号的正确性</h3><p>&emsp;&emsp;题目很简单就是输入一串字符，判断字符中的括号是否合法。直接上代码：<span id="more"></span></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(Stack&amp; S)</span> </span>&#123;</span><br><span class="line">S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(Stack S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(Stack&amp; S, ElemType x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == MAXSIZE - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">S.top++;</span><br><span class="line">S.data[S.top] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(Stack&amp; S, ElemType&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">x = S.data[S.top];</span><br><span class="line">S.top--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">GetTop</span><span class="params">(Stack S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> S.data[S.top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Stack S;</span><br><span class="line"><span class="built_in">InitStack</span>(S);</span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"><span class="comment">//flag标志状态 true为括号匹配，false为不匹配</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="comment">//元素若为&#123;，(，[则入栈</span></span><br><span class="line"><span class="keyword">if</span> ((str[i] == <span class="string">&#x27;&#123;&#x27;</span>) || (str[i] == <span class="string">&#x27;[&#x27;</span>) || (str[i] == <span class="string">&#x27;(&#x27;</span>)) &#123;</span><br><span class="line"><span class="built_in">Push</span>(S, str[i]);</span><br><span class="line">&#125;<span class="comment">//元素若为&#125;，)，]则出栈 赋值给right</span></span><br><span class="line"><span class="keyword">if</span> ((str[i] == <span class="string">&#x27;&#125;&#x27;</span>) || (str[i] == <span class="string">&#x27;]&#x27;</span>) || (str[i] == <span class="string">&#x27;)&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> ((str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; <span class="built_in">GetTop</span>(S) == <span class="string">&#x27;&#123;&#x27;</span>) </span><br><span class="line">|| (str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; <span class="built_in">GetTop</span>(S) == <span class="string">&#x27;[&#x27;</span>) </span><br><span class="line">|| (str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; <span class="built_in">GetTop</span>(S) == <span class="string">&#x27;(&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">char</span> top = <span class="built_in">Pop</span>(S, top);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">Push</span>(S, str[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (S.top != <span class="number">-1</span>) &#123;    <span class="comment">//当栈不为空时</span></span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;括号不匹配！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;括号匹配！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实验结果：</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210122155026920.png" alt="image-20210122155026920"></p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210122155116917.png" alt="image-20210122155116917"></p><h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p>&emsp;&emsp;要求一个表达式的结果，例如 9 +（3 - 1) * 3 + 1 ，我们可以直接算出来，但是计算机不会，计算机一般将这种表达式转换成后缀表达式，运算符在操作数后面，并且运算也是根据优先级排列好的，没有括号，利于计算机的计算，如上述表达式转换为后缀表示式为：</p><p>9  3  1  -  3  *  10 +  ，但是我们现在要实现的是中缀表达式的求值。</p><p>计算思路：</p><ul><li>使用两个栈，stack0用于存储操作数，stack1用于存储操作符</li><li>从左往右扫描，遇到操作数入栈stack0</li><li>遇到操作符时，如果优先级低于或等于栈顶操作符优先级，则从stack0弹出两个元素进行计算，并压入stack0，继续与栈顶操作符的比较优先级</li><li>如果遇到操作符高于栈顶操作符优先级，则直接入栈stack1</li><li>遇到左括号，直接入栈stack1，遇到右括号，则直接出栈并计算，直到遇到左括号</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算符优先法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">110</span>; </span><br><span class="line"><span class="keyword">char</span> priority[<span class="number">7</span>][<span class="number">7</span>]=&#123; </span><br><span class="line">    &#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,  </span><br><span class="line">    &#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,  </span><br><span class="line">    &#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,  </span><br><span class="line">    &#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,  </span><br><span class="line">    &#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;=&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,   <span class="comment">// 此行&quot;(&quot;=&quot;)&quot;表示左右括号相遇，括号内运算已完成 </span></span><br><span class="line">    &#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>&#125;,  </span><br><span class="line">    &#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;=&#x27;</span>&#125;    <span class="comment">// &quot;=&quot; 表示整个表达式求值完毕 </span></span><br><span class="line">&#125;;                               <span class="comment">//  &quot;0&quot;表示不可能出现这种情况 ( 语法错误 ) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Precede 用于判断运算符栈栈顶运算符 a1 与读入运算符 a2 之间的优先关系函数 </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Procede</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>&#123;   <span class="comment">// 建立 pre[][] 到 运算符间的映射关系 </span></span><br><span class="line">    <span class="keyword">int</span> i,j;  </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(a)&#123;  </span><br><span class="line">        case&#x27;+&#x27;:i=0;break;  </span><br><span class="line">        case&#x27;-&#x27;:i=1;break;  </span><br><span class="line">        case&#x27;*&#x27;:i=2;break;  </span><br><span class="line">        case&#x27;/&#x27;:i=3;break;  </span><br><span class="line">        case&#x27;(&#x27;:i=4;break;  </span><br><span class="line">        case&#x27;)&#x27;:i=5;break;  </span><br><span class="line">        case&#x27;#&#x27;:i=6;break;   // # 是表达式的结束符 </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(b)&#123;  </span><br><span class="line">        case&#x27;+&#x27;:j=0;break;  </span><br><span class="line">        case&#x27;-&#x27;:j=1;break;  </span><br><span class="line">        case&#x27;*&#x27;:j=2;break;  </span><br><span class="line">        case&#x27;/&#x27;:j=3;break;  </span><br><span class="line">        case&#x27;(&#x27;:j=4;break;  </span><br><span class="line">        case&#x27;)&#x27;:j=5;break;  </span><br><span class="line">        case&#x27;#&#x27;:j=6;break;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> priority[i][j];  </span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Operate</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">char</span> x)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(x==<span class="string">&#x27;+&#x27;</span>)  </span><br><span class="line">    <span class="keyword">return</span> m+n;  </span><br><span class="line">    <span class="keyword">if</span>(x==<span class="string">&#x27;-&#x27;</span>)  </span><br><span class="line">    <span class="keyword">return</span> n-m;  </span><br><span class="line">    <span class="keyword">if</span>(x==<span class="string">&#x27;*&#x27;</span>)  </span><br><span class="line">    <span class="keyword">return</span> m*n;  </span><br><span class="line">    <span class="keyword">if</span>(x==<span class="string">&#x27;/&#x27;</span>)  </span><br><span class="line">    <span class="keyword">return</span> n/m;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// EvaluuateExpression-reduced</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stack &lt;<span class="keyword">int</span>&gt; OPND;  <span class="comment">// Operand stack</span></span><br><span class="line">    stack &lt;<span class="keyword">char</span>&gt; OPTR;  <span class="comment">// Operator stack</span></span><br><span class="line">OPTR.<span class="built_in">push</span>(<span class="string">&#x27;#&#x27;</span>);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">char</span> ss[<span class="number">2</span>]=<span class="string">&quot;#&quot;</span>;<span class="comment">//尾部有\0 </span></span><br><span class="line">    <span class="keyword">char</span> s[maxn];</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="built_in">strcat</span>(s,ss);<span class="comment">// 运算式尾部加 &quot;#&quot;--结束运算符 </span></span><br><span class="line">    <span class="keyword">char</span> c=s[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c!=<span class="string">&#x27;#&#x27;</span>||OPTR.<span class="built_in">top</span>()!=<span class="string">&#x27;#&#x27;</span>)&#123;  <span class="comment">//表达式未读完或者运算未完 </span></span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;    </span><br><span class="line">            <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;  <span class="comment">// 读入连续的数字 </span></span><br><span class="line">                y=y*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);  </span><br><span class="line">                c=s[k++];  </span><br><span class="line">            &#125;  </span><br><span class="line">            OPND.<span class="built_in">push</span>(y);  <span class="comment">// 把读进的数字入数字栈 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(<span class="built_in">Procede</span>(OPTR.<span class="built_in">top</span>(),c))  </span><br><span class="line">            &#123;  </span><br><span class="line">                case&#x27;&lt;&#x27;:  //栈顶元素优先权低 </span><br><span class="line">                    OPTR.<span class="built_in">push</span>(c);  </span><br><span class="line">                    c=s[k++];  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                case&#x27;=&#x27;:  </span><br><span class="line">                    OPTR.<span class="built_in">pop</span>();  <span class="comment">// 脱括号 </span></span><br><span class="line">                    c=s[k++];  <span class="comment">// 读入下一个字符 </span></span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                case&#x27;&gt;&#x27;:  //退栈并将运算结果入栈 </span><br><span class="line">                    <span class="keyword">char</span> x=OPTR.<span class="built_in">top</span>();OPTR.<span class="built_in">pop</span>();  </span><br><span class="line">                    <span class="keyword">int</span> m=OPND.<span class="built_in">top</span>();OPND.<span class="built_in">pop</span>();  </span><br><span class="line">                    <span class="keyword">int</span> n=OPND.<span class="built_in">top</span>();OPND.<span class="built_in">pop</span>();  </span><br><span class="line">                    OPND.<span class="built_in">push</span>(<span class="built_in">Operate</span>(m,n,x));  </span><br><span class="line">                    <span class="keyword">break</span>;    </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;OPND.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实验结果：</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210122155312932.png" alt="image-20210122155312932"></p><h2 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h2><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>&emsp;&emsp;利用队列存储每一层的结点，再存储到数组中，很容易理解。下面是套路：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)   q.<span class="built_in">push</span>(root);</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            TreeNode* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            temp.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在计算机系统中的应用"><a href="#在计算机系统中的应用" class="headerlink" title="在计算机系统中的应用"></a>在计算机系统中的应用</h3><p>&emsp;&emsp;一、解决主机与外部设备之间速度不匹配的问题。</p><p>&emsp;&emsp;二、解决由多用户引起的资源竞争问题。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环链表</title>
      <link href="2021/04/22/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
      <url>2021/04/22/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><h2 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h2><p>&emsp;&emsp;循环单链表和单链表的区别在于：循环单链表的最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8.png"></p><p>&emsp;&emsp;在循环单链表中，表尾结点tail的next指针指向头结点，所以表中没有指针域为NULL的结点，因此，循环单链表的判空条件不是头结点的指针是否为空，而是判断头结点的指针是否等于头指针，就是说是否指向自身。</p><span id="more"></span><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitLinkList</span><span class="params">(LinkList&amp; L)</span></span>&#123;</span><br><span class="line">    LNode* L = (LNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>( L == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkList&amp; L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( L-&gt;next == L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断表尾结点"><a href="#判断表尾结点" class="headerlink" title="判断表尾结点"></a>判断表尾结点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsTail</span><span class="params">(LinkList&amp; L, LNode* p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( p-&gt;next == L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;有时对单链表常做的操作是在表头表尾操作的，此时对循环单链表不设头指针而仅设尾指针，从而使得操作效率更高。原因是若设头指针，对表尾进行操作的时间复杂度为O（n）,而设尾指针tail，tail-&gt;next即为头指针，对于表头表尾进行操作时都只需要O（1）。</p><h2 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h2><p>&emsp;&emsp;知道了循环单链表，那循环双链表理解起来就很简单了。循环双链表的表尾结点的next 指针指向头结点，同时头结点的prior指针指向表尾结点。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8.JPG"></p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList&amp; L)</span></span>&#123;</span><br><span class="line">    DNode* L = (DNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>( L == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;prior = L;</span><br><span class="line">    L-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判空-1"><a href="#判空-1" class="headerlink" title="判空"></a>判空</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(DLinkList&amp; L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( L-&gt;next == L &amp;&amp; L-&gt;prior = L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断表尾结点-1"><a href="#判断表尾结点-1" class="headerlink" title="判断表尾结点"></a>判断表尾结点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsTail</span><span class="params">(LinkList&amp; L, LNode* p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( p-&gt;next == L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><p>&emsp;&emsp;静态链表借助数组来描述线性表的链式存储结构，结点也有数据域data和指针域next，与链表中的指针不同，这里的指针是结点的相对地址（数组下标），又称游标。静态链表也要预先分配分配一块连续的内存空间。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8.png"></p><p>&emsp;&emsp;静态链表结构类型的描述如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;静态链表以next == - 1作为其结束的标志。静态链表的插入，删除操作与动态链表的相同，只需要修改指针，而不需要移动元素。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线索二叉树</title>
      <link href="2021/04/22/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2021/04/22/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>&emsp;&emsp;遍历二叉树以一定规则将二叉树中的结点排列成一个线性序列，得到二叉树结点的各种遍历序列，其实质是对一个非线性结构进行线性化操作，使这个访问序列中的每个结点（第一个和最后一个除外）都有一个直接前驱和直接后继。</p><p>&emsp;&emsp;引入线索二叉树是为了加快查找结点前驱和后继的速度。在有n的结点的二叉树中，有n+1个空指针。</p><p><strong>&emsp;&emsp;在二叉树线索化时，通常规定：若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向后继结点。还需要增加两个标志域表明当前指针域所指对象是指向左（右）子结点还是指向直接前驱（后继）。</strong></p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p><span id="more"></span><p>&emsp;&emsp;线索二叉树的存储结构描述如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以这种结点构成的二叉链表作为二叉树的存储结构，称为<strong>线索链表</strong>，其中指向结点前驱和后继的指针称为<strong>线索</strong>。加上线索的二叉树称为<strong>线索二叉树</strong>。对二叉树以某种次序遍历使其变为线索二叉树的过程称为<strong>线索化</strong>。</p><h2 id="线索二叉树的构造"><a href="#线索二叉树的构造" class="headerlink" title="线索二叉树的构造"></a>线索二叉树的构造</h2><p>&emsp;&emsp;对二叉树的线索化，实质上就是遍历一次二叉树，只是在遍历的过程中，检查当前节点的左右指针域是否为空，若为空，将它们改为指向前驱结点或指向后继结点的线索。</p><p><strong>&emsp;&emsp;线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继信息只有在遍历该二叉树时才能得到，所以，线索化的过程就是在遍历的过程中修改空指针的过程。</strong></p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/线索二叉树构造.jpg" style="zoom: 80%;" /><p>&emsp;&emsp;以中序遍历对二叉树线索化的递归算法为例：</p><p>&emsp;&emsp;前驱结点：</p><ol><li>若左指针为线索，则其指向结点为前驱结点</li><li>若左指针为左孩子，则其左子树的最右侧结点为前驱结点</li></ol><p>&emsp;&emsp;后继结点：</p><ol><li>若右指针为线索，则其指向结点为后继结点</li><li>若右指针为右孩子，则其右子树的最左侧结点为后继结点</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree&amp; p, ThreadTree&amp; pre)</span></span>&#123;<span class="comment">//线索二叉树的根结点，指向前驱结点的指针</span></span><br><span class="line">    <span class="keyword">if</span>( p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">InThread</span>(p-&gt;lchild,pre);<span class="comment">//递归，线索化左子树</span></span><br><span class="line">        <span class="keyword">if</span>( p-&gt;lchild == <span class="literal">NULL</span>)&#123;<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">            p-&gt;lchild == pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rchild = p;<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;<span class="comment">//标记当前结点成为刚刚访问过得结点</span></span><br><span class="line">        <span class="built_in">InThread</span>( p-&gt;rchild, pre);<span class="comment">//递归，线索化右子树</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;建立线索二叉树：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>( T != <span class="literal">NULL</span> )&#123;<span class="comment">//非空二叉树线索化</span></span><br><span class="line">        <span class="built_in">InThread</span>(T,pre);<span class="comment">//线索化二叉树</span></span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;有时为了方便，仿照线性表的存储结构，在二叉树的线索链表上也添加一个头结点，并令其lchild指针指向二叉树的二叉树的根结点，令 rchild 指针指向中序遍历时访问的最后一个结点；令中序遍历的第一个节点的lchild指针和最后一个结点的rchild指针均指向头结点。这就好比为二叉树建立了一个双向线索链表，既可以从第一个结点顺后继进行遍历，也可以从最后一个结点顺前驱进行遍历。</p><h2 id="线索二叉树的遍历"><a href="#线索二叉树的遍历" class="headerlink" title="线索二叉树的遍历"></a>线索二叉树的遍历</h2><p>&emsp;&emsp;不含头结点的线索化二叉树的遍历算法：</p><ol><li><p>求中序线索二叉树中中序序列的第一个结点：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">FirstNode</span><span class="params">(ThreadNode* p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( p-&gt;ltag == <span class="number">0</span>)&#123;</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>求中序线索二叉树中结点p在中序序列下的后继结点：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">NextNode</span><span class="params">(ThreadNode* p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( p-&gt;rtag == <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;rchild);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode* T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( ThreadNode* p = <span class="built_in">FirstNode</span>(T); p != <span class="literal">NULL</span>; p = <span class="built_in">NextNode</span>(p))&#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外添加的函数：</p></li><li><p>中序线索二叉树的最后一个结点</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">LastNode</span><span class="params">(ThreadNode* p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( p-&gt;rtag == <span class="number">0</span> )&#123;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>求中序线索二叉树中结点p在中序序列下的前驱结点：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">PreNode</span><span class="params">(ThreadNode* p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( p-&gt;ltag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;lchild);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程基础</title>
      <link href="2021/04/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>2021/04/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程基本原理"><a href="#网络编程基本原理" class="headerlink" title="网络编程基本原理"></a>网络编程基本原理</h1><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/socket%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><span id="more"></span><h1 id="Socket通信函数"><a href="#Socket通信函数" class="headerlink" title="Socket通信函数"></a>Socket通信函数</h1><h2 id="soket"><a href="#soket" class="headerlink" title="soket"></a>soket</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        _In_ <span class="keyword">int</span> af, <span class="comment">//AF_INET</span></span></span></span><br><span class="line"><span class="function"><span class="params">        _In_ <span class="keyword">int</span> type,<span class="comment">//socket类型，SOCK_STREAM(Tcp),SOCK_DGRAM(UDP)</span></span></span></span><br><span class="line"><span class="function"><span class="params">        _In_ <span class="keyword">int</span> protocol<span class="comment">//协议</span></span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br></pre></td></tr></table></figure><p>返回：非负描述字──成功， -1──出错</p><ul><li><p>参数family</p><p>这个参数指定一个协议簇，也往往被称为协议域。系统存在许多可以的协议簇，常见有AF_INET──指定为IPv4协议，AF_INET6──指定为IPv6，AF_LOCAL──指定为UNIX 协议域等等。它值都是系统预先定义的宏，系统支持哪些协议我们才可以使用，否则会调用失败。协议簇是网络层的协议。</p></li><li><p>参数type</p><p>这个参数指定一个套接口的类型，套接口可能的类型有：SOCK_STREAM、SOCK_DGRAM、SOCK_SEQPACKET、SOCK_RAW等等，它们分别表明字节流、数据报、有序分组、原始套接口。这实际上是指定内核为我们提供的服务抽象，比如我们要一个字节流。需要注意的，并不是每一种协议簇都支持这里的所有的类型，所以类型与协议簇要匹配。</p></li><li><p>参数protocol</p><p>指定相应的传输协议，也就是诸如TCP或UDP协议等等，系统针对每一个协议簇与类型提供了一个默认的协议，我们通过把protocol设置为0来使用这个默认的值。注意这里的协议与上面的协议簇是两个不同的概念，前者是指网络层的协议，由于它对于到传输层会出现许多协议，比如IPv4可以用来实现TCP或UDP等等传输层协议，所以称为协议簇。相应的传输层的协议就简单地称为协议。常见的协议有TCP、UDP、SCTP，要指定它们分别使用宏IPPROTO_TCP、IPPROTO_UPD、IPPROTO_SCTP来指定。</p></li><li><p>返回值</p><p>socket函数返回一个套接字，即套接口描述字。如果出现错误，它返回-1，并设置errno为相应的值，用户应该检测以判断出现什么错误。</p></li></ul><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        _In_ SOCKET s,</span></span></span><br><span class="line"><span class="function"><span class="params">        _In_reads_bytes_(namelen) <span class="keyword">const</span> struct sockaddr FAR * name,</span></span></span><br><span class="line"><span class="function"><span class="params">        _In_ <span class="keyword">int</span> namelen</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>返回0表示成功，-1表示失败。</p><p>&emsp;&emsp;绑定的时候要用到socket的各种数据，这些数据存储在名叫SOCK_ADDR的结构体中：<br>SOCK_ADDR</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (_WIN32_WINNT &lt; 0x0600)</span></span><br><span class="line">    u_short sa_family;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    ADDRESS_FAMILY sa_family;           <span class="comment">// Address family.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//(_WIN32_WINNT &lt; 0x0600)</span></span></span><br><span class="line"></span><br><span class="line">    CHAR sa_data[<span class="number">14</span>];                   <span class="comment">// Up to 14 bytes of direct address.</span></span><br><span class="line">&#125; SOCKADDR, *PSOCKADDR, FAR *LPSOCKADDR;</span><br></pre></td></tr></table></figure><p>sa_family是地址家族，一般都是“AF_xxx”的形式。好像通常大多用的是都是AF_INET。<br>sa_data是14字节协议地址。<br>此数据结构用做bind、connect、recvfrom、sendto等函数的参数，指明地址信息。</p><p>但一般编程中并不直接针对此数据结构操作，而是使用另一个与sockaddr等价的数据结构</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>(_WIN32_WINNT &lt; 0x0600)<span class="comment">//sin_family指代协议族，在socket编程中只能是AF_INET</span></span></span><br><span class="line">    <span class="keyword">short</span>   sin_family;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">//(_WIN32_WINNT &lt; 0x0600)</span></span></span><br><span class="line">    ADDRESS_FAMILY sin_family;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//(_WIN32_WINNT &lt; 0x0600)</span></span></span><br><span class="line"></span><br><span class="line">    USHORT sin_port;  <span class="comment">//存储端口号（使用网络字节顺序）</span></span><br><span class="line">    IN_ADDR sin_addr;<span class="comment">//Internet 地址，存储IP地址</span></span><br><span class="line">    CHAR sin_zero[<span class="number">8</span>];<span class="comment">//为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节</span></span><br><span class="line">&#125; SOCKADDR_IN, *PSOCKADDR_IN;</span><br></pre></td></tr></table></figure><h2 id="本机转换"><a href="#本机转换" class="headerlink" title="本机转换"></a>本机转换</h2><p>在实现过程中，我们需要将ip 本机字节序列转换为 网络字节序列，这里涉及到多个函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">htons()--&quot;Host to Network Short&quot;</span><br><span class="line"></span><br><span class="line">htonl()--&quot;Host to Network Long&quot;</span><br><span class="line"></span><br><span class="line">ntohs()--&quot;Network to Host Short&quot;</span><br><span class="line"></span><br><span class="line">ntohl()--&quot;Network to Host Long&quot;</span><br></pre></td></tr></table></figure><p>将数据放到网络上时，确保它是网络字节序列</p><p>为什么在数据结构 struct sockaddr_in 中， sin_addr 和 sin_port 需要转换为网络字节顺序，而sin_family 需不需要呢?</p><p> 答案是： sin_addr 和 sin_port 分别封装在包的 IP 和 UDP 层。因此，它们必须要 是网络字节顺序。但是 sin_family 域只是被内核 (kernel) 使用来决定在数 据结构中包含什么类型的地址，所以它必须是本机字节顺序。同时， sin_family 没有发送到网络上，它们可以是本机字节顺序。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inet_addr(&quot;192.168.175.1&quot;);&#x2F;&#x2F;将本机ip地址转换为网络字节序</span><br></pre></td></tr></table></figure><h2 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span><span class="title">listen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ SOCKET s,<span class="comment">//监听的socket</span></span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ <span class="keyword">int</span> backlog<span class="comment">//等待请求队列的最大长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数是服务端套接字，你要聆听，总得出来说个话啊，好，就指定你了；第二个参数是等待连接队列的最大长度，比方说，你将backlog定为10, 当有15个连接请求的时候，前面10个连接请求就被放置在请求队列中，后面5个请求被拒绝。****千千万万要注意：****这个10并不是表示客户端最大的连接数为10， 实际上可以有很多很多的客户端（实践证明也是如此）。</p><p>返回值：0——成功，1——失败</p><h2 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        _In_ SOCKET s,<span class="comment">//监听套接字</span></span></span></span><br><span class="line"><span class="function"><span class="params">        _Out_writes_bytes_opt_(*addrle) struct sockaddr FAR * addr,<span class="comment">//</span></span></span></span><br><span class="line"><span class="function"><span class="params">        _Inout_opt_ <span class="keyword">int</span> FAR * addrlen</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br></pre></td></tr></table></figure><p>返回：非负描述字——成功， -1——失败</p><p><strong>accept默认会阻塞进程，直到有一个客户连接建立后返回，它返回的是一个新可用的套接字，这个套接字是连接套接字。</strong></p><p>此时我们需要区分两种套接字，一种套接字正如accept的参数s，它是<strong>监听套接字</strong>，在调用listen函数之后，一个套接字会从主动连接的套接字变身为一个监听套接字；而<strong>accept返回是一个连接套接字</strong>，它代表着一个网络已经存在的点点连接。自然要问的是：为什么要有两种套接字？原因很简单，如果使用一个描述字的话，那么它的功能太多，使得使用很不直观，同时在内核确实产生了一个这样的新的描述字。</p><ul><li><p>参数s</p><p>参数s就是上面解释中的监听套接字，这个套接字用来监听一个端口，当有一个客户与服务器连接时，它使用这个一个端口号，而此时这个端口号正与这个套接字关联。当然客户不知道套接字这些细节，它只知道一个地址和一个端口号。</p></li><li><p>参数addr </p><p>这是一个结果参数，它用来接受一个返回值，<strong>这返回值指定客户端的地址</strong>，当然这个地址是通过某个地址结构来描述的，用户应该知道这一个什么样的地址结构。如果对客户的地址不感兴趣，那么可以把这个值设置为NULL。</p></li><li><p>参数addrlen</p><p>如同大家所认为的，它也是结果的参数，用来接受上述addr的结构的大小的，它指明addr结构所占有的字节个数。同样的，它也可以被设置为NULL。</p></li></ul><p>如果accept成功返回，则服务器与客户已经正确建立连接了，此时服务器通过accept返回的套接字来完成与客户的通信。</p><h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">WSAAPI</span><br><span class="line"><span class="built_in">connect</span>(</span><br><span class="line">    _In_ SOCKET s,</span><br><span class="line">    _In_reads_bytes_(namelen) <span class="keyword">const</span> struct sockaddr FAR * name,</span><br><span class="line">    _In_ <span class="keyword">int</span> namelen</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h6 id="参数1"><a href="#参数1" class="headerlink" title="参数1"></a>参数1</h6><p>服务器的socket</p><h6 id="参数2"><a href="#参数2" class="headerlink" title="参数2"></a>参数2</h6><p>服务器ip地址、端口号结构体<br>注意参数2的调用需要先定义一个结构体，放入需要请求连接的服务器的ip地址、端口号，这个结构体为struct类型， SOCKADDR* ，可以使用 SOCKADDR_IN 类型转换过来</p><h6 id="参数3"><a href="#参数3" class="headerlink" title="参数3"></a>参数3</h6><p>参数2的结构体大小</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul><li>成功的话返回0</li><li>执行失败返回SOCKET_ERROR，用函数WSAGetLastError()得到错误码，根据得到的错误码作相应处理</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="built_in">connect</span>(sky_Server, &amp;serverMsg, <span class="built_in"><span class="keyword">sizeof</span></span>(serverMsg));</span><br><span class="line"><span class="keyword">if</span> (a == SOCKET_ERROR) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connect错误，错误码：%d\n&quot;</span>, <span class="built_in">WSAGetLastError</span>()); <span class="comment">//检验错误原因</span></span><br><span class="line"><span class="built_in">closesocket</span>(sky_Server);</span><br><span class="line"><span class="built_in">WSACleanup</span>();<span class="comment">//不成功需要关闭网络库</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="send"><a href="#send" class="headerlink" title="send"></a>send</h2><p>向目标发送数据，本质上就是将数据复制粘贴进系统的协议发送缓冲区，计算机伺机发送出去</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">WSAAPI</span><br><span class="line"><span class="built_in">send</span>(</span><br><span class="line">    _In_ SOCKET s,<span class="comment">//标识已连接套接字的描述符。</span></span><br><span class="line">    _In_reads_bytes_(len) <span class="keyword">const</span> <span class="keyword">char</span> FAR * buf, <span class="comment">//指向包含要传输的数据的缓冲区的指针。</span></span><br><span class="line">    _In_ <span class="keyword">int</span> len,<span class="comment">//buf参数指向的缓冲区中数据的长度（以字节为单位）。</span></span><br><span class="line">    _In_ <span class="keyword">int</span> flags<span class="comment">//一组标志，指定进行呼叫的方式。通过将按位或运算符与以下任何值一起使用来构造此参数。</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h6 id="参数1-1"><a href="#参数1-1" class="headerlink" title="参数1"></a>参数1</h6><p>目标的socket，每个客户端对应唯一的socket</p><h6 id="参数2-1"><a href="#参数2-1" class="headerlink" title="参数2"></a>参数2</h6><p>给对方发送的字节串<br>这个一般不超过1500个字节，也是网络传输的最大单元，也就是客户端发过来的数据，是协议规定的，这个数据也是根据很多情况总结出来的最优值<br>1500的相关知识文末进一步说明</p><h6 id="参数3-1"><a href="#参数3-1" class="headerlink" title="参数3"></a>参数3</h6><p>要发送的字节个数，决定发送的个数，如果比参数2中的要发送的字节数短，则只发送参数3决定的个数，后面的就不管了，大了就发送过多的字节，内存可能泄漏<br>一般与参数2一样大小</p><h6 id="参数4"><a href="#参数4" class="headerlink" title="参数4"></a>参数4</h6><p>一般直接写0就行</p><h2 id="recv"><a href="#recv" class="headerlink" title="recv"></a><strong>recv</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">WSAAPI</span><br><span class="line"><span class="built_in">recv</span>(</span><br><span class="line">    _In_ SOCKET s,</span><br><span class="line">    _Out_writes_bytes_to_(len, <span class="keyword">return</span>) __out_data_source(NETWORK) <span class="keyword">char</span> FAR * buf,</span><br><span class="line">    _In_ <span class="keyword">int</span> len,</span><br><span class="line">    _In_ <span class="keyword">int</span> flags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h6 id="参数1-2"><a href="#参数1-2" class="headerlink" title="参数1"></a>参数1</h6><p>目标的socket，每个客户端对应唯一的socket</p><h6 id="参数2-2"><a href="#参数2-2" class="headerlink" title="参数2"></a>参数2</h6><p>接收缓存区</p><h6 id="参数3-2"><a href="#参数3-2" class="headerlink" title="参数3"></a>参数3</h6><p>接收缓存区长度</p><h6 id="参数4-1"><a href="#参数4-1" class="headerlink" title="参数4"></a>参数4</h6><p>一般直接写0就行</p><p><strong>recv函数返回其实际copy的字节数</strong>。如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。</p><h2 id="WSAAsyncSelect-将网络中的某事件关联到窗口的某个消息中"><a href="#WSAAsyncSelect-将网络中的某事件关联到窗口的某个消息中" class="headerlink" title="WSAAsyncSelect   将网络中的某事件关联到窗口的某个消息中"></a>WSAAsyncSelect   将网络中的某<code>事件关联</code>到窗口的某个消息中</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">WSAAPI</span><br><span class="line"><span class="built_in">WSAAsyncSelect</span>(</span><br><span class="line">  _In_  SOCKET s,<span class="comment">//我们感兴趣的套接字</span></span><br><span class="line">  _In_  HWND hWnd,<span class="comment">//窗口的句柄，对于网络事件繁盛后，想要接收到的通知的那个窗口</span></span><br><span class="line">  _In_  <span class="keyword">unsigned</span> <span class="keyword">int</span> wMsg,<span class="comment">//指定在发生网络事件时，打算接收的消息。</span></span><br><span class="line">  _In_  <span class="keyword">long</span> lEvent<span class="comment">//指定一个位掩码，对应于一系列网络事件的组合。</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="closesocket"><a href="#closesocket" class="headerlink" title="closesocket"></a>closesocket</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> PASCAL FAR <span class="title">closesocket</span> <span class="params">( IN SOCKET s)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="WSACleanup-清理协议版本信息"><a href="#WSACleanup-清理协议版本信息" class="headerlink" title="WSACleanup  清理协议版本信息"></a>WSACleanup  清理协议版本信息</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">WSAAPI</span><br><span class="line"><span class="built_in">WSACleanup</span>(</span><br><span class="line">    <span class="keyword">void</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h2 id="ioctlsocket-设置套接字的I-O模式"><a href="#ioctlsocket-设置套接字的I-O模式" class="headerlink" title="ioctlsocket 设置套接字的I/O模式"></a>ioctlsocket 设置套接字的I/O模式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">WSAAPI</span><br><span class="line"><span class="built_in">ioctlsocket</span>(</span><br><span class="line">    _In_ SOCKET s,</span><br><span class="line">    _In_ <span class="keyword">long</span> cmd,</span><br><span class="line">    _When_(cmd != FIONREAD, _Inout_)</span><br><span class="line">    _When_(cmd == FIONREAD, _Out_)</span><br><span class="line">    u_long FAR * argp</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>s为I/O操作的套接字。<br>cmd为对套接字的操作命令。<br>argp为命令所带参数的指针。</p><p>常见的命令：</p><p>//确定套接字自动读入的数据量<br>#define FIONREAD _IOR(‘’’’f’’’’, 127, u_long) /* get # bytes to read <em>/<br>//允许或禁止套接字的非阻塞模式，允许为非0，禁止为0<br>#define FIONBIO _IOW(‘’’’f’’’’, 126, u_long) /</em> set/clear non-blocking i/o <em>/<br>//确定是否所有带外数据都已被读入<br>#define SIOCATMARK _IOR(‘’’’s’’’’, 7, u_long) /</em> at oob mark? */<br>本函数可用于任一状态的任一套接口。它用于获取与套接口相关的操作参数，<br>而与具体协议或通讯子系统无关。支持下列命令：</p><p> <strong>FIONBIO</strong>：允许或禁止套接口s的非阻塞模式。argp指向一个无符号长整型。如<br>允许非阻塞模式则非零，如禁止非阻塞模式则为零。当创建一个套接口时，它就<br>处于阻塞模式（也就是说非阻塞模式被禁止）。这与BSD套接口是一致的。WSAAs<br>ynSelect()函数将套接口自动设置为非阻塞模式。如果已对一个套接口进行了WS<br>AAsynSelect() 操作，则任何用ioctlsocket()来把套接口重新设置成阻塞模式的<br>试图将以WSAEINVAL失败。为了把套接口重新设置成阻塞模式，应用程序必须首先<br>用WSAAsynSelect()调用（IEvent参数置为0）来禁至WSAAsynSelect()。</p><p> <strong>FIONREAD：</strong>确定套接口s自动读入的数据量。argp指向一个无符号长整型，其中<br>存有ioctlsocket()的返回值。如果s是SOCKET_STREAM类型，则FIONREAD返回在一<br>次recv()中所接收的所有数据量。这通常与套接口中排队的数据总量相同。如果<br>S是SOCK_DGRAM 型，则FIONREAD返回套接口上排队的第一个数据报大小。</p><p> <strong>SIOCATMARK</strong>：确实是否所有的带外数据都已被读入。这个命令仅适用于SOCK_S<br>TREAM类型的套接口，且该套接口已被设置为可以在线接收带外数据（SO_OOBINL<br>INE）。如无带外数据等待读入，则该操作返回TRUE真。否则的话返回FALSE假，<br>下一个recv()或recvfrom()操作将检索“标记”前一些或所有数据。应用程序可<br>用SIOCATMARK操作来确定是否有数据剩下。如果在“紧急”（带外）数据前有常<br>规数据，则按序接收这些数据（请注意，recv()和recvfrom()操作不会在一次调<br>用中混淆常规数据与带外数据）。argp指向一个BOOL型数，ioctlsocket()在其中<br>存入返回值。</p><h1 id="IP处理函数"><a href="#IP处理函数" class="headerlink" title="IP处理函数"></a>IP处理函数</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特殊矩阵的压缩存储</title>
      <link href="2021/04/22/%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/"/>
      <url>2021/04/22/%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1>特殊矩阵的压缩存储</h1><h2 id="数组的存储结构">数组的存储结构</h2><p>  一个数组中的所有元素在内存中占用一段连续的存储空间。</p><p>  对于多维数组，有两种映射方法：按行优先，按列优先。以二维数组为例：按行优先存储的基本思想是：先行后列，先存储行号较小的元素，行号相等先存储列号较小的元素。</p><h2 id="矩阵的压缩存储">矩阵的压缩存储</h2><p>  压缩存储：指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。目的是为了节省存储空间。</p><p>  特殊矩阵：指具有许多相同矩阵的元素或零元素，并且这些相同矩阵沿元素或零元素的分布有一定规律性的矩阵。常见的特殊矩阵有 对称矩阵，上（下）三角矩阵，对角矩阵。</p><span id="more"></span><h3 id="对称矩阵">对称矩阵</h3><p>  <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8.png" alt=""></p><p>  上三角区的所有元素和下三角区的对应元素相同，若仍采用二维数组存储，则会浪费几乎一半的存储空间，所以我们存放在一个一维数组B[n(n+1)/2]中，即元素a(i,j) 存放在b(k)中。</p><p>  元素a(i,j)在数组b中的下标k = 1 + 2 + … + (i - 1) + ( j - 1) = i (i-1) / 2 + j - 1 (数组下标从0 开始)。</p><p>  因此，元素下标之间的对应关系为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.2500em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mo>&gt;</mo><mo>=</mo><mi>j</mi><mo stretchy="false">(</mo><mtext>下三角区和主对角线元素</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>j</mi><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mi>i</mi><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo stretchy="false">(</mo><mtext>上三角区元素</mtext><mi>a</mi><mtext> </mtext><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mtext> </mtext><mo>=</mo><mi>a</mi><mtext> </mtext><mi>j</mi><mo separator="true">,</mo><mi>i</mi><mtext> </mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">k=\left\{\begin{aligned}i(i-1)/2 + j - 1 &amp;&amp; i &gt;= j(下三角区和主对角线元素)\\j(j-1)/2 + i - 1 &amp;&amp; i &lt; j (上三角区元素a~i,j~ = a~j,i~)\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.00003em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord cjk_fallback">下三角区和主对角线元素</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord cjk_fallback">上三角区元素</span><span class="mord mathnormal">a</span><span class="mspace nobreak"> </span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">a</span><span class="mspace nobreak"> </span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace nobreak"> </span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="三角矩阵">三角矩阵</h3><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E4%B8%8A%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5.jpg" alt=""></p><p>  上三角矩阵中，下三角区的所有元素均为同一常量，一般为0。只需存储主对角线、上三角区上的元素和下三角区的常量一次，可将其压缩存储B[n(n+1)/2 + 1]中。</p><p>  因此，元素下标之间的对应关系为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.2500em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mo>&lt;</mo><mo>=</mo><mi>j</mi><mo stretchy="false">(</mo><mtext>上三角区和主对角线元素</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo stretchy="false">(</mo><mtext>下三角区元素</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">k=\left\{\begin{aligned}(i-1)(2n-i+2)/2 + j - 1 &amp;&amp; i &lt;= j(上三角区和主对角线元素)\\n(n+1)/2 &amp;&amp; i &lt; j (下三角区元素)\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.00003em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">/2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord cjk_fallback">上三角区和主对角线元素</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord cjk_fallback">下三角区元素</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E4%B8%8A%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8.jpg" alt=""></p><p>  下三角矩阵：</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E4%B8%8B%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5.jpg" alt=""></p><p>  下三角矩阵的存储思想与对称矩阵类似，不同之处在于存储完下三角区和主对角线上元素之后，紧接着存储对角线上方的常量一次。</p><p>  因此，元素下标之间的对应关系为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.2500em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mo>&gt;</mo><mo>=</mo><mi>j</mi><mo stretchy="false">(</mo><mtext>下三角区和主对角线元素</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo stretchy="false">(</mo><mtext>上三角元素</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">k=\left\{\begin{aligned}i(i-1)/2 + j - 1 &amp;&amp; i &gt;= j(下三角区和主对角线元素)\\n(n+1)/2 &amp;&amp; i &lt; j (上三角元素)\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.00003em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord cjk_fallback">下三角区和主对角线元素</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord cjk_fallback">上三角元素</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="三对角矩阵">三对角矩阵</h3><p>  对角矩阵也称带状矩阵。对于n阶方阵A中的任意元素aij，当|i-j| &gt; 1 时，有aij = 0，则称为三对角矩阵。</p><p>    <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5.jpg" alt=""></p><p>  采用压缩存储，将3条对角线上的元素按行优先存放在一维数组B中，且将a0,0 存放在B[0]中，这样就可以计算出三角线上元素 aij（ 0&lt;= i, j &lt;= n, | i - j| &lt;= 1 ) 在一维数组B中存放的下标为 k = 2i + j - 3。</p><h2 id="稀疏矩阵">稀疏矩阵</h2><p>  如果矩阵中的非零元素的个数相对整个矩阵的元素个数来说非常少，则将这样的矩阵称为稀疏矩阵。</p><p>  存储稀疏矩阵，我们一般构造三元组存储矩阵非零元素。系数矩阵压缩存储后便失去了随机存取的特性。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表</title>
      <link href="2021/04/22/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
      <url>2021/04/22/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><p>&emsp;&emsp;线性表的顺序存储又称顺序表。表中元素的逻辑顺序与其物理顺序相同。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="静态定义："><a href="#静态定义：" class="headerlink" title="静态定义："></a>静态定义：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 50;<span class="comment">//定义线性表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MAXSIZE];<span class="comment">//顺序表的元素</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;Sqlist;<span class="comment">//顺序表的类型定义</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;静态分配时，数据量小的话，会造成数组空间的浪费；而如果是数据量大的话，就会造成溢出，进而导致程序崩溃。所以我们采用下面更灵活的方式来</p><span id="more"></span><h3 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 100<span class="comment">//定义线性表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType* data;<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> MAXSIZE,length;<span class="comment">//数组的最大容量和当前个数</span></span><br><span class="line">&#125;Sqlist;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;C的初始化分配语句为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">L.data = (ElemType*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ElemType)*InitSize);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这句话的意思是malloc向系统申请分配 （ sizeof(ElemType)*InitSize ）的内存空间，ElemType类型的指针指向这块内存的首地址。</p><p>&emsp;&emsp;C++的初始化分配语句为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">L.data = <span class="keyword">new</span> ElemType[InitSize];</span><br></pre></td></tr></table></figure><h2 id="顺序表上的基本操作："><a href="#顺序表上的基本操作：" class="headerlink" title="顺序表上的基本操作："></a>顺序表上的基本操作：</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化顺序表(静态分配)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitSqList</span><span class="params">(Sqlist&amp; L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE; i++) &#123;</span><br><span class="line">L.data[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!L.data)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(Sqlist L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(Sqlist L,ElemType e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>( e == L[i])&#123;</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最好情况：查找的元素就在表头，时间复杂度为O(1)</p><p>&emsp;&emsp;最坏情况：查找的元素在表尾，时间复杂度为O(n)</p><p>&emsp;&emsp;平均情况：比较的平均次数为 (n+1) / 2</p><p>&emsp;&emsp;因此，线性表的按值查找操作算法时间复杂度为O(n)。</p><h3 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(Sqlist L,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> L[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(Sqlist&amp; L,<span class="keyword">int</span> i,ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)&#123;<span class="comment">//判断输入的i是否符合范围</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( L.length &gt; MAXSIZE)&#123;<span class="comment">//如果存储空间已满，则插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = L.length; i &gt;= i; i--)&#123;<span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">        L.data[i] = L.data[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i] = e;</span><br><span class="line">    L.length ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最好情况：在表尾插入，时间复杂度为O(1)</p><p>&emsp;&emsp;最坏情况：在表头插入，时间复杂度为O(n)</p><p>&emsp;&emsp;平均情况：所需移动结点的平均次数为 n/2</p><p>&emsp;&emsp;因此，线性表的插入操作算法时间复杂度为O(n)。</p><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(Sqlist&amp; L,<span class="keyword">int</span> i,ElemTyep &amp;e)</span> </span>&#123; <span class="comment">//删除第i位上的数，并通过e返回其值</span></span><br><span class="line">    <span class="keyword">if</span>( i &lt; <span class="number">1</span> || i &gt; L.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = L.data[i];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = i; i &lt; L.length; i++)&#123;</span><br><span class="line">        L.data[i<span class="number">-1</span>] = L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length --;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最好情况：在表尾删除，时间复杂度为O(1)</p><p>&emsp;&emsp;最坏情况：在表头删除，时间复杂度为O(n)</p><p>&emsp;&emsp;平均情况：所需移动结点的平均次数为 (n-1) / 2</p><p>&emsp;&emsp;因此，线性表的删除操作算法时间复杂度为O(n)。</p><h2 id="动态分配的那点事"><a href="#动态分配的那点事" class="headerlink" title="动态分配的那点事"></a>动态分配的那点事</h2><h3 id="初始化顺序表"><a href="#初始化顺序表" class="headerlink" title="初始化顺序表"></a>初始化顺序表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSeqList</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">L.data = (ElemType*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ElemType) * InitSize);</span><br><span class="line"><span class="comment">//L.data = new ElemType[InitSize];   //C++动态分配</span></span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加动态数组的长度"><a href="#增加动态数组的长度" class="headerlink" title="增加动态数组的长度"></a>增加动态数组的长度</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncreaseSize</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">ElemType* p = L.data;  <span class="comment">//新建指针p指向数组首部,也就是p指针和data指针同时指向数组首位元素</span></span><br><span class="line">L.data = (ElemType*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ElemType) * (L.MAXSIZE + len));  <span class="comment">//在别处开辟(MAXSIZE+len)*sizeof(ElemType)连续的空间，  并将data指针指向这片空间的首地址</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">L.data[i] = p[i];<span class="comment">//将数据复制到区域</span></span><br><span class="line">&#125;</span><br><span class="line">L.MAXSIZE += len;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双链表</title>
      <link href="2021/04/22/%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
      <url>2021/04/22/%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><p>&emsp;&emsp;单链表结点中只有一个只指向后继的指针，使得单链表只能从头结点开始一次顺序的先后遍历。要访问某个结点的前驱结点（插入删除操作时），只能从头开始遍历，访问后继节点的时间复杂度为O（1），访问前驱结点的时间复杂度为O（n）。</p><p>&emsp;&emsp;为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针prior 和 next，分别指向其前驱结点和后继结点。</p><span id="more"></span><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;双链表中结点类型描述：</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%8F%8C%E9%93%BE%E8%A1%A8.jpg"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DLinkList;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在双链表中，按位查找和按值查找的操作和单链表中的相同。但在插入和删除上有着较大的不同。因为双链表有prior指针，可以很方便地找到其前驱结点，因此插入，删除结点的时间复杂度为O（1）。</p><h2 id="前插操作"><a href="#前插操作" class="headerlink" title="前插操作"></a>前插操作</h2><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5.jpg"></p><p>&emsp;&emsp;将结点s 插入到指针p所指结点b之前：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DLinkList_Insert</span><span class="params">(DLinkList&amp; L,ElemTyep c)</span></span>&#123;</span><br><span class="line">    DNode* p;</span><br><span class="line">    <span class="comment">/* 先检查位置是否合法...  */</span></span><br><span class="line">    DNode* s = (DNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(DNode));</span><br><span class="line">    s-&gt;data = c;</span><br><span class="line">    <span class="comment">//第一步：结点s的prior指针指向左边的结点</span></span><br><span class="line">    s-&gt;prior = p-&gt;prior;</span><br><span class="line">    <span class="comment">//第二步：结点b的前驱结点（也就是左边的结点）的next指针指向结点s</span></span><br><span class="line">    p-&gt;prior-&gt;next = s;</span><br><span class="line">    <span class="comment">//第三步：结点s的next指针指向结点b</span></span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">    <span class="comment">//第四步：结点b的prior指针指向结点s</span></span><br><span class="line">    p-&gt;prior = s;        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&emsp;&emsp;注意：第一，二步必须在第四步之前，否则*p的前驱结点的指针就会丢失，导致插入失败。</strong></p><h2 id="后插操作"><a href="#后插操作" class="headerlink" title="后插操作"></a>后插操作</h2><p>&emsp;&emsp;将结点s 插入到指针p所指的节点b 之后（如上图，假设后面的结点是d）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DLinkList_Insert</span><span class="params">(DLinkList&amp; L,ElemType c)</span></span>&#123;</span><br><span class="line">    DNode* p;</span><br><span class="line">    DNode* s = (DNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(DNode));</span><br><span class="line">    s-&gt;data = c;</span><br><span class="line">    <span class="comment">//第一步：将结点s 的next指针指向后继结点</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="comment">//第二步；将后继结点的prior指针指向结点s</span></span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    <span class="comment">//第三步：将结点s的prior指针指向结点b</span></span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    <span class="comment">//第四步：将结点b的next指针指向结点s</span></span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同样的，前插操作和后插其实没区别，注意第四步即可，大家不清楚可以在草稿纸上面画出来，画出来了就一目了然了。</p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4.JPG"></p><p>&emsp;&emsp;删除指针p指向的结点b：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DLinkList_Delete</span><span class="params">(DLinkList&amp; L)</span></span>&#123;</span><br><span class="line">    DNode* p;</span><br><span class="line">    <span class="comment">//第一步：将结点b的前驱结点的next指针指向结点c</span></span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="comment">//第二步：将结点c的prior指针指向结点b的前驱结点</span></span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">    <span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&emsp;&emsp;如果是删除指针p指向的结点的后继结点，指针q指向后继结点，也就是后删：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DLinkList_Delete</span><span class="params">(DLinkList&amp; L)</span></span>&#123;</span><br><span class="line">    DNode *p,*q;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树、森林</title>
      <link href="2021/04/22/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97/"/>
      <url>2021/04/22/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97/</url>
      
        <content type="html"><![CDATA[<h1 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h1><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><p>&emsp;&emsp;树的存储方式有很多种，既可采用顺序结构，又可采用链式存储结构，但无论采用何种存储方式，都要求能唯一的反映树中各结点之间的逻辑关系。下面是常见的存储结构：</p><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>&emsp;&emsp;这种存储方式采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E6%A0%91%E7%9A%84%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png"></p><span id="more"></span><p>&emsp;&emsp;双亲表示法的存储结构描述:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100<span class="comment">//树中最多结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//树中的结点定义</span></span><br><span class="line">    ElemType data;<span class="comment">//数据元素</span></span><br><span class="line">    <span class="keyword">int</span> parent;<span class="comment">//双亲位置</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//结点数</span></span><br><span class="line">&#125;PTTree;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该存储结构利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快得到每个结点的双亲结点，但求结点的孩子时需要遍历整个结构。</p><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>&emsp;&emsp;孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表（叶子结点的孩子链表尾空表）。</p><p>&emsp;&emsp;这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历n个结点中孩子链表指针域所指向的n个孩子链表。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg"></p><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>&emsp;&emsp;孩子兄弟表示法又称二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容：结点值，指向结点第一个孩子结点的指针，指向结点下一个兄弟结点的指针（沿此可以找到结点的所有兄弟结点）。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg"></p><p>&emsp;&emsp;孩子兄弟表示法的存储结构：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span><span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种存储表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但是缺点是从当前结点查找双亲结点比较麻烦。若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便。</p><h2 id="树，森林与二叉树的转换"><a href="#树，森林与二叉树的转换" class="headerlink" title="树，森林与二叉树的转换"></a>树，森林与二叉树的转换</h2><p>&emsp;&emsp;<strong>树转化为二叉树的规则</strong>：每个结点左指针指向它的第一个孩子结点，右指针指向它在树中的相邻兄弟结点，可即为“左孩子右兄弟”。由于根结点没有兄弟，所以由树转换而得的二叉树没有右子树。</p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/树转化为二叉树.jpg" style="zoom: 50%;" /><p>&emsp;&emsp;<strong>森林转化为二叉树的规则</strong>：先将每一棵树转换为二叉树，再将第一棵树的根作为转换后的二叉树的根，将第一棵树的左子树作为转换后的左子树，将第二棵树作为转换后的右子树，将第三棵树作为转换后的二叉树的右子树的右子树，以此类推。</p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/森林转化为二叉树.jpg" style="zoom: 80%;" /><p>&emsp;&emsp;<strong>二叉树转换为森林的规则</strong>：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，二叉树的根的右子树可视为一个由除第一棵树外的森林转化后的二叉树，用同样的方法，知道最后产生一棵没有右子树的二叉树为止。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A3%AE%E6%9E%97.jpg"></p><p>&emsp;&emsp;总结起来，个人愚见：将原先的左子树孩子节点转换为左子树孩子结点不变，原先的兄弟结点转换为左孩子结点的右子树。</p><h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>&emsp;&emsp;1）<strong>先根遍历</strong>：若树非空，先访问根结点，再按从左到右的顺序遍历根结点的每棵子树。和相对应的二叉树的先序遍历顺序相同</p><p>&emsp;&emsp;2）<strong>后根遍历</strong>：若树非空，先按从左到右的顺序遍历根结点的每棵子树，之后在访问根结点。和相对应的二叉树的中序遍历顺序相同</p><p>&emsp;&emsp;3）<strong>层次遍历</strong>：与二叉树的层次遍历思想基本相同</p><h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><p>&emsp;&emsp;1）<strong>先序遍历森林</strong>：若森林非空，访问森林中第一棵树的根结点；先序遍历第一课树中根结点的子树森林；先序遍历除去第一棵树之后剩余的树构成的森林。</p><p>&emsp;&emsp;2）<strong>中序遍历森林</strong>：若森林非空，中序遍历第一课树中根结点的子树森林；访问森林中第一棵树的根结点；中序遍历除去第一棵树之后剩余的树构成的森林。</p><p>&emsp;&emsp;树和森林的遍历与二叉树遍历的对应关系：</p><table><thead><tr><th align="center">树</th><th align="center">森林</th><th align="center">二叉树</th></tr></thead><tbody><tr><td align="center">先根遍历</td><td align="center">先序遍历</td><td align="center">先序遍历</td></tr><tr><td align="center">后根遍历</td><td align="center">中序遍历</td><td align="center">中序遍历</td></tr></tbody></table><h2 id="树的应用–并查集"><a href="#树的应用–并查集" class="headerlink" title="树的应用–并查集"></a>树的应用–并查集</h2><p>&emsp;&emsp;并查集是一种简单的集合表示，支持以下三种操作：</p><p>&emsp;&emsp;1）Union（S，Root1，Root2）：把集合S中的子集合Root2并入子集合Root1。要求Root1和Root2 互不相交，否则不执行合并。</p><p>&emsp;&emsp;2）Find（S，x）：查找集合S中单元素x所在的子集合，并返回该子集合的名字。</p><p>&emsp;&emsp;3）Initial（S）：将集合S中的每个元素都初始化为只有一个单元素的子集合。</p><p>&emsp;&emsp;通常用树（森林）的双亲表示作为并查集的存储结构，每个子集合以一棵树表示。所有表示子集合的树，构成表示全集合的森林，存放在双亲表示数组内，可以把它叫做 parent数组。通常用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲结点为负数（-1）。</p><p>&emsp;&emsp;这里先简单将一下，后续会详细讲解。并查集可以用来检测图中是否含有闭合回路，当然还有其他用途。</p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/并查集.png" style="zoom:80%;" /><p>&emsp;&emsp;并查集的结构定义：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="keyword">int</span> UFSets[SIZE];<span class="comment">//集合元素数组</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;并查集的初始化操作：将parent数组中的元素值设为-1，代表元素无根结点，自己就是独立的元素</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">(<span class="keyword">int</span> parent[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(parent)/<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        parent[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Find操作：找出元素的根结点</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> parent[],<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(parent[x] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/并查集路径压缩.jpg" style="zoom:150%;" /><p>&emsp;&emsp;Union操作：求两个不相交集合的并集</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> Root1, <span class="keyword">int</span> Root2)</span></span>&#123;</span><br><span class="line">    parent[Root2] = Root1; <span class="comment">//将集合root2合并到集合Root1中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表和链表的区别</title>
      <link href="2021/04/22/%E5%8C%BA%E5%88%AB/"/>
      <url>2021/04/22/%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><table><thead><tr><th align="center"></th><th align="center">顺序表</th><th align="center">单链表</th></tr></thead><tbody><tr><td align="center"><strong>存取方式</strong></td><td align="center">可顺序存取，可随机存取</td><td align="center">只能从表头顺序存取</td></tr><tr><td align="center"><strong>逻辑结构和物理结构</strong></td><td align="center">顺序存储，逻辑上相邻物理上也相邻</td><td align="center">链式存储，逻辑上相邻物理上不一定相邻，通过指针链接</td></tr><tr><td align="center"><strong>按值查找</strong></td><td align="center">按值查找：O（n）(无序)<br />折半查找 O(log2n)(有序)</td><td align="center">O（n）</td></tr><tr><td align="center"><strong>按序号查找</strong></td><td align="center">O（1）</td><td align="center">O（n）</td></tr><tr><td align="center"><strong>插入</strong></td><td align="center">O（n），平均需要移动n/2个元素</td><td align="center">只需修改相关结点</td></tr><tr><td align="center"><strong>删除</strong></td><td align="center">O（n），平均需要移动n/2个元素</td><td align="center">只需修改相关结点</td></tr><tr><td align="center"><strong>空间分配</strong></td><td align="center">可能会出现存储空间大量闲置或空间不足溢出</td><td align="center">动态申请空间，操作灵活、高效</td></tr></tbody></table><span id="more"></span><h2 id="怎样选取存储结构"><a href="#怎样选取存储结构" class="headerlink" title="怎样选取存储结构"></a>怎样选取存储结构</h2><p><strong>&emsp;&emsp;1、基于存储的考虑</strong></p><p>&emsp;&emsp;&emsp;&emsp;难以估计线性表的长度或存储规模时，不易采用顺序表；但链表的存储密度较低，链式存储结构的存储密度是小于1的。</p><p><strong>&emsp;&emsp;2、基于运算的考虑</strong></p><p>&emsp;&emsp;&emsp;&emsp;若经常做的运算是按序访问数据元素，则显然顺序表更优。</p><p>&emsp;&emsp;&emsp;&emsp;若经常做插入删除操作，则链式存储结构则更优。</p><p><strong>&emsp;&emsp;3、基于环境的考虑</strong></p><p>&emsp;&emsp;&emsp;&emsp;顺序表容易实现，链表是基于指针的，相对来讲，前者实现更加简单，实现难易度也是需要考虑的一点。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡二叉树</title>
      <link href="2021/04/22/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2021/04/22/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树(AVL)"></a>平衡二叉树(AVL)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;为避免树的高度增长过快，降低二叉树的性能，我们规定在插入和删除结点时，要保证任意结点的左右子树高度差的绝对值不超过1，将这样的二叉树称为<strong>平衡二叉树（AVL）</strong>。定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是 -1， 0或 1。</p><p>&emsp;&emsp;平衡二叉树：一棵空树，或是具有以下性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度差的绝对值不超过1。</p><h3 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h3><p>&emsp;&emsp;基本思路：每当在二叉排序树中插入（删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作二导致了不平衡。若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值是否大于1的结点A，再对以A为根的子树，在保持二叉排序树的特性的前提下，调整各个结点的位置关系，使之重新达到平衡。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E6%9C%80%E5%B0%8F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p><p>&emsp;&emsp;平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要作出相应的调整。一般可将失去平衡后进行调整的规律归纳为下列四种情况：</p><p>&emsp;&emsp;1）LL平衡旋转（右单旋转）。</p><p>&emsp;&emsp;&emsp;&emsp;由于在根结点的左孩子的左子树（L）上插入一个新结点，根结点的平衡因子由 1 增至 2 ，导致以A为根的子树失去平衡，需要一次向右的旋转操作。将根结点的左孩子向右上旋转代替称为根结点，将根结点向右下旋转成为左孩子的右子树的根结点，而原先左孩子的右子树变为现在根结点的右孩子的左子树。</p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/LL平衡旋转.png" style="zoom: 80%;" /><p>&emsp;&emsp;2）RR平衡旋转（左单旋转）。</p><p>&emsp;&emsp;&emsp;&emsp;由于在根结点的右孩子的右子树（R）上插入一个新结点，根结点的平衡因子由 1 增至 2 ，导致以A为根的子树失去平衡，需要一次向左的旋转操作。将根结点的右孩子向左上旋转代替称为根结点，将根结点向左下旋转成为右孩子的左子树的根结点，而原先右孩子的左子树变为现在根结点的左孩子的右子树。</p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/RR平衡旋转.png" style="zoom:80%;" /><p>&emsp;&emsp;3）LR平衡旋转（先左后右双旋转）。</p><p>&emsp;&emsp;&emsp;&emsp;由于在根结点的左孩子的右子树上面插入新结点，导致根结点的两个子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将根结点的左孩子的右子树的根结点向左上旋转提升到根结点的左孩子结点的位置，然后再把该结点向右上旋转提升到根结点的位置。</p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/LR平衡旋转.png" style="zoom:80%;" /><p>&emsp;&emsp;4）RL平衡旋转（先右后左双旋转）。</p><p>&emsp;&emsp;&emsp;&emsp;由于在根结点的右孩子的左子树上面插入新结点，导致根结点的两个子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将根结点的右孩子的左子树的根结点向右上旋转提升到根结点的右孩子结点的位置，然后再把该结点向左上旋转提升到根结点的位置。</p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/RL平衡旋转.png" style="zoom: 250%;" /><h3 id="平衡二叉树的查找"><a href="#平衡二叉树的查找" class="headerlink" title="平衡二叉树的查找"></a>平衡二叉树的查找</h3><p>&emsp;&emsp;在平衡二叉树上进行查找时的过程与二叉排序树的相同。含有n个结点的平衡二叉树的最大深度为O（log<sub>2</sub>n）,因此平衡二叉树的平均查找长度为O（log<sub>2</sub>n）。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贫穷的本质</title>
      <link href="2021/04/22/%E8%B4%AB%E7%A9%B7%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E6%91%86%E8%84%B1%E4%B8%8D%E4%BA%86%E8%B4%AB%E7%A9%B7/"/>
      <url>2021/04/22/%E8%B4%AB%E7%A9%B7%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E6%91%86%E8%84%B1%E4%B8%8D%E4%BA%86%E8%B4%AB%E7%A9%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="贫穷的本质是什么？"><a href="#贫穷的本质是什么？" class="headerlink" title="贫穷的本质是什么？"></a>贫穷的本质是什么？</h1><h2 id="一、穷人缺乏有效的避险工具"><a href="#一、穷人缺乏有效的避险工具" class="headerlink" title="一、穷人缺乏有效的避险工具"></a>一、穷人缺乏有效的避险工具</h2><ol><li><p>穷人会生一堆孩子，但生孩子不是观念落后，而是一种理性思考，因为穷人所在的国家往往没有社会保障体系，想规避养老和医疗风险，只能依靠自己的子女，但是子女身上不确定性太多，或者早夭，或者关系不好，或者没能力养老，穷人往往采取多生几个的策略，尽量规避风险。</p></li><li><p>婚姻也是一种规避风险的方式。印度的穷人一般会将自己的女儿嫁到不远不近的村庄，如果两个村子太近，气候完全一样，你这里发洪水，我这个也发洪水，谁也帮不上谁。两个村子隔开一段距离，气候条件就不一样了，遇到灾险，不至于全军覆没，还可互相帮助。</p></li><li><p>穷人借高利贷，是因为正规金融体系排斥穷人。高利贷的利息高是由风险定价决定的，并非剥削。穷人使用高利贷规避可能出现的灾病风险，几乎不可能脱贫，因为高利贷的利息成本和穷人的违约率“一损俱损”。</p></li></ol><span id="more"></span><h2 id="二、穷人不做远期规划"><a href="#二、穷人不做远期规划" class="headerlink" title="二、穷人不做远期规划"></a>二、穷人不做远期规划</h2><ol><li><p>绝大多数地方的穷人对教育很不重视，即便很多慈善组织跑来给他们建立学校、普及教育的好处，家长们积极性也不高。因为穷人并不确定10个儿女里，哪个可能会给他养老，而偏偏教育是个长期投入，要好多年后才能看到成效。让穷人赌一个遥遥无期的结果，要冒太大风险。他们宁愿把钱花到马上就能见效的事情上，比如买点食物，改善一下伙食。</p></li><li><p>穷人是很穷，连填饱肚子都有困难，如果他们得到慈善机构的粮食补助，但穷人会拿补贴的钱去买电视机、收音机。和我们的直觉相反，对穷人来说，他首要选择不是填饱肚子，而是让自己毫无希望的贫穷生活少一点儿乏味。</p></li><li><p>人的压力和一种叫皮质醇激素水平相关，皮质醇水平越高就代表压力越大。穷人长期处于生存压力中，皮质醇水平很高，这会影响大脑的部分区域，比如前额皮质、类扁桃体等，这些是认知功能的重要区域。所以，长期处于压力之下的穷人，他们不太可能会做出理智的决定、长远的决策。</p></li></ol><h2 id="三、穷人充满执拗和偏见"><a href="#三、穷人充满执拗和偏见" class="headerlink" title="三、穷人充满执拗和偏见"></a>三、穷人充满执拗和偏见</h2><ol><li><p>穷人会把自己的大部分钱花在健康上，但他们的花销很不科学。比如，穷人特别喜欢用抗生素，而且经常会做一些为时已晚的外科手术。也就是说，穷人平常不会花点小钱预防疾病，而等到健康真的出了大问题了，他们又不惜借钱来拼命治疗。穷人相信一种理论，他们觉得药物直接输送至血液是很重要的，所以，他们觉得输液比口服药物更有效，会大量的使用抗生素。</p></li><li><p>说服穷人父母们让孩子来打疫苗是一件非常困难的事儿，因为他们不相信疫苗，并不是所有没接种的孩子都会感染麻疹，但这事儿在家长们看来就有问题了，接种的和没接种的都没得病啊，说明疫苗没用。接种一种疫苗只能预防一种疾病，其他的疾病可预防不了，受过教育的父母就觉得自己受了骗，以后再也不让孩子打疫苗了。</p></li></ol><h2 id="四、我们和穷人思维上没有本质区别"><a href="#四、我们和穷人思维上没有本质区别" class="headerlink" title="四、我们和穷人思维上没有本质区别"></a>四、我们和穷人思维上没有本质区别</h2><ol><li><p>很多人一辈子省吃俭用，不办健身卡、不舍得体检，真的检查出大病了，哪怕是晚期，全家人都会四处举债借钱，做各种昂贵的手术，只为延长哪怕几个月的生命。</p></li><li><p>很多年轻人沉迷于网络游戏，荒废工作学习，因为游戏的设计者利用了心理学上刺激反馈的概念，这种机制给你一个短期刺激，做一个动作就会有相应的反馈出现，而工作学习是个苦活，还要长期坚持才能见效，不如游戏里即时刺激有趣。</p></li><li><p>在不懂的事情上，我们一样有偏见，在网上慷慨激昂的反对转基因食品的人，并不清楚转基因到底是什么，只是凭感觉认为人工的东西不如天然。去医院看病，明明看不懂，但主管会觉得医生肯定做不必要的检查了，在我们认知水平达不到的领域，我们也喜欢按直觉和情绪去理解很多东西。</p></li></ol><p><strong>&emsp;&emsp;总结一下：穷人之所以穷是因为，第一，避险手段太落后，第二，他们只顾眼前，不做任何长远规划，第三，因为认知水平的局限，他们对不懂的东西有太多偏见。其实我们和穷人并没有什么本质的区别，他们犯的错误，我们也在犯。</strong></p><p><strong>&emsp;&emsp;金句：</strong></p><p><strong>&emsp;&emsp;穷人会听到这样的声音，“你永远都买不起那台电冰箱，还是喝杯茶吧……”。结果形成了一个恶性循环：对于穷人来说，存钱的吸引力更小，因为在他们看来，目标太遥远了，而且他们知道一路上会遇到很多诱惑。不过，如果不存钱，他们会一直穷下去。放弃短期目标，追求长期目标，需要人的自我控制能力，但自我控制就像一块肌肉：我们用这块肌肉时就会感到劳累，因此穷人很难存下钱也就不足为怪了。</strong></p><p><strong>&emsp;&emsp;对于生活在安全而干净的家中、躺在舒适沙发上的我们来说，痛斥家长式作风的危害、告诉自己该为自己的生活负责是轻而易举的。对于我们这些生活在富裕世界的人来说，我们目前不正是这种家长式作风的永久受益者么？我们深深扎根于这一体系而浑然不觉。这个体系不仅可以将我们照顾得更好，而且我们也不需要去思考生活中的其他问题。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 财富密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论语摘抄</title>
      <link href="2021/04/22/%E8%AE%BA%E8%AF%AD/"/>
      <url>2021/04/22/%E8%AE%BA%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="论语摘抄"><a href="#论语摘抄" class="headerlink" title="论语摘抄"></a>论语摘抄</h1><h2 id="学而篇"><a href="#学而篇" class="headerlink" title="学而篇"></a>学而篇</h2><h3 id="emsp-emsp-子曰：不患人之不己知，患不知人也。"><a href="#emsp-emsp-子曰：不患人之不己知，患不知人也。" class="headerlink" title="&emsp;&emsp;子曰：不患人之不己知，患不知人也。"></a>&emsp;&emsp;子曰：不患人之不己知，患不知人也。</h3><p>&emsp;&emsp;不怕别人不理解我，就怕自己不了解别人。</p><h2 id="为政篇"><a href="#为政篇" class="headerlink" title="为政篇"></a>为政篇</h2><h3 id="emsp-emsp-子游问孝。子曰：今之孝者，是为能养。至于犬马，皆能有养，不敬，何以别乎？"><a href="#emsp-emsp-子游问孝。子曰：今之孝者，是为能养。至于犬马，皆能有养，不敬，何以别乎？" class="headerlink" title="&emsp;&emsp;子游问孝。子曰：今之孝者，是为能养。至于犬马，皆能有养，不敬，何以别乎？"></a>&emsp;&emsp;子游问孝。子曰：今之孝者，是为能养。至于犬马，皆能有养，不敬，何以别乎？</h3><p>&emsp;&emsp;如果只是以物质赡养父母，而不在精神上做到孝，那其实不是真正的孝。要体悟父母的心情，让他们安心。</p><h3 id="emsp-emsp-大勇若怯，大智若愚"><a href="#emsp-emsp-大勇若怯，大智若愚" class="headerlink" title="&emsp;&emsp;大勇若怯，大智若愚"></a>&emsp;&emsp;大勇若怯，大智若愚</h3><p>&emsp;&emsp;苏东坡所说，并不是论语里面的。</p><h3 id="emsp-emsp-子曰：君子不器。"><a href="#emsp-emsp-子曰：君子不器。" class="headerlink" title="&emsp;&emsp;子曰：君子不器。"></a>&emsp;&emsp;子曰：君子不器。</h3><p>&emsp;&emsp;君子应该博学多识，而不是像器具一样，只有一方面的用途，我觉得应该是各方面都有所涉猎，同时也有专精的地方。</p><h3 id="emsp-emsp-子曰：先行其言而后从之。"><a href="#emsp-emsp-子曰：先行其言而后从之。" class="headerlink" title="&emsp;&emsp;子曰：先行其言而后从之。"></a>&emsp;&emsp;子曰：先行其言而后从之。</h3><p>&emsp;&emsp;先行其言二后从之。先做再说。</p><h3 id="emsp-emsp-子曰：君子周而不比，小人比而不周。"><a href="#emsp-emsp-子曰：君子周而不比，小人比而不周。" class="headerlink" title="&emsp;&emsp;子曰：君子周而不比，小人比而不周。"></a>&emsp;&emsp;子曰：君子周而不比，小人比而不周。</h3><p>&emsp;&emsp;孔子说：君子能普遍地团结人而不与人相互勾结；小人与人勾结而不能普遍地团结人。</p><h3 id="emsp-emsp-子曰：人而无信，不知其可也。大车无輗，小车无樾，其何以行之哉？"><a href="#emsp-emsp-子曰：人而无信，不知其可也。大车无輗，小车无樾，其何以行之哉？" class="headerlink" title="&emsp;&emsp;子曰：人而无信，不知其可也。大车无輗，小车无樾，其何以行之哉？"></a>&emsp;&emsp;子曰：人而无信，不知其可也。大车无輗，小车无樾，其何以行之哉？</h3><p>&emsp;&emsp;如果一个人不讲信用，不知道他怎么可以做人。好比大车没有套横木的輗，小车没有套横木的樾，怎么能行走呢？</p><h3 id="emsp-emsp-子曰：非其鬼而祭之，谄也。见义不为，无勇也。"><a href="#emsp-emsp-子曰：非其鬼而祭之，谄也。见义不为，无勇也。" class="headerlink" title="&emsp;&emsp;子曰：非其鬼而祭之，谄也。见义不为，无勇也。"></a>&emsp;&emsp;子曰：非其鬼而祭之，谄也。见义不为，无勇也。</h3><p>&emsp;&emsp;不是自己应该祭祀的鬼神而去祭祀它，这就是献媚。需要见义勇为时却不能挺声而出，这是懦弱。</p><h2 id="里仁篇"><a href="#里仁篇" class="headerlink" title="里仁篇"></a>里仁篇</h2><h3 id="emsp-emsp-子曰：里仁为美，择不处仁，焉得知？"><a href="#emsp-emsp-子曰：里仁为美，择不处仁，焉得知？" class="headerlink" title="&emsp;&emsp;子曰：里仁为美，择不处仁，焉得知？"></a>&emsp;&emsp;子曰：里仁为美，择不处仁，焉得知？</h3><p>&emsp;&emsp;居住在有人的的地方才好。选择的住处没有仁德，怎么能获得智慧呢？（自己的理解）</p><h3 id="emsp-emsp-子曰：苟志于仁矣，无恶也。"><a href="#emsp-emsp-子曰：苟志于仁矣，无恶也。" class="headerlink" title="&emsp;&emsp;子曰：苟志于仁矣，无恶也。"></a>&emsp;&emsp;子曰：苟志于仁矣，无恶也。</h3><p>&emsp;&emsp;如果一个人具备了仁的修养，就不会去做坏事了。</p><h3 id="emsp-emsp-子曰：士志于道，而耻恶衣恶食者，未足与议也。"><a href="#emsp-emsp-子曰：士志于道，而耻恶衣恶食者，未足与议也。" class="headerlink" title="&emsp;&emsp;子曰：士志于道，而耻恶衣恶食者，未足与议也。"></a>&emsp;&emsp;子曰：士志于道，而耻恶衣恶食者，未足与议也。</h3><p>&emsp;&emsp;读书人有志于真理，但是以穿破衣。吃粗食为耻的人，不值得与他谈论真理。我们应该追求真理大道，而不是过于追求物质享受。</p><h3 id="emsp-emsp-子曰：君子之于天下也，无适也，无莫也，义之与比。"><a href="#emsp-emsp-子曰：君子之于天下也，无适也，无莫也，义之与比。" class="headerlink" title="&emsp;&emsp;子曰：君子之于天下也，无适也，无莫也，义之与比。"></a>&emsp;&emsp;子曰：君子之于天下也，无适也，无莫也，义之与比。</h3><p>&emsp;&emsp;君子对于天下的事，无所谓必行，无所谓必不行，只要符合道义就可以了。</p><h3 id="emsp-emsp-子曰：不患无位，患所以立；不患莫己知，求为可知也。"><a href="#emsp-emsp-子曰：不患无位，患所以立；不患莫己知，求为可知也。" class="headerlink" title="&emsp;&emsp;子曰：不患无位，患所以立；不患莫己知，求为可知也。"></a>&emsp;&emsp;子曰：不患无位，患所以立；不患莫己知，求为可知也。</h3><p>&emsp;&emsp;不担心没有职位，担心的是没有立足的能力；不怕没有人知道自己，只要力求自己成为能够被人知道的具有才德的人就行了。</p><h3 id="emsp-emsp-子曰：君子喻于义，小人喻于义。"><a href="#emsp-emsp-子曰：君子喻于义，小人喻于义。" class="headerlink" title="&emsp;&emsp;子曰：君子喻于义，小人喻于义。"></a>&emsp;&emsp;子曰：君子喻于义，小人喻于义。</h3><p>&emsp;&emsp;君子通晓的是义，小人只知道利。</p><h3 id="emsp-emsp-子曰：古者言之不出，耻躬之不逮也。"><a href="#emsp-emsp-子曰：古者言之不出，耻躬之不逮也。" class="headerlink" title="&emsp;&emsp;子曰：古者言之不出，耻躬之不逮也。"></a>&emsp;&emsp;子曰：古者言之不出，耻躬之不逮也。</h3><p>&emsp;&emsp;古代的人话不轻易说出来，因为他们以自己的行为跟不上为耻辱。先做再说，给自己一个交代，给别人一个交代，否则失了威信。</p><h3 id="emsp-emsp-子曰：君子欲讷于言而敏于行。"><a href="#emsp-emsp-子曰：君子欲讷于言而敏于行。" class="headerlink" title="&emsp;&emsp;子曰：君子欲讷于言而敏于行。"></a>&emsp;&emsp;子曰：君子欲讷于言而敏于行。</h3><p>&emsp;&emsp;君子说话要谨慎，而行动要敏捷勤快。</p><h3 id="emsp-emsp-子曰：德不孤，必有邻。"><a href="#emsp-emsp-子曰：德不孤，必有邻。" class="headerlink" title="&emsp;&emsp;子曰：德不孤，必有邻。"></a>&emsp;&emsp;子曰：德不孤，必有邻。</h3><p>&emsp;&emsp;有德行的不会孤单，一定会有思想一致的人与他相处。</p><h3 id="emsp-emsp-子游曰：事君数，斯辱矣；朋友数，斯疏矣。"><a href="#emsp-emsp-子游曰：事君数，斯辱矣；朋友数，斯疏矣。" class="headerlink" title="&emsp;&emsp;子游曰：事君数，斯辱矣；朋友数，斯疏矣。"></a>&emsp;&emsp;子游曰：事君数，斯辱矣；朋友数，斯疏矣。</h3><p>&emsp;&emsp;侍奉君主劝谏过于繁琐，就会遭到侮辱；对待朋友规劝过于繁琐，就会被疏远。</p><h2 id="公治长篇"><a href="#公治长篇" class="headerlink" title="公治长篇"></a>公治长篇</h2><h3 id="emsp-emsp-朽木不可雕也，粪土之墙不可朽也。于予与何诛！"><a href="#emsp-emsp-朽木不可雕也，粪土之墙不可朽也。于予与何诛！" class="headerlink" title="&emsp;&emsp;朽木不可雕也，粪土之墙不可朽也。于予与何诛！"></a>&emsp;&emsp;朽木不可雕也，粪土之墙不可朽也。于予与何诛！</h3><p>&emsp;&emsp;腐朽了的木头不能雕刻，粪土一样的墙壁不能再粉刷了。对于宰予这样的人再责备他有什么用呢？</p><h3 id="emsp-emsp-季文子三思而后行。子闻之，曰：再，斯可矣。"><a href="#emsp-emsp-季文子三思而后行。子闻之，曰：再，斯可矣。" class="headerlink" title="&emsp;&emsp;季文子三思而后行。子闻之，曰：再，斯可矣。"></a>&emsp;&emsp;季文子三思而后行。子闻之，曰：再，斯可矣。</h3><p>&emsp;&emsp;季文子每做什么事情之前都要斟酌再三，反复考虑。孔子听到了，说：想两次就可以了。</p><h2 id="雍也篇"><a href="#雍也篇" class="headerlink" title="雍也篇"></a>雍也篇</h2><h3 id="emsp-emsp-子曰：贤哉回也，一箪食，一瓢饮，在陋巷，人不堪其忧，回也不改其乐。贤哉回也。"><a href="#emsp-emsp-子曰：贤哉回也，一箪食，一瓢饮，在陋巷，人不堪其忧，回也不改其乐。贤哉回也。" class="headerlink" title="&emsp;&emsp;子曰：贤哉回也，一箪食，一瓢饮，在陋巷，人不堪其忧，回也不改其乐。贤哉回也。"></a>&emsp;&emsp;子曰：贤哉回也，一箪食，一瓢饮，在陋巷，人不堪其忧，回也不改其乐。贤哉回也。</h3><p>&emsp;&emsp;贤德啊，颜回！一个竹筐盛饭，一个瓜瓢喝水，住在小巷子里。别人都忍受不了贫困的烦扰，颜回却不改变他自身的快乐。贤德啊，颜回！</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 国学经典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树和二叉树基本概念</title>
      <link href="2021/04/22/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>2021/04/22/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;树是n个结点的有限集合，n = 0 时，称为空树。在任意空树中应满足：</p><ol><li><p>有且仅有一个特定的称为根的结点</p></li><li><p>当 n &gt; 1时，其余结点可分为 m 个互不相交的有限集合，其中每个集合本身又是一棵树，并且成为根节点的子树。</p><p>树的定义是递归的，也是一种递归的数据结构。有两个特点：</p><ol><li><p>树的根节点没有前驱结点，除根节点外的所有结点有且只有一个前驱结点</p></li><li><p>树中所有结点可以有零的或多个后继结点</p></li></ol></li></ol><p>&emsp;&emsp;树适合表示具有层次结构的数据。数中的某个结点最多只和上一层的一个结点有直接关系，根结点没有直接上层结点，所有在n个结点的书中有 n - 1 条边。</p><span id="more"></span><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><p>&emsp;&emsp;这里要注意的主要是：</p><p>&emsp;&emsp;1）**祖先结点 **对应  <strong>子孙结点</strong>； <strong>双亲结点</strong> 对应 <strong>孩子结点</strong>； 具有相同双亲的结点称为 <strong>兄弟结点</strong>。</p><p>&emsp;&emsp;2）树中一个结点的子结点个数称为<strong>结点的度</strong>；树中结点的最大度数称为<strong>树的度</strong>。</p><p>&emsp;&emsp;3）度大于0 的称为 分支结点；度为 0 的结点称为 叶子结点；</p><p>&emsp;&emsp;4）结点的深度、高度和层次</p><p>&emsp;&emsp;&emsp;&emsp;结点的层次：从根结点开始定义的，根结点第一层，一直往下推</p><p>&emsp;&emsp;&emsp;&emsp;结点的深度：从根结点开始自顶向下逐层相加</p><p>&emsp;&emsp;&emsp;&emsp;结点的高度：从叶结点开始自底向上逐层相加</p><p>&emsp;&emsp;&emsp;&emsp;树的高度： 树中结点的最大层数</p><p>&emsp;&emsp;5）有序树，无序树</p><p>&emsp;&emsp;&emsp;&emsp;有序树：树中结点的子树从左到右是有次序的，不能交换</p><p>&emsp;&emsp;6）路径和路径长度</p><p>&emsp;&emsp;&emsp;&emsp;树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数。兄弟结点之间不存在路径。</p><p>&emsp;&emsp;7）森林： 森林是由m棵互不相交的集合。</p><h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><p>&emsp;&emsp;1、树中的结点数等于所有结点的度数加1</p><p>&emsp;&emsp;2、度为 m 的树中第 i 层 上至多有 m<sup>i-1</sup> 结点</p><p>&emsp;&emsp;3、高度为 h 的 m 叉树 至多有（m<sup>h</sup> - 1）/ ( m - 1 )个结点</p><p>&emsp;&emsp;4、具有 n 个 结点的m叉树的最小高度为[log<sub>m</sub>(n(m-1) + 1)]</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;二叉树的特点就是每个节点至多只有两颗子树，并且二叉树的子树有左右之分，其次序不能任意颠倒。</p><p>&emsp;&emsp;五种基本形态：</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BD%A2%E6%80%81.jpg"></p><p><strong>&emsp;&emsp;二叉树与度为2的有序树的区别：</strong></p><p>&emsp;&emsp;1）度为2的树至少有三个结点，而二叉树可以为空</p><p>&emsp;&emsp;2）度为2的有序树的孩子结点左右次序是相对的，但是二叉树的结点次序是确定的。</p><h3 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h3><p>&emsp;&emsp;1、<strong>满二叉树</strong>：一棵树高度为h，且含有2<sup>h</sup> - 1 个结点的二叉树称为 满二叉树。就是说满二叉树中的所有结点（除叶子结点）都含有两个子结点，也就是度为2。若对满二叉树从根结点编号，自上而下，自左向右，那么对于编号为 i 的结点，若有双亲，则其双亲为 i / 2 (向下取整)，若有左孩子，则左孩子为 2i , 若有右孩子，则右孩子为 2i + 1。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p><p>&emsp;&emsp;2、<strong>完全二叉树</strong>：设一个高度为h，有n个结点的二叉树，当且仅当每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p><p>  完全二叉树的特点：</p><p>    1、若 i &lt;= n/2(向下取整)，则结点i为分支结点，否则为叶子结点。</p><p>    2、叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都一次排列在该层最左边的位置上。</p><p>    3、<strong>若有度为1的结点，则只可能只有一个，且该结点只有左孩子而无右孩子（重要特征）。</strong></p><p>    4、按层编号后，一旦出现某结点（编号为i）为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点。</p><p>    5、若n为奇数，则每个分支结点都有左右孩子；若为偶数，则编号最大的分支结点只有左孩子，没有右孩子。</p><p>&emsp;&emsp;3、<strong>二叉排序树</strong>：二叉树或者是空二叉树，左子树上面的关键字都小于根节点的关键字；右子树上面的关键字都大于根节点的关键字。左子树和右子树又各是一棵二叉排序树。</p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/二叉排序树.jpg" style="zoom: 80%;" /><p>&emsp;&emsp;4、<strong>平衡二叉树</strong>：树上的任一结点的左子树和右子树的深度之差不超过 1。</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>&emsp;&emsp;1）非空二叉树上的叶子结点数等于度为2的结点数加 1，即 n<sub>0</sub> = n<sub>2</sub> + 1。</p><p>&emsp;&emsp;2）非空二叉树第k层上至多有 2<sup>k-1</sup>个结点（k &gt;= 1）</p><p>&emsp;&emsp;3）高度为 h 的二叉树 至多有 2<sup>h</sup> - 1 个结点</p><p>&emsp;&emsp;4）结点 i  所在层次 为 log<sub>2</sub>i(向下取整) + 1</p><p>&emsp;&emsp;5）具有n个结点的完全二叉树的高度为 log<sub>2</sub>n(向下取整) + 1  或    log<sub>2</sub>(n+1)  (向上取整)。</p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>&emsp;&emsp;1、<strong>顺序存储结构</strong></p><p>&emsp;&emsp;二叉树的顺序存储结构是指用一组地址连续的存储但愿此意自上而下，自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在某个数组下标为 i - 1 的分量中，然后通过一些方法确定结点在逻辑上的父子和兄弟关系。</p><p>&emsp;&emsp;完全二叉树和满二叉树采用顺序存储比较合适，但是对于一般的二叉树，为了数组下标能够反映二叉树中结点之间的逻辑关系，只能添加并不存在的空结点，让每个结点与完全二叉树上的结点相对照，再存储到一对数组的相应分量上中。然而，在最坏情况下，一个高度为h 且只有 h个结点的单支树却需要占据近2<sup>h</sup> -  1 个存储单元，称为树的退化。</p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/二叉树顺序存储.jpg" style="zoom: 50%;" /><p>&emsp;&emsp;2、<strong>链式存储结构</strong></p><p>&emsp;&emsp;由于顺序存储空间利用率低，因此二叉树一般采用链式存储结构。链式存储结构是指用一个链表来存储一棵二叉树，二叉树中的每个结点用链表的一个结点来存储。二叉链表至少含有 3 个域：数据域data，左指针域lchild，右指针域rchild。</p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/二叉树链式存储结点.png" style="zoom: 50%;" /><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8.jpg"></p><p>&emsp;&emsp;二叉树的链式存储结构：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BitNode,*BitTree;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树</title>
      <link href="2021/04/22/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>2021/04/22/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h2><p>&emsp;&emsp;在许多实际应用中，树中结点常常被赋予一个表示某种意义的数值，称为该<strong>结点的权</strong>。从树根结点到任意结点的路径长度（经过的边数）与该结点上权值的乘积，称为该结点的<strong>带权路径长度</strong>。树中所有结点的带权路径长度之和称为全树的带权路径长度，记为：<br>$$<br>WPL=\sum_{i=1}^n W_iL_i<br>$$<br>&emsp;&emsp;W<sub>i</sub> 是第i个结点所带的权值，L<sub>i</sub> 是该结点到根结点的路径长度。</p><p>&emsp;&emsp;在含有n个带权叶子的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称最优二叉树。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E4%B8%8D%E5%90%8C%E6%9D%83%E5%80%BC%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p><span id="more"></span><p>&emsp;&emsp;（a）WPL = 7 x 2 + 5 x 2 + 2 x 2 + 4 x 2 = 36；</p><p>&emsp;&emsp;（b）WPL = 7 x 3 + 5 x 3 + 2 x 1 + 4 x 2 = 46；</p><p>&emsp;&emsp;（c）WPL = 7 x 1 + 5 x 2 + 2 x 3 + 4 x 3 = 35；</p><p>其中，c中的树的wpl最小，可以验证，它恰好为哈夫曼树。</p><h2 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h2><p>&emsp;&emsp;算法描述如下：</p><ol><li>将这n个结点分别作为n棵仅含有一个结点的二叉树，构成森林F。</li><li>构造一个新结点，从F中选取两颗树节点权值最小的树作为新结点的左、右子树，并且将新节点的权值置为左、右子树上根结点的权值之和。</li><li>从F中删除刚选出的两棵树，同时将新得到的树加入到F中。</li><li>重复步骤2和3，直至F中只剩下一棵树为止。</li></ol><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0.png"></p><p>&emsp;&emsp;从上述构造过程中可以看出哈夫曼树具有如下特点：</p><ol><li>每个初始结点最终都成为叶结点，且权值越小的节点到根结点的路径长度越大。</li><li>构造过程中共新建了 n-1 个结点，因此哈夫曼树中的结点总数为 2n - 1。</li><li>每次构造都选择 2 棵树作为新结点的孩子，因此哈夫曼树中不存在度为 1 的结点。</li></ol><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>&emsp;&emsp;对应待处理的一个字符串序列，若对每个字符用同样长度的二进制表示，则称这种编码方式为<strong>固定长度编码</strong>。若允许对不同字符用不等长的二进制位表示，则这种方式称为<strong>可变长度编码</strong>。 可变长编码的特点是对高频率的字符赋以端编码，而对频率较低的字符则以较长的一些的编码，从而可以使字符平均编码长度剪短，起到压缩数据的效果。</p><p>&emsp;&emsp;若没有一个编码是另一个编码的前缀，则这样的编码为前缀编码。</p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/哈夫曼编码.jpg" style="zoom: 67%;" /><p>&emsp;&emsp;构造出的哈夫曼树不唯一，但各哈夫曼树的带权路径长度相同且为最优。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股票实战法</title>
      <link href="2021/04/22/%E8%82%A1%E7%A5%A8%E5%AE%9E%E6%88%98%E6%B3%95/"/>
      <url>2021/04/22/%E8%82%A1%E7%A5%A8%E5%AE%9E%E6%88%98%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<pre><code>    在股市稳定赚钱的人，肯定有自己的交易系统；有自己交易系统的人，不一定在股市稳定赚钱。</code></pre><h1 id="做短线最需要的是什么？"><a href="#做短线最需要的是什么？" class="headerlink" title="做短线最需要的是什么？"></a>做短线最需要的是什么？</h1><h2 id="1、执行力"><a href="#1、执行力" class="headerlink" title="1、执行力"></a>1、执行力</h2><p>​                执行力说人话就是：自己决定的事打死也要做到。你只需要勇敢地执行你认为对的事情，增加计划中的交易，并提高计划交易的质量。任何一个超短交易模式加上钢一样的执行力都是一个稳定收益模式的开始，无关技术，只看性格和时间。</p><h2 id="2、稳定盈利模式"><a href="#2、稳定盈利模式" class="headerlink" title="2、稳定盈利模式"></a>2、稳定盈利模式</h2><p>​                超短的盈利模式有很多种，适合自己的才是最好的，只要你能严格执行2年以上，保证每3个月都能盈利，就算是稳定的盈利模式了。最基本的稳定盈利模式就是一招打遍天下无敌手。</p><span id="more"></span><h1 id="指标1-高成功率的指标之王（MACD）"><a href="#指标1-高成功率的指标之王（MACD）" class="headerlink" title="指标1: 高成功率的指标之王（MACD）"></a>指标1: 高成功率的指标之王（MACD）</h1><h2 id="一、什么是MACD"><a href="#一、什么是MACD" class="headerlink" title="一、什么是MACD?"></a>一、什么是MACD?</h2><p>​                MACD（异同移动平均线）指标，下面是MACD图：</p><p>​                <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304141703498.png" alt="image-20210304141703498"></p><p>​                1、DIFF，也就是图中的黄线。DIFF是短期（常用12日）指数移动平均线与长期（常用26日）指数移动平均线的差值。因为其变动较为灵敏，又称快线。</p><p>​                2、DEA，也就是图中的红线。DEA是M日（常用9日）的平滑移动平均线。因其变化稍慢，又称慢线。</p><p>​                3、MACD红绿柱线，是DIFF值与DEA差值的2倍数值，柱线的高低直接反映多空能量的强弱。</p><p>​                4、零轴线，也就是绿柱子与红柱子长出的地方。零轴线是MACD的多空分界线，DIFF和DEA在零轴线之上为多头市场，在零轴线以下是空头市场。</p><h2 id="二、形态"><a href="#二、形态" class="headerlink" title="二、形态"></a>二、形态</h2><h3 id="1、金叉"><a href="#1、金叉" class="headerlink" title="1、金叉"></a>1、金叉</h3><p>​                    DIFF线自下而上穿越DEA，MACD则由绿柱转为红柱。代表股价由下跌开始转为上升，意味着多头市场的开始。</p><h4 id="1、零（轴）上金叉"><a href="#1、零（轴）上金叉" class="headerlink" title="1、零（轴）上金叉"></a>1、零（轴）上金叉</h4><p>​                          一般而言，DIFF和DEA都位于零轴线上方时是零上金叉。市场整体处于多头市场，金叉锦上添花，往往意味着新一波大涨势的开始。</p><h4 id="2、零（轴）下金叉"><a href="#2、零（轴）下金叉" class="headerlink" title="2、零（轴）下金叉"></a>2、零（轴）下金叉</h4><p>​                          DIFF和DEA都位于零轴线下方时是零下金叉。往往只是空头市场短暂的反弹，所以其稳定度和可靠性都较低，力度也不大。当DIFF和DEA在零轴线下方形成二次或多次金叉时，稳定度及可靠性就会大大提高，力度也往往较大。</p><h3 id="2、死叉"><a href="#2、死叉" class="headerlink" title="2、死叉"></a>2、死叉</h3><p>​                    DIFF自上而下穿越DEA，MACD柱线由红柱转变为绿柱，代表股价由上升转为下跌，意味着空头市场的开始。</p><h4 id="1、零（轴）上死叉"><a href="#1、零（轴）上死叉" class="headerlink" title="1、零（轴）上死叉"></a>1、零（轴）上死叉</h4><p>​                           一般而言，DIFF和DEA同在零轴线上方为零（轴）上死叉，往往只是多头市场中的一个回调，可靠性不高，且调整幅度不会太大。</p><h4 id="2、零（轴）下死叉"><a href="#2、零（轴）下死叉" class="headerlink" title="2、零（轴）下死叉"></a>2、零（轴）下死叉</h4><p>​                            DIFF和DEA同处于零轴线以下为零（轴）下死叉，往往意味着新一波下跌的开始，且可靠性极高，下跌幅度也较大。</p><h2 id="三、简单粗暴三板斧"><a href="#三、简单粗暴三板斧" class="headerlink" title="三、简单粗暴三板斧"></a>三、简单粗暴三板斧</h2><h3 id="第一板斧—MACD抄底术"><a href="#第一板斧—MACD抄底术" class="headerlink" title="第一板斧—MACD抄底术"></a>第一板斧—MACD抄底术</h3><p>​                        1.经过一波下跌后反弹；</p><p>​                        2.股价再次下跌创新低；</p><p>​                        3.MACD的DIFF线低点不创新低；</p><p>​                        4.<strong>MACD金叉确认底背离即是买入信号</strong>。</p><p>​                    <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304143556681.png" alt="image-20210304143556681"></p><h3 id="第二板斧——MACD抓主升"><a href="#第二板斧——MACD抓主升" class="headerlink" title="第二板斧——MACD抓主升"></a>第二板斧——MACD抓主升</h3><p>​                        1.经过一波上涨后调整；</p><p>​                        2.股价调整不破前低；</p><p>​                        3.<strong>MACD在略高于零轴线位置金叉；</strong></p><p>​                        4.<strong>出中阳K线即买入信号</strong>。</p><p>​                    <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304143842740.png" alt="image-20210304143842740"></p><h3 id="第三板斧——MACD逃顶术"><a href="#第三板斧——MACD逃顶术" class="headerlink" title="第三板斧——MACD逃顶术"></a>第三板斧——MACD逃顶术</h3><p>​                        1.经过一波上涨后调整；</p><p>​                        2.股价第二波上涨创新高；</p><p>​                        3.MACD的DIFF线高点未创新高；</p><p>​                        4.<strong>MACD死叉确认顶背离即卖出信号</strong>。</p><p>​                     <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304144220148.png" alt="image-20210304144220148"></p><h1 id="指标2-指标搭配运用才能无往不利-KDJ"><a href="#指标2-指标搭配运用才能无往不利-KDJ" class="headerlink" title="指标2: 指标搭配运用才能无往不利(KDJ)"></a>指标2: 指标搭配运用才能无往不利(KDJ)</h1><p>​                人们为了帮助分析中短期的趋势，用技术指标K、D和J三条线，组成了一个偶像组合——随机指标（KDJ）。它能够比较迅速、快捷、直观地研判行情，是期货和股票市场上最常用的技术分析工具。</p><p>​                <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304144458981.png" alt="image-20210304144458981"></p><p>​                一般情况下，可以把K线与D线都作为J线的僚机来使用，K值和D值的取值范围都是0—100，而J值的取值范围可以超过100和低于0。</p><p>​                总的来说，K、D、J这三条线数值在20以下为超卖区，关注伺机买入。在80以上为超买区，关注伺机卖出，在20—80之间为徘徊区，坐观全场就行了。</p><h2 id="一、形态"><a href="#一、形态" class="headerlink" title="一、形态"></a>一、形态</h2><h3 id="1、金叉-1"><a href="#1、金叉-1" class="headerlink" title="1、金叉"></a>1、金叉</h3><p>​                    当K线从D线的下方向上穿越D线，同时J线从K、D线的下方向上穿越K、D线，形成KDJ金叉，是股价转强的信号。</p><p>​                    若之前K值小于10，D值小于20，J值小于0，KDJ如下图所示：</p><p>​                    <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304144849262.png" alt="image-20210304144849262"></p><p>​                    三线在超卖区形成金叉时，股价成功反弹的可能性较高。</p><h3 id="2、死叉-1"><a href="#2、死叉-1" class="headerlink" title="2、死叉"></a>2、死叉</h3><p>​                    当K线从D线上方向下穿越D线，同时J线从K、D线的上方向下穿越K、D线，形成KDJ死叉时，是股价转弱的信号。</p><p>​                    若之前K值大于90，D值大于80，J值大于100，KDJ是下图这样的状态：</p><p>​                    <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304145003182.png" alt="image-20210304145003182"></p><p>​                    三线在超买区形成死叉时，股价短期下跌的概率较高。</p><h3 id="3、顶背离。"><a href="#3、顶背离。" class="headerlink" title="3、顶背离。"></a>3、顶背离。</h3><p>​                    当股价连续上涨并持续创新高但KDJ并没有同时跟随创出新高时，就会形成KDJ顶背离，预示股价短期上涨乏力。股价短期内极容易滞涨回落，为短期出局信号。</p><h3 id="4、底背离。"><a href="#4、底背离。" class="headerlink" title="4、底背离。"></a>4、底背离。</h3><p>​                    当股价连续下跌并持续创新低，而KDJ并没有同时跟随创出新低时，形成KDJ底背离，预示股价短期下跌动能减弱。股价短期内极容易止跌反弹，是短线抢反弹择机买进的信号。</p><h3 id="5、钝化"><a href="#5、钝化" class="headerlink" title="5、钝化"></a>5、钝化</h3><p>​                    所谓钝化就是指股价在行情中大涨或暴跌，使指标数据出现粘连，让指标失去指导作用，因为KDJ是一个非常敏感的指标，所以它特别容易出现钝化。</p><p>​                    一般钝化分两种：高位钝化和低位钝化。</p><p>​                    高位钝化，在股价走势极强的单边上涨行情中，K值与D值均在80以上的超买区，J值大于100。股价仍在急速上涨创新高，此时形成KDJ高位钝化。此时就可以参考其他指标进行操作。</p><p>​                    低位钝化。一般K值与D值同时在20以下的超卖区，J值在0以下。遇到低位钝化一般意味着股价可能要跌一段时间了。此时适合参考其他指标来判断KDJ何时回归正常，回归后的KDJ金叉是抄底的最好时机。</p><h2 id="二、配合其他指标实战"><a href="#二、配合其他指标实战" class="headerlink" title="二、配合其他指标实战"></a>二、配合其他指标实战</h2><p>​                在股价的实际走势中KDJ买卖信号频繁，且错误虚假信号较多。因为，我们可以看到每次出现顶背离和底背离的时候，KDJ都会出现金叉和死叉。但KDJ每次出现金叉、死叉的时候却不意味着股价也出现了顶背离和底背离，所以，我们要做的就是判断其金叉和死叉的准确性。</p><h3 id="1、MACD-KDJ双金叉选股"><a href="#1、MACD-KDJ双金叉选股" class="headerlink" title="1、MACD+KDJ双金叉选股"></a>1、MACD+KDJ双金叉选股</h3><p>​                    MACD出现金叉买点时，绿柱消失是红柱出现的拐点，仅此信号是买入点。MACD具有延迟性，所以当KDJ出现金叉，并且都处于较低的值的时候，MACD绿柱缩量也即将出现拐点，即可以此来判断此次KDJ为有效指导。为保险起见可在KDJ出现金叉后1—2日买入。</p><h3 id="2、MACD黄白线位于零轴线上方"><a href="#2、MACD黄白线位于零轴线上方" class="headerlink" title="2、MACD黄白线位于零轴线上方"></a>2、MACD黄白线位于零轴线上方</h3><p>​                    KDJ金叉出现时是买入机会。由于KDJ自身的灵敏度较高，影响了指标的准确性，所以只做强势区域的KDJ金叉，准确性会大幅度提升。在实战中，根据二者的交叉和趋势，来判断买卖点，非常可靠。借助KDJ灵敏而MACD稳健的特点，一旦KDJ发出买入信号或者卖出信号，只要等到MACD有要金叉的趋势就可以买卖，不用等到MACD金叉时再买卖。</p><p>​                单一指标是用来验证你的想法的，不具备真正的指导意义。多个指标共振才是真正的交易时机！</p><h1 id="指标3-给你精准战法的交易线-BOLL-BBIBOLL"><a href="#指标3-给你精准战法的交易线-BOLL-BBIBOLL" class="headerlink" title="指标3: 给你精准战法的交易线(BOLL,BBIBOLL)"></a>指标3: 给你精准战法的交易线(BOLL,BBIBOLL)</h1><h2 id="一、布林线指标"><a href="#一、布林线指标" class="headerlink" title="一、布林线指标"></a>一、布林线指标</h2><p>​                布林线指标是怎样的呢？它由上、中、下三条轨线组成。</p><p>​                <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304150353048.png" alt="image-20210304150353048"></p><p>​                <strong>布林线有四大作用：</strong></p><p>​                        （1）布林线可以指示支撑和压力位置，股价通道的上、下轨线可以显示股价安全运行的最高价位和最低价位。</p><p>​                        （2）布林线可以指示趋势，通道的中轨线之上为可操作趋势，中轨线之下为不建议操作区域，强势股总在中、上轨线之间。    </p><p>​                        （3）布林线可以显示超买、超卖。股价冲出上轨线将有回调，股价跌出下轨线将有反抽。</p><p>​                        （4）布林线可以选择方向，上下轨收口变窄隐藏着突变，开口越大说明风险越大。</p><p>​                <strong>布林线开口：</strong></p><p>​                        1.布林线开口向下。出现这个状态的时候马上离场，坐等低吸就可以了。</p><p>​                            <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304150734476.png"></p><p>​                         2.布林线开口紧缩。当出现这个形态的时候会出现突变，马上就会有大变化。至于上涨还是下跌可以根据行情和其他指标参考，如不放心可等形势明了再参与。</p><p>​                            <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304150844844.png" alt="image-20210304150844844"></p><p>​                        3.布林线开口向上。K线沿着布林线上轨在运行，应对的策略就是持股不动，让利润奔跑。</p><p>​                            <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304150917596.png" alt="image-20210304150917596"></p><h2 id="二、布林线和k线"><a href="#二、布林线和k线" class="headerlink" title="二、布林线和k线"></a>二、布林线和k线</h2><p>​                 1.当K线从布林线的中轨线以下向上突破布林线中轨线时，预示着股价的强势特征开始出现。股价将上涨，应以买入为主。</p><p>​                    <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304151105645.png" alt="image-20210304151105645"></p><p>​                2.当K线从布林线的中轨线以上向上突破布林线上轨线时，预示着股价的强势特征已经确立。股价短期将可能大涨，应以持股待涨或短期买入为主。</p><p>​                    <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304151149364.png" alt="image-20210304151149364"></p><p>​                3.当K线向上突破布林线上轨线后，其运行方向继续向上时，如果布林线的运行方向也同时向上，则预示着股市的强势特征依旧，股价短期还将上涨，应坚决持股待涨。</p><p>​                    <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304151222933.png" alt="image-20210304151222933"></p><p>​                4.当K线在布林线上方运动了一段时间后，如果K线掉头向下并突破布林线的上轨时，预示着股价短期的强势行情可能结束，股价短期内将大跌。短线应及时卖出股票，特别是那些短期涨幅很大的股票。</p><p>​                    <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304151305558.png" alt="image-20210304151305558"></p><h2 id="三、BOLL与其他指标的搭配"><a href="#三、BOLL与其他指标的搭配" class="headerlink" title="三、BOLL与其他指标的搭配"></a>三、BOLL与其他指标的搭配</h2><p>​            我们把之前讲的MACD和KDJ也联系起来，顺便加上5日均线（MA5），可以大大提高判断的准确率。</p><p>​            <strong>1.股价一直在连续下跌的同时，KDJ金叉当天或第二天股价突然从下轨线附近站上5日均线，那么这就是最佳的买入时机。</strong></p><p>​                <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304152813202.png" alt="image-20210304152813202"></p><p>​                <strong>所以只有在买入和卖出时我们才主要依据KDJ，而在持仓途中我们要用MACD来确定KDJ的准确性。</strong></p><p>​            <strong>2.当股价从下方靠近中轨线时，如果股价一举突破了中轨线并在上方获得中轨线支撑和站上5日均线，这时我们要看的就是MACD了。当MACD形成了金叉的买入信号，就是很好的买入机会。</strong></p><p>​                <img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210304153051633.png" alt="image-20210304153051633"></p><p>​            <strong>3.当股价一直运行在上升轨道，随后股价开始跌破中轨线和5日线时，KDJ形成了死叉的卖出信号，那么就要注意进行相应操作了，需要卖出获利。</strong></p><p>​        大量实操表明，BOLL参数设置为26的日线布林线比设置为20的日线布林线更能准确反映股价的运行情况。通常来说，BOLL参数20的轨道更大更开阔，参数为26的布林线更灵敏，更高效。特别注意！此处指的都是日线布林线！</p><h2 id="四、多空布林线BBIBOLL"><a href="#四、多空布林线BBIBOLL" class="headerlink" title="四、多空布林线BBIBOLL"></a>四、多空布林线BBIBOLL</h2><p>​                它是由多空线指标与普通布林线指标组合而成的。BBI和BOLL单独使用的范围太小，而BBIBOLL系统较为完美地结合了二者的优点，同时还具备对未来方向的判断。但中轨线就是BBIBOLL中的“BBI”，也就是多空线，它最大的作用就在于判断走势的时候，根据多空力量的强弱做出取舍判断。</p><ol><li><p>当K线大部分集中在中轨线上方，且中轨线向上运行时，可判定当前多头强势，应该持有或逢低买入股票。</p></li><li><p>当K线大部分集中在中轨线下方，且中轨线向下运行时，可判定当前空头强势，应该逢高卖出股票，保持空仓或者少量持股观望。</p><p>​        <strong>BBIBOLL精准打击战法</strong>:</p><ol><li>法则一： 在多空布林线系统中，行情缩口变张口，中轨线上方有阳线，行情涨。    反之，当行情缩口变张口，中轨线下方有阴线，则行情要跌。</li><li>​    法则二： 行情上涨时，K线实体一旦突破甚至完全站在上轨线上方，行情极大概率会回调，尤其是第二天会有调整，基本都是收阴，可能开盘价就是最高价。反之，行情下跌时，K线实体一旦跌破甚至完全站在下轨线下方，行情极大概率会反弹，第二天往往都是放阳，所以开盘价买入都是较低价。</li></ol></li></ol><h1 id="指标4-选股也需要心理学-PSY"><a href="#指标4-选股也需要心理学-PSY" class="headerlink" title="指标4: 选股也需要心理学(PSY)"></a>指标4: 选股也需要心理学(PSY)</h1>]]></content>
      
      
      <categories>
          
          <category> 财富自由 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 股票实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维图形生成算法</title>
      <link href="2021/04/22/%E4%BA%8C%E7%BB%B4%E5%9B%BE%E5%BD%A2%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/"/>
      <url>2021/04/22/%E4%BA%8C%E7%BB%B4%E5%9B%BE%E5%BD%A2%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="直线图形"><a href="#直线图形" class="headerlink" title="直线图形"></a>直线图形</h1><p>&emsp;&emsp;绘制直线段一般需要进行栅格化（又叫光栅化）处理：将几何数据经过一系列变换后转换为像素呈现在显示设备上。</p><h2 id="数值微分算法（DDA）"><a href="#数值微分算法（DDA）" class="headerlink" title="数值微分算法（DDA）"></a>数值微分算法（DDA）</h2><p>&emsp;&emsp;数值微分算法本质为用数值方法解微分方程，即通过同时对x和y个增加一个小增量，计算下一步的x，y的值。</p><h3 id="DDA的推导公式"><a href="#DDA的推导公式" class="headerlink" title="DDA的推导公式"></a>DDA的推导公式</h3><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210412205313703.png" alt="image-20210412205313703" style="zoom: 67%;" /><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210412205632060.png" alt="image-20210412205632060" style="zoom: 67%;" /><h3 id="DDA画线程序设计"><a href="#DDA画线程序设计" class="headerlink" title="DDA画线程序设计"></a>DDA画线程序设计</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Line_DDA</span> <span class="params">(CDC *pDC,<span class="keyword">int</span> xs,<span class="keyword">int</span> ys,<span class="keyword">int</span> xe,<span class="keyword">int</span> ye, COLORREF color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t; <span class="keyword">float</span> x,y,k=(<span class="keyword">float</span>)(ye-ys)/(xe-xs);</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">fbs</span>(k) &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xe&lt;xs)&#123;</span><br><span class="line">          t=xe,xe=xs,xs=t,t=ye,ye=ys,ys=t;</span><br><span class="line">      &#125;    </span><br><span class="line">    y=ys;    </span><br><span class="line">    <span class="keyword">for</span>(x=xs;x&lt;=xe;x++)</span><br><span class="line">        pDC-&gt;<span class="built_in">SetPixel</span>(x,y,color), y=y+k;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ye&lt;ys)&#123;</span><br><span class="line">            t=xe,xe=xs,xs=t,t=ye,ye=ys,ys=t;</span><br><span class="line">        &#125;</span><br><span class="line">        x=xs;    </span><br><span class="line">        <span class="keyword">for</span>(y=ys;y&lt;=ye;y++)</span><br><span class="line">        pDC-&gt;<span class="built_in">SetPixel</span>(x,y,color),x=x+<span class="number">1</span>/k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制线型的程序设计思路"><a href="#控制线型的程序设计思路" class="headerlink" title="控制线型的程序设计思路"></a>控制线型的程序设计思路</h3><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210412211134082.png" alt="image-20210412211134082" style="zoom:67%;" /><h3 id="反走样处理"><a href="#反走样处理" class="headerlink" title="反走样处理"></a>反走样处理</h3><p>&emsp;&emsp;用离散量表示连续量引起的图形失真，叫走样；减少走样现象的技术和方法称为反走样。</p><p>&emsp;&emsp;反走样处理：</p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210412211337516.png" alt="image-20210412211337516" style="zoom:67%;" /><h2 id="中点画线法"><a href="#中点画线法" class="headerlink" title="中点画线法"></a>中点画线法</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210412211540932.png" alt="image-20210412211540932" style="zoom:67%;" /><h3 id="中点法的递推公式"><a href="#中点法的递推公式" class="headerlink" title="中点法的递推公式"></a>中点法的递推公式</h3><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210412211955089.png" alt="image-20210412211955089" style="zoom:67%;" /><h3 id="任意方向上的中点法"><a href="#任意方向上的中点法" class="headerlink" title="任意方向上的中点法"></a>任意方向上的中点法</h3><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210412212402604.png" alt="image-20210412212402604" style="zoom: 67%;" /><h3 id="中点法程序设计"><a href="#中点法程序设计" class="headerlink" title="中点法程序设计"></a>中点法程序设计</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="直线段的线宽处理"><a href="#直线段的线宽处理" class="headerlink" title="直线段的线宽处理"></a>直线段的线宽处理</h3><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210412213303525.png" alt="image-20210412213303525" style="zoom: 67%;" /><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210412213324815.png" alt="image-20210412213324815" style="zoom: 67%;" /></p><p> &emsp;&emsp;1) <strong>垂直线刷子</strong>：适用于直线斜率在[-1, 1]之间。把线刷子放置成垂直方向，刷子中点对准直线 一端点，然后让刷子中心往直线的另一端移动，即可“刷出”具有一定宽度的线段。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CDC *pDC=<span class="built_in">GetDC</span>();   </span><br><span class="line">dx=xe-xs; dy=ye-ys;   <span class="comment">//( xs,ys),(xe,ye)为直线段的两个端点坐标 </span></span><br><span class="line">e=-dx; y=ys; dxx=dx+dx; dyy=dy+dy; </span><br><span class="line"><span class="keyword">for</span>(x=xs;x&lt;=xe;x++)&#123; </span><br><span class="line">    pDC-&gt;<span class="built_in">SetPixel</span>(x,y,<span class="built_in">RGB</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));   </span><br><span class="line">    pDC-&gt;<span class="built_in">SetPixel</span>(x<span class="number">-1</span>,y,<span class="built_in">RGB</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));      </span><br><span class="line">    pDC-&gt;<span class="built_in">SetPixel</span>(x+<span class="number">1</span>,y,<span class="built_in">RGB</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));   </span><br><span class="line">    <span class="keyword">if</span>(e&gt;=<span class="number">0</span>)    </span><br><span class="line">        y=y++, e=e-dxx;   e=e+dyy; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;2) <strong>水平线刷子</strong>：适用于直线斜率不在[1, 1]之间。把线刷子放置成水平方向，刷子中点对准直 线一端点并往直线的另一端移动，可“刷出”具有一定宽度的线。</p><p>&emsp;&emsp;3)<strong>方形刷子</strong>：把正方形（边宽为指定线宽）的中心沿直线做平行移动，即可获得具有线宽的线条。</p><h1 id="圆与椭圆图形"><a href="#圆与椭圆图形" class="headerlink" title="圆与椭圆图形"></a>圆与椭圆图形</h1><h2 id="简单方程产生园弧"><a href="#简单方程产生园弧" class="headerlink" title="简单方程产生园弧"></a>简单方程产生园弧</h2><p>&emsp;&emsp;<img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210412221941689.png" alt="image-20210412221941689" style="zoom:80%;" /></p><h3 id="绘制圆函数的程序设计"><a href="#绘制圆函数的程序设计" class="headerlink" title="绘制圆函数的程序设计"></a>绘制圆函数的程序设计</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Arc_Para</span><span class="params">(CDC *pDC,<span class="keyword">int</span> xc,<span class="keyword">int</span> yc,<span class="keyword">int</span> r,COLORREF color)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> x,y;<span class="keyword">float</span> d=<span class="number">1</span>/(<span class="number">2</span>*<span class="number">3.14</span>*r);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> t=<span class="number">0</span>;t&lt;<span class="number">6.283</span>;t=t+d)</span><br><span class="line">&#123;</span><br><span class="line">        x=x0+r*<span class="built_in">cos</span>(t);</span><br><span class="line">    y=y0+r*<span class="built_in">sin</span>(t);</span><br><span class="line">        pDC-&gt;<span class="built_in">SetPixel</span> (x,y,color);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中点画圆算法"><a href="#中点画圆算法" class="headerlink" title="中点画圆算法"></a>中点画圆算法</h2><h3 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h3><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210412223659076.png" alt="image-20210412223659076" style="zoom: 80%;" /><h3 id="程序设计："><a href="#程序设计：" class="headerlink" title="程序设计："></a>程序设计：</h3><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210412222710874.png" alt="image-20210412222710874" style="zoom:67%;" /><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Circle_DDA</span><span class="params">(CDC *pDC,<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> r,COLORREF color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  x=<span class="number">0</span>, y=r, d=<span class="number">1</span>-r;  </span><br><span class="line"><span class="keyword">while</span>( y&gt;=x )&#123;       </span><br><span class="line">    pDC-&gt;<span class="built_in">SetPixel</span> (x+x0,y+y0,color);</span><br><span class="line">        pDC-&gt;<span class="built_in">SetPixel</span> (-x+x0,y+y0,color);</span><br><span class="line">        pDC-&gt;<span class="built_in">SetPixel</span> (-x+x0,-y+y0,color); </span><br><span class="line">        pDC-&gt;<span class="built_in">SetPixel</span> (x+x0,-y+y0,color);</span><br><span class="line">        pDC-&gt;<span class="built_in">SetPixel</span> (y+x0,x+y0,color);        </span><br><span class="line">        pDC-&gt;<span class="built_in">SetPixel</span> (-y+x0,x+y0,color);</span><br><span class="line">        pDC-&gt;<span class="built_in">SetPixel</span> (-y+x0,-x+y0,color);      </span><br><span class="line">        pDC-&gt;<span class="built_in">SetPixel</span> (y+x0,-x+y0,color);</span><br><span class="line">        <span class="keyword">if</span>(d&lt;<span class="number">0</span>)   </span><br><span class="line">            d=d+<span class="number">2</span>*x+<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            d=d+<span class="number">2</span>*(x-y)+<span class="number">5</span>, y--;</span><br><span class="line">        x++;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线宽处理"><a href="#线宽处理" class="headerlink" title="线宽处理"></a>线宽处理</h3><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/image-20210412224025985.png" alt="image-20210412224025985"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Circle_W</span> <span class="params">(CDC *pDC,<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> r,COLORREF color, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> x,y; <span class="keyword">float</span> d=<span class="number">1</span>/(<span class="number">2</span>*r*<span class="number">3.14</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> t=<span class="number">0</span>;t&lt;<span class="number">6.3</span>;t=t+d)&#123;</span><br><span class="line">        x=x0+r*<span class="built_in">cos</span>(t);</span><br><span class="line">y=y0+r*<span class="built_in">sin</span>(t);</span><br><span class="line"><span class="keyword">float</span> dt=<span class="number">1.0</span>/(<span class="number">3.14</span>*w);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> t=<span class="number">0</span>;t&lt;<span class="number">6.3</span>;t=t+dt)&#123;</span><br><span class="line">            xx=x+w/<span class="number">2</span>*<span class="built_in">cos</span>(t);</span><br><span class="line">            yy=y+w/<span class="number">2</span>*<span class="built_in">cos</span>(t);</span><br><span class="line">            pDC-&gt;<span class="built_in">SetPixel</span>(xx,yy,color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维图形生成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树遍历（递归，非递归）和构造</title>
      <link href="2021/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
      <url>2021/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%8E%E6%9E%84%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树遍历和构造"><a href="#二叉树遍历和构造" class="headerlink" title="二叉树遍历和构造"></a>二叉树遍历和构造</h1><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>&emsp;&emsp;二叉树遍历其实很简单，三种遍历都是一样的，只不过顺序先后不一样罢了。</p><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>&emsp;&emsp;访问根结点，先序遍历左子树，先序遍历右子树</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BitTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( T != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);</span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>&emsp;&emsp;中序遍历左子树，访问根结点，中序遍历右子树</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BitTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">visit</span>(T);</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>  后序遍历左子树，后序遍历右子树，访问根结点</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BitTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( T != <span class="literal">nullptr</span> )&#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">visit</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;时间复杂度都为O（n），在递归遍历中，递归工作栈的栈深恰好为树的深度，在最坏情况下，二叉树是有n个结点且深度为 n 的单支树，遍历算法的空间复杂度为O（n）。</p><h3 id="利用非递归方式遍历二叉树"><a href="#利用非递归方式遍历二叉树" class="headerlink" title="利用非递归方式遍历二叉树"></a>利用非递归方式遍历二叉树</h3><p>&emsp;&emsp;借助栈，可以将二叉树的递归遍历转换为非递归算法。以中序遍历为例，给出中序遍历非递归算法。先扫描（并非访问）根结点的所有左结点并将它们一一进栈，然后出栈一个结点*p，访问它。然后继续扫描该结点的右孩子结点，将其进栈，在扫描该孩子结点的所有左结点并一一进栈，如此继续，直到栈空。</p><p>&emsp;&emsp;<strong>中序遍历</strong>的非递归算法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderWithoutRecursion</span><span class="params">(BitTree T)</span></span>&#123;</span><br><span class="line">    Stack&lt;BitTree&gt; S;           <span class="comment">//辅助栈</span></span><br><span class="line">    BitTree p = T;<span class="comment">//遍历指针</span></span><br><span class="line">    <span class="keyword">while</span>( p || !<span class="built_in">IsEmpty</span>(S) )&#123;<span class="comment">//栈不为空或p不为空时</span></span><br><span class="line">        <span class="keyword">if</span>( p )&#123;</span><br><span class="line">            S.<span class="built_in">push</span>(p);<span class="comment">//根指针进栈</span></span><br><span class="line">            p = p-&gt;lchild;<span class="comment">//遍历左子树</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            S.<span class="built_in">pop</span>(p);<span class="comment">//根指针退栈</span></span><br><span class="line">            <span class="built_in">visit</span>(p);<span class="comment">//cout &lt;&lt; p-&gt;data;</span></span><br><span class="line">            p = p-&gt;rchild;      <span class="comment">//向右子树走</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>前序遍历</strong>的非递归算法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderWithoutRecursion</span><span class="params">(BitTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">BTNode* p = T;</span><br><span class="line">stack&lt;BitNode*&gt; s;</span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>() || p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">visit</span>(p);<span class="comment">// cout &lt;&lt; p-&gt;data;</span></span><br><span class="line">s.<span class="built_in">push</span>(p);</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p = s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>后序遍历</strong>的非递归算法：后序遍历的难点在于：需要判断上次访问的节点是位于左子树，还是右子树。若是位于左子树，则需跳过根节点，先进入右子树，再回头访问根节点；若是位于右子树，则直接访问根节点。直接看代码，代码中有详细的注释。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderWithoutRecursion</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">stack&lt;BTNode*&gt; s;</span><br><span class="line"><span class="comment">//pCur:当前访问节点，pLastVisit:上次访问节点</span></span><br><span class="line">BTNode* pCur, *pLastVisit;</span><br><span class="line"><span class="comment">//pCur = root;</span></span><br><span class="line">pCur = root;</span><br><span class="line">pLastVisit = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//先把pCur移动到左子树最下边</span></span><br><span class="line"><span class="keyword">while</span> (pCur)</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">push</span>(pCur);</span><br><span class="line">pCur = pCur-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//走到这里，pCur都是空，并已经遍历到左子树底端(看成扩充二叉树，则空，亦是某棵树的左孩子)</span></span><br><span class="line">pCur = s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//一个根节点被访问的前提是：无右子树或右子树已被访问过</span></span><br><span class="line"><span class="keyword">if</span> (pCur-&gt;rchild == <span class="literal">NULL</span> || pCur-&gt;rchild == pLastVisit)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; pCur-&gt;data;</span><br><span class="line"><span class="comment">//修改最近被访问的节点</span></span><br><span class="line">pLastVisit = pCur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这里的else语句可换成带条件的else if:</span></span><br><span class="line"><span class="comment">else if (pCur-&gt;lchild == pLastVisit)//若左子树刚被访问过，则需先进入右子树(根节点需再次入栈)</span></span><br><span class="line"><span class="comment">因为：上面的条件没通过就一定是下面的条件满足。仔细想想！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//根节点再次入栈</span></span><br><span class="line">s.<span class="built_in">push</span>(pCur);</span><br><span class="line"><span class="comment">//进入右子树，且可肯定右子树一定不为空</span></span><br><span class="line">pCur = pCur-&gt;rchild;</span><br><span class="line"><span class="keyword">while</span> (pCur)</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">push</span>(pCur);</span><br><span class="line">pCur = pCur-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>层次遍历</strong></p><p>&emsp;&emsp;层次遍历需要借助队列。先将二叉树根结点入队，然后初岁，访问该结点，若它有左子树，则将左子树根节点入队；若它有右子树，则将右子树根结点入队。然后出队，对出队结点访问，如此反复，直到队列为空。</p><p><img src="https://xiuxin-1304803037.cos.ap-shanghai.myqcloud.com/%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.jpg"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BitTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( T == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;BitNode*&gt; q;<span class="comment">//辅助队列</span></span><br><span class="line">    q.<span class="built_in">push</span>(T);<span class="comment">//将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;<span class="comment">//队列不为空时</span></span><br><span class="line">        <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            BitNode* cur = Q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();<span class="comment">//队头元素出队</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(p-&gt;lchild);<span class="comment">//左子树不为空时，左子树入队</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(p-&gt;rchild);<span class="comment">//右子树不为空时，右子树入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><p>&emsp;&emsp;由二叉树的先序和中序序列可以唯一确定一棵二叉树，同样后序和中序序列也可以唯一确定一棵二叉树，但先序和后序不能确定一棵二叉树。</p><h3 id="先序和中序序列构造一棵二叉树"><a href="#先序和中序序列构造一棵二叉树" class="headerlink" title="先序和中序序列构造一棵二叉树"></a><strong>先序和中序序列构造一棵二叉树</strong></h3><p>&emsp;&emsp;思路：我们知道先序序列的第一个值其实就是根节点的值，这样我们就可以在中序序列中找到对应的根节点，那么根节点左边的数就全为左子树的结点，根节点右边的数就全为右子树的结点。根据这个想法，再递归的进行构造，见代码。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;  <span class="comment">//借助哈希表，让我们快速的找到分割点，不用每次都去循环一遍</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">myBuildTree</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> preorder_left, <span class="keyword">int</span> preorder_right, <span class="keyword">int</span> inorder_left, <span class="keyword">int</span> inorder_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">        <span class="keyword">int</span> preorder_root = preorder_left;</span><br><span class="line">        <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">        <span class="keyword">int</span> inorder_root = index[preorder[preorder_root]];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先把根节点建立出来</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preorder_root]);</span><br><span class="line">        <span class="comment">// 得到左子树中的节点数目</span></span><br><span class="line">        <span class="keyword">int</span> size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        <span class="comment">// 递归地构造左子树，并连接到根节点</span></span><br><span class="line">        <span class="comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span></span><br><span class="line">        root-&gt;left = <span class="built_in">myBuildTree</span>(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归地构造右子树，并连接到根节点</span></span><br><span class="line">        <span class="comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span></span><br><span class="line">        root-&gt;right = <span class="built_in">myBuildTree</span>(preorder, inorder, preorder_left + size_left_subtree + <span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 构造哈希映射，帮助我们快速定位根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">myBuildTree</span>(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后序和中序序列构造一棵二叉树"><a href="#后序和中序序列构造一棵二叉树" class="headerlink" title="后序和中序序列构造一棵二叉树"></a><strong>后序和中序序列构造一棵二叉树</strong></h3><p>&emsp;&emsp;思路：我们知道后序序列的最后一个值其实就是根节点的值，这样我们就可以在中序序列中找到对应的根节点，那么根节点左边的数就全为左子树的结点，根节点右边的数就全为右子树的结点。根据这个想法，再递归的进行构造，见代码。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; index; <span class="comment">//借助哈希表，让我们快速的找到分割点，不用每次都去循环一遍</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">myBuildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; postorder,vector&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> postorder_left,<span class="keyword">int</span> postorder_right,<span class="keyword">int</span> inorder_left,<span class="keyword">int</span> inorder_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder_left &gt; postorder_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后序遍历的最后一个节点其实就是根节点</span></span><br><span class="line">        <span class="keyword">int</span> postorder_root = postorder_right;</span><br><span class="line">        <span class="comment">//在中序遍历中定位根节点</span></span><br><span class="line">        <span class="keyword">int</span> inorder_root = index[postorder[postorder_root]];</span><br><span class="line">        <span class="comment">//先建立根节点</span></span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[postorder_root]);</span><br><span class="line">        <span class="comment">//得到左子树节点数量</span></span><br><span class="line">        <span class="keyword">int</span> size_left_subtree=inorder_root-inorder_left;</span><br><span class="line">        <span class="comment">//注意区间边界范围 +1，-1 一定要注意判别好</span></span><br><span class="line">        <span class="comment">//递归构造左右子树</span></span><br><span class="line">        root-&gt;left=<span class="built_in">myBuildTree</span>(postorder,inorder,postorder_left,postorder_left+size_left_subtree<span class="number">-1</span>,inorder_left,inorder_root<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=<span class="built_in">myBuildTree</span>(postorder,inorder,postorder_left+size_left_subtree,postorder_root<span class="number">-1</span>,inorder_root+<span class="number">1</span>,inorder_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=postorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//借助哈希表，让我们快速的找到分割点，不用每次都去循环一遍</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            index[inorder[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">myBuildTree</span>(postorder,inorder,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4C++ APawn类的创建</title>
      <link href="2020/11/06/UE4C++%20APawn%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>2020/11/06/UE4C++%20APawn%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="创建一个APawn类，添加根组件和StaticMeshComponennt，并将StaticMeshComponent附着到根组件上，并添加相机-获得Pawn的控制权">创建一个APawn类，添加根组件和StaticMeshComponennt，并将StaticMeshComponent附着到根组件上，并添加相机    获得Pawn的控制权</h2><p>MyPawn.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GameFramework/Pawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Components/StaticMeshComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyPawn.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIRSTDEMO_API</span> <span class="title">AMyPawn</span> :</span> <span class="keyword">public</span> APawn</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Sets default values for this pawn&#x27;s properties</span></span><br><span class="line"><span class="built_in">AMyPawn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Tick</span><span class="params">(<span class="keyword">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called to bind functionality to input</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(class UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UStaticMeshComponent* MyStaticMesh;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UCameraComponent* MyCamera;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MyPawn.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyPawn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AMyPawn::<span class="built_in">AMyPawn</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">RootComponent=CreateDefaultSubobject&lt;USceneComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;RootComponent&quot;</span>));</span><br><span class="line"></span><br><span class="line">MyStaticMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;MyStaticMesh&quot;</span>));</span><br><span class="line">MyStaticMesh-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetRootComponent</span>());</span><br><span class="line"></span><br><span class="line">MyCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;MyCamera&quot;</span>));</span><br><span class="line">MyCamera-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetRootComponent</span>());</span><br><span class="line"></span><br><span class="line">MyCamera-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">-300.f</span>, <span class="number">0.f</span>, <span class="number">300.f</span>));</span><br><span class="line">MyCamera-&gt;<span class="built_in">SetRelativeRotation</span>(<span class="built_in">FRotator</span>(<span class="number">-45.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>));</span><br><span class="line"></span><br><span class="line">AutoPossessPlayer = EAutoReceiveInput::Player0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::Tick</span><span class="params">(<span class="keyword">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called to bind functionality to input</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201104123341666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Mjg1NTUx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> UE4C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE4C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4C++ 设置模型与材质的默认值</title>
      <link href="2020/11/05/UE4%20C++%20%E8%AE%BE%E7%BD%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9D%90%E8%B4%A8%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
      <url>2020/11/05/UE4%20C++%20%E8%AE%BE%E7%BD%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9D%90%E8%B4%A8%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1>UE4 C++ 设置模型与材质的默认值</h1><p>MyPawn.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GameFramework/Pawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Components/StaticMeshComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Components/InputComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GameFramework/SpringArmComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyPawn.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIRSTDEMO_API</span> <span class="title">AMyPawn</span> :</span> <span class="keyword">public</span> APawn</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Sets default values for this pawn&#x27;s properties</span></span><br><span class="line"><span class="built_in">AMyPawn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Tick</span><span class="params">(<span class="keyword">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called to bind functionality to input</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(class UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UStaticMeshComponent</span>* <span class="title">MyStaticMesh</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UCameraComponent</span>* <span class="title">MyCamera</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USpringArmComponent</span>* <span class="title">MySpringArm</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="keyword">float</span> MaxSpeed;</span><br><span class="line"></span><br><span class="line"><span class="comment">//强制要求</span></span><br><span class="line"><span class="function">FORCEINLINE UStaticMeshComponent* <span class="title">GetStaticMeshComponent</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> MyStaticMesh; &#125;</span><br><span class="line"><span class="function">FORCEINLINE USpringArmComponent* <span class="title">GetSpringArmComponent</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> MySpringArm; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveForward</span><span class="params">(<span class="keyword">float</span> Value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveRight</span><span class="params">(<span class="keyword">float</span> Value)</span></span>;</span><br><span class="line">FVector Velocity;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MyPawn.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyPawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UObject/ConstructorHelpers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AMyPawn::<span class="built_in">AMyPawn</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">RootComponent=CreateDefaultSubobject&lt;USceneComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;RootComponent&quot;</span>));</span><br><span class="line"></span><br><span class="line">MyStaticMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;MyStaticMesh&quot;</span>));</span><br><span class="line">MyStaticMesh-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetRootComponent</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载staticmesh 和 material</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; <span class="title">StaticMeshAsset</span><span class="params">(TEXT(<span class="string">&quot;StaticMesh&#x27;/Engine/EditorMeshes/ArcadeEditorSphere.ArcadeEditorSphere&#x27;&quot;</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ConstructorHelpers::FObjectFinder&lt;UMaterialInterface&gt; <span class="title">MaterialAsset</span><span class="params">(TEXT(<span class="string">&quot;Material&#x27;/Engine/MapTemplates/Materials/BasicAsset01.BasicAsset01&#x27;&quot;</span>))</span></span>;</span><br><span class="line"><span class="comment">//判断路径是否正确</span></span><br><span class="line"><span class="keyword">if</span> (StaticMeshAsset.<span class="built_in">Succeeded</span>() &amp;&amp; MaterialAsset.<span class="built_in">Succeeded</span>())</span><br><span class="line">&#123;</span><br><span class="line">MyStaticMesh-&gt;<span class="built_in">SetStaticMesh</span>(StaticMeshAsset.Object);</span><br><span class="line">MyStaticMesh-&gt;<span class="built_in">SetMaterial</span>(<span class="number">0</span>, MaterialAsset.Object);</span><br><span class="line">MyStaticMesh-&gt;<span class="built_in">SetWorldScale3D</span>(<span class="built_in">FVector</span>(<span class="number">0.5f</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MySpringArm = CreateDefaultSubobject&lt;USpringArmComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;MySpringArm&quot;</span>));</span><br><span class="line">MySpringArm-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetStaticMeshComponent</span>());</span><br><span class="line">MySpringArm-&gt;RelativeRotation = <span class="built_in">FRotator</span>(<span class="number">-45.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>); <span class="comment">//设置Springarm的相对旋转</span></span><br><span class="line">MySpringArm-&gt;TargetArmLength = <span class="number">400.f</span>;    <span class="comment">//设置Springarm的长度</span></span><br><span class="line">MySpringArm-&gt;bEnableCameraLag = <span class="literal">true</span>;    <span class="comment">//设置Springarm是否平滑</span></span><br><span class="line">MySpringArm-&gt;CameraLagSpeed = <span class="number">3.f</span>;             <span class="comment">//设置平滑速度</span></span><br><span class="line"></span><br><span class="line">MyCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;MyCamera&quot;</span>));</span><br><span class="line">MyCamera-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetSpringArmComponent</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*MyCamera-&gt;SetRelativeLocation(FVector(-300.f, 0.f, 300.f));</span></span><br><span class="line"><span class="comment">MyCamera-&gt;SetRelativeRotation(FRotator(-45.f, 0.f, 0.f));*/</span></span><br><span class="line"></span><br><span class="line">AutoPossessPlayer = EAutoReceiveInput::Player0;</span><br><span class="line"></span><br><span class="line">MaxSpeed = <span class="number">100.f</span>;</span><br><span class="line">Velocity = FVector::ZeroVector;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::Tick</span><span class="params">(<span class="keyword">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line"><span class="built_in">AddActorLocalOffset</span>(Velocity * DeltaTime, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called to bind functionality to input</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MoveForward&quot;</span>), <span class="keyword">this</span>, &amp;AMyPawn::MoveForward);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MoveRight&quot;</span>), <span class="keyword">this</span>, &amp;AMyPawn::MoveRight);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::MoveForward</span><span class="params">(<span class="keyword">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Velocity.X = FMath::<span class="built_in">Clamp</span>(Value, <span class="number">-1.f</span>, <span class="number">1.f</span>) * MaxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::MoveRight</span><span class="params">(<span class="keyword">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Velocity.Y = FMath::<span class="built_in">Clamp</span>(Value, <span class="number">-1.f</span>, <span class="number">1.f</span>) * MaxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201105130523537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Mjg1NTUx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> UE4C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE4C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4C++ SpringArm组件的创建</title>
      <link href="2020/11/05/UE4C++%20SpringArm%E7%BB%84%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>2020/11/05/UE4C++%20SpringArm%E7%BB%84%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="UE4C-SpringArm组件的创建">UE4C++ SpringArm组件的创建</h2><p>MyPawn.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GameFramework/Pawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Components/StaticMeshComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Components/InputComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GameFramework/SpringArmComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyPawn.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIRSTDEMO_API</span> <span class="title">AMyPawn</span> :</span> <span class="keyword">public</span> APawn</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Sets default values for this pawn&#x27;s properties</span></span><br><span class="line"><span class="built_in">AMyPawn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Tick</span><span class="params">(<span class="keyword">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called to bind functionality to input</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(class UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UStaticMeshComponent</span>* <span class="title">MyStaticMesh</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UCameraComponent</span>* <span class="title">MyCamera</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USpringArmComponent</span>* <span class="title">MySpringArm</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="keyword">float</span> MaxSpeed;</span><br><span class="line"></span><br><span class="line"><span class="comment">//强制要求</span></span><br><span class="line"><span class="function">FORCEINLINE UStaticMeshComponent* <span class="title">GetStaticMeshComponent</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> MyStaticMesh; &#125;</span><br><span class="line"><span class="function">FORCEINLINE USpringArmComponent* <span class="title">GetSpringArmComponent</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> MySpringArm; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveForward</span><span class="params">(<span class="keyword">float</span> Value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveRight</span><span class="params">(<span class="keyword">float</span> Value)</span></span>;</span><br><span class="line">FVector Velocity;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MyPawn.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyPawn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AMyPawn::<span class="built_in">AMyPawn</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">RootComponent=CreateDefaultSubobject&lt;USceneComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;RootComponent&quot;</span>));</span><br><span class="line"></span><br><span class="line">MyStaticMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;MyStaticMesh&quot;</span>));</span><br><span class="line">MyStaticMesh-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetRootComponent</span>());</span><br><span class="line"></span><br><span class="line">MySpringArm = CreateDefaultSubobject&lt;USpringArmComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;MySpringArm&quot;</span>));</span><br><span class="line">MySpringArm-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetStaticMeshComponent</span>());</span><br><span class="line">MySpringArm-&gt;RelativeRotation = <span class="built_in">FRotator</span>(<span class="number">-45.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>); <span class="comment">//设置Springarm的相对旋转</span></span><br><span class="line">MySpringArm-&gt;TargetArmLength = <span class="number">400.f</span>;    <span class="comment">//设置Springarm的长度</span></span><br><span class="line">MySpringArm-&gt;bEnableCameraLag = <span class="literal">true</span>;    <span class="comment">//设置Springarm是否平滑</span></span><br><span class="line">MySpringArm-&gt;CameraLagSpeed = <span class="number">3.f</span>;             <span class="comment">//设置平滑速度</span></span><br><span class="line"></span><br><span class="line">MyCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;MyCamera&quot;</span>));</span><br><span class="line">MyCamera-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetSpringArmComponent</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*MyCamera-&gt;SetRelativeLocation(FVector(-300.f, 0.f, 300.f));</span></span><br><span class="line"><span class="comment">MyCamera-&gt;SetRelativeRotation(FRotator(-45.f, 0.f, 0.f));*/</span></span><br><span class="line"></span><br><span class="line">AutoPossessPlayer = EAutoReceiveInput::Player0;</span><br><span class="line"></span><br><span class="line">MaxSpeed = <span class="number">100.f</span>;</span><br><span class="line">Velocity = FVector::ZeroVector;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::Tick</span><span class="params">(<span class="keyword">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line"><span class="built_in">AddActorLocalOffset</span>(Velocity * DeltaTime, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called to bind functionality to input</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MoveForward&quot;</span>), <span class="keyword">this</span>, &amp;AMyPawn::MoveForward);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MoveRight&quot;</span>), <span class="keyword">this</span>, &amp;AMyPawn::MoveRight);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::MoveForward</span><span class="params">(<span class="keyword">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Velocity.X = FMath::<span class="built_in">Clamp</span>(Value, <span class="number">-1.f</span>, <span class="number">1.f</span>) * MaxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::MoveRight</span><span class="params">(<span class="keyword">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Velocity.Y = FMath::<span class="built_in">Clamp</span>(Value, <span class="number">-1.f</span>, <span class="number">1.f</span>) * MaxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201105124424772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Mjg1NTUx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> UE4C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE4C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4C++ APawn类，添加轴映射，使能够控制APawn移动</title>
      <link href="2020/11/04/UE4C++%20APawn%E7%B1%BB%EF%BC%8C%E6%B7%BB%E5%8A%A0%E8%BD%B4%E6%98%A0%E5%B0%84%EF%BC%8C%E4%BD%BF%E8%83%BD%E5%A4%9F%E6%8E%A7%E5%88%B6APawn%E7%A7%BB%E5%8A%A8/"/>
      <url>2020/11/04/UE4C++%20APawn%E7%B1%BB%EF%BC%8C%E6%B7%BB%E5%8A%A0%E8%BD%B4%E6%98%A0%E5%B0%84%EF%BC%8C%E4%BD%BF%E8%83%BD%E5%A4%9F%E6%8E%A7%E5%88%B6APawn%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="APawn类，添加轴映射，使能够控制APawn移动">APawn类，添加轴映射，使能够控制APawn移动</h2><p>MyPawn.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GameFramework/Pawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Components/StaticMeshComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyPawn.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIRSTDEMO_API</span> <span class="title">AMyPawn</span> :</span> <span class="keyword">public</span> APawn</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Sets default values for this pawn&#x27;s properties</span></span><br><span class="line"><span class="built_in">AMyPawn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Tick</span><span class="params">(<span class="keyword">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called to bind functionality to input</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(class UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UStaticMeshComponent* MyStaticMesh;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UCameraComponent* MyCamera;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="keyword">float</span> MaxSpeed;<span class="comment">//添加pawn移动速度参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//添加轴映射函数，MoveForward，MoveRight，Velocity</span></span><br><span class="line"><span class="comment">//设为私有变量，Pawn类里自身进行处理，无需暴露给外部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveForward</span><span class="params">(<span class="keyword">float</span> Value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveRight</span><span class="params">(<span class="keyword">float</span> Value)</span></span>;</span><br><span class="line">FVector Velocity;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MyPawn.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyPawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Components/InputComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AMyPawn::<span class="built_in">AMyPawn</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">RootComponent=CreateDefaultSubobject&lt;USceneComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;RootComponent&quot;</span>));</span><br><span class="line"></span><br><span class="line">MyStaticMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;MyStaticMesh&quot;</span>));</span><br><span class="line">MyStaticMesh-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetRootComponent</span>());</span><br><span class="line"></span><br><span class="line">MyCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;MyCamera&quot;</span>));</span><br><span class="line">MyCamera-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetRootComponent</span>());</span><br><span class="line"></span><br><span class="line">MyCamera-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">-300.f</span>, <span class="number">0.f</span>, <span class="number">300.f</span>));</span><br><span class="line">MyCamera-&gt;<span class="built_in">SetRelativeRotation</span>(<span class="built_in">FRotator</span>(<span class="number">-45.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>));</span><br><span class="line"></span><br><span class="line">AutoPossessPlayer = EAutoReceiveInput::Player0;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">MaxSpeed = <span class="number">100.f</span>;</span><br><span class="line">Velocity = FVector::ZeroVector;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::Tick</span><span class="params">(<span class="keyword">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"><span class="comment">//在tick中添加偏移函数</span></span><br><span class="line"><span class="built_in">AddActorLocalOffset</span>(Velocity * DeltaTime, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called to bind functionality to input</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定玩家输入轴映射，轴映射和函数名要相对应</span></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MoveForward&quot;</span>), <span class="keyword">this</span>, &amp;AMyPawn::MoveForward);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MoveRight&quot;</span>), <span class="keyword">this</span>, &amp;AMyPawn::MoveRight);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::MoveForward</span><span class="params">(<span class="keyword">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//向前的速度，利用Clamp 将value限制在-1,1之间，放置Ue4编辑器中数值过大，产生bug</span></span><br><span class="line">Velocity.X = FMath::<span class="built_in">Clamp</span>(Value, <span class="number">-1.f</span>, <span class="number">1.f</span>) * MaxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn::MoveRight</span><span class="params">(<span class="keyword">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//向右的速度，利用Clamp 将value限制在-1,1之间，放置Ue4编辑器中数值过大，产生bug</span></span><br><span class="line">Velocity.Y = FMath::<span class="built_in">Clamp</span>(Value, <span class="number">-1.f</span>, <span class="number">1.f</span>) * MaxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UE4C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE4C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4C++ AActor类的创建</title>
      <link href="2020/11/04/UE4C++%20AActor%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>2020/11/04/UE4C++%20AActor%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="创建一个带StaticMeshComponent的AActor类">创建一个带StaticMeshComponent的AActor类</h2><p>MyActor.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyActor.generated.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>() <span class="comment">//因为Actor父类就已经是blueprintable ，所以不用在括号里面声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIRSTDEMO_API</span> <span class="title">AMyActor</span> :</span> <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Sets default values for this actor&#x27;s properties</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">AMyActor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义组件 VisibleAnywhere 任何地方可见</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere,Category=<span class="string">&quot;My Actor Components&quot;</span>) <span class="comment">//任何地方都可见</span></span><br><span class="line">UStaticMeshComponent* StaticMesh;  <span class="comment">//组件名为  StaticMesh ,组件名为后面的指针名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//EditInstanceOnly 只有在实例中才能修改</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditInstanceOnly,Category=<span class="string">&quot;My Actor Properties | FVector&quot;</span>)</span><br><span class="line"><span class="comment">//物体初始化transform</span></span><br><span class="line">FVector InitLocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VisibleInstaceOnly 在实例中可见</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleInstanceOnly, Category = <span class="string">&quot;My Actor Properties | FVector&quot;</span>)</span><br><span class="line">FVector PlacedLocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">//EditDefaultsOnly 只能在类默认值中编辑，实例化对象中看不到这个变量存在</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = <span class="string">&quot;My Actor Properties | FVector&quot;</span>)</span><br><span class="line"><span class="keyword">bool</span> bGotoInitLocation; <span class="comment">//ue默认 bool变量前都要加上b</span></span><br><span class="line"><span class="comment">//VisibleDefaultsOnly 默认可见</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleDefaultsOnly, Category = <span class="string">&quot;My Actor Properties | FVector&quot;</span>)</span><br><span class="line">FVector WorldOrigin;</span><br><span class="line"><span class="comment">//EditAnywhere 任何地方（类，实例）都可编辑                        //限制条件：限制UE中输入框中的最小值和最大值，ClampMin实际的对应UIMin，相应的</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;My Actor Properties | FVector&quot;</span>, meta = (ClampMin = <span class="number">-5.f</span>, ClampMax = <span class="number">5.f</span>, UIMin = <span class="number">-5.f</span>, UIMax = <span class="number">5.f</span>))</span><br><span class="line">FVector TickLocationOffset;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="string">&quot;My Actor Properties | FVector&quot;</span>)</span><br><span class="line"><span class="keyword">bool</span> bShouldMove;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditInstanceOnly, Category = <span class="string">&quot;My Actor Properties | Physics&quot;</span>)</span><br><span class="line">FVector InitForce;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditInstanceOnly, Category = <span class="string">&quot;My Actor Properties | Physics&quot;</span>)</span><br><span class="line">FVector InitTorque;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditInstanceOnly, Category = <span class="string">&quot;My Actor Properties | Physics&quot;</span>)</span><br><span class="line"><span class="keyword">bool</span> bAccelChange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="comment">//重写父类的BeginPlay()</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="comment">//event tick ,from parent class override</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Tick</span><span class="params">(<span class="keyword">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MyActor.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyActor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Components/StaticMeshComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AMyActor::<span class="built_in">AMyActor</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line"><span class="comment">//如果不需要eventtick 这个函数的话就可以设为 false，增加程序的性能</span></span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组件初始化</span></span><br><span class="line">    <span class="comment">//创建一个默认的子物体，后面传入的是一个模板，TEXT宏后面是一个ue封装好的一个FString类型   </span></span><br><span class="line"><span class="comment">//模板函数，后面传入的是一个模板</span></span><br><span class="line">StaticMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;MyStaticMesh&quot;</span>));</span><br><span class="line"></span><br><span class="line">InitLocation = <span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">100.0f</span>, <span class="number">200.0f</span>);</span><br><span class="line">PlacedLocation = <span class="built_in">FVector</span>(<span class="number">0.0f</span>);</span><br><span class="line">bGotoInitLocation = <span class="literal">false</span>;</span><br><span class="line">WorldOrigin = <span class="built_in">FVector</span>(<span class="number">0.0f</span>);</span><br><span class="line">TickLocationOffset = <span class="built_in">FVector</span>(<span class="number">1.f</span>);</span><br><span class="line">bShouldMove = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">InitForce = <span class="built_in">FVector</span>(<span class="number">0.f</span>);</span><br><span class="line">InitTorque = <span class="built_in">FVector</span>(<span class="number">0.f</span>);</span><br><span class="line">bAccelChange = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyActor::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//调用父类的beginplay()</span></span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">PlacedLocation = <span class="built_in">GetActorLocation</span>();</span><br><span class="line"><span class="keyword">if</span> (bGotoInitLocation)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SetActorLocation</span>(InitLocation);</span><br><span class="line">&#125;</span><br><span class="line">StaticMesh-&gt;<span class="built_in">AddForce</span>(InitForce,<span class="built_in">TEXT</span>(<span class="string">&quot;NAME_None&quot;</span>),bAccelChange);</span><br><span class="line">StaticMesh-&gt;<span class="built_in">AddTorque</span>(InitTorque, <span class="built_in">TEXT</span>(<span class="string">&quot;NAME_None&quot;</span>), bAccelChange);</span><br><span class="line"></span><br><span class="line"><span class="comment">//FMath::Lerp();</span></span><br><span class="line"><span class="comment">//FMath::FRandRange();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyActor::Tick</span><span class="params">(<span class="keyword">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//调用父类的eventtick()</span></span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"><span class="keyword">if</span> (bShouldMove)</span><br><span class="line">&#123;</span><br><span class="line">FHitResult HitResult;</span><br><span class="line"><span class="built_in">AddActorLocalOffset</span>(TickLocationOffset,<span class="literal">true</span>,&amp;HitResult);</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;X: %.f, Y: %.f, Z: %.f&quot;</span>), HitResult.Location.X, HitResult.Location.Y, HitResult.Location.Z);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201104113419442.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> UE4C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE4C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4C++ Uobject的创建</title>
      <link href="2020/11/04/UE4C++%20Uobject%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>2020/11/04/UE4C++%20Uobject%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>MyObject.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UObject/NoExportTypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyObject.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>(Blueprintable) <span class="comment">//可生成蓝图的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIRSTDEMO_API</span> <span class="title">UMyObject</span> :</span> <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">UMyObject</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadWrite,Category=<span class="string">&quot;My Viriables&quot;</span>)</span><br><span class="line"><span class="keyword">float</span> test;</span><br><span class="line"><span class="comment">//成员函数</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable,Category=<span class="string">&quot;My Functions&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Myfunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MyObject.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyObject.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Logging/LogMacros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Engine/Engine.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UMyObject::<span class="built_in">UMyObject</span>() <span class="comment">//构造函数实现，在构造函数中初始化成员变量的值</span></span><br><span class="line">&#123;</span><br><span class="line">test = <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyObject::Myfunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//日志打印信息</span></span><br><span class="line"><span class="comment">//Log 不能大写，大写的话是另一个枚举参数</span></span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World !&quot;</span>));</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World !&quot;</span>));</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World !&quot;</span>));</span><br><span class="line"><span class="comment">//在屏幕上打印输出信息</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">10.f</span>, FColor::Black, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World !&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201104122636930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Mjg1NTUx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201104122708434.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> UE4C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE4C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可变分区内存动态分配模拟</title>
      <link href="2019/12/06/C++%20%E7%94%9F%E6%88%90%20-10%20%E5%88%B0%2030%20%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%88%E5%8F%AF%E6%89%A9%E5%B1%95%EF%BC%89/"/>
      <url>2019/12/06/C++%20%E7%94%9F%E6%88%90%20-10%20%E5%88%B0%2030%20%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%88%E5%8F%AF%E6%89%A9%E5%B1%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="C-生成-10-到-30-的随机数"><a href="#C-生成-10-到-30-的随机数" class="headerlink" title="C++ 生成 -10 到 30 的随机数"></a>C++ 生成 -10 到 30 的随机数</h1><p><img src="https://img-blog.csdnimg.cn/20201205122035834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Mjg1NTUx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%(<span class="number">41</span>)<span class="number">-10</span>); <span class="comment">//生成 -10 到 30 的随机数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次运行结果：<br><img src="https://img-blog.csdnimg.cn/20201205122117187.png" alt="在这里插入图片描述"><br>第二次运行结果：<br><img src="https://img-blog.csdnimg.cn/20201205122203914.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Loop &amp; FlowControl</title>
      <link href="2019/12/06/Lua%20%20Loop&amp;FlowControl/"/>
      <url>2019/12/06/Lua%20%20Loop&amp;FlowControl/</url>
      
        <content type="html"><![CDATA[<h2 id="Loop-amp-FlowControl"><a href="#Loop-amp-FlowControl" class="headerlink" title="Loop&amp;FlowControl"></a>Loop&amp;FlowControl</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">--三种循环方式：<span class="keyword">while</span> ，<span class="keyword">for</span> ，repeat...until</span><br><span class="line">--循环控制语句：<span class="keyword">break</span> ，<span class="keyword">goto</span>    没有<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--<span class="number">1</span>、<span class="keyword">while</span>循环</span><br><span class="line">--和c，c++的<span class="keyword">while</span>循环没多大区别， 需要注意的是<span class="keyword">do</span>   end</span><br><span class="line">a=<span class="number">10</span></span><br><span class="line"><span class="keyword">while</span>(a&gt;<span class="number">5</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">print</span>(a)</span><br><span class="line">a=a-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">--<span class="number">2</span>、<span class="keyword">for</span>循环</span><br><span class="line">--<span class="number">2.1</span> 数值<span class="keyword">for</span>循环</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span>  <span class="keyword">do</span>  --表示的是从<span class="number">1</span>循环到<span class="number">10</span></span><br><span class="line"><span class="keyword">print</span>(i)</span><br><span class="line">    end</span><br><span class="line">--<span class="number">2.2</span> 泛型<span class="keyword">for</span>循环   泛型 <span class="keyword">for</span> 循环通过一个迭代器函数来遍历所有值，类似 java中的 <span class="keyword">foreach</span> 语句。</span><br><span class="line">a=&#123;<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i,v in ipairs(a) <span class="keyword">do</span>  --ipairs是Lua中的迭代器，用于迭代数组，相当于stl中的迭代器</span><br><span class="line">   <span class="keyword">print</span>(i,v)</span><br><span class="line">end</span><br><span class="line">--<span class="number">3</span>、repeat...until循环</span><br><span class="line">    i=<span class="number">15</span></span><br><span class="line">    repeat</span><br><span class="line">    <span class="keyword">print</span>(i)</span><br><span class="line">i=i-<span class="number">1</span></span><br><span class="line"><span class="keyword">until</span>(i&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">--<span class="keyword">while</span>和repeat循环的区别就相当于c语言当中的<span class="keyword">while</span> <span class="keyword">do</span> 和<span class="keyword">do</span>  <span class="keyword">while</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--循环嵌套 就是多层循环的嵌套使用</span><br><span class="line"></span><br><span class="line">--流程控制：lua中 false和nil为假，其他都为true（包括<span class="number">0</span>）</span><br><span class="line">--<span class="number">1</span>、<span class="keyword">if</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>)</span><br><span class="line">   then</span><br><span class="line">     <span class="keyword">print</span>(true)</span><br><span class="line">end</span><br><span class="line">    --if...else</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>)</span><br><span class="line">   then</span><br><span class="line">     <span class="keyword">print</span>(true)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">print</span>(false)</span><br><span class="line">end</span><br><span class="line">--<span class="keyword">if</span> <span class="keyword">if</span> 嵌套</span><br><span class="line">--<span class="keyword">if</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">else</span> 嵌套</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua变量以及赋值，索引操作</title>
      <link href="2019/12/06/Lua%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E8%B5%8B%E5%80%BC%EF%BC%8C%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/"/>
      <url>2019/12/06/Lua%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E8%B5%8B%E5%80%BC%EF%BC%8C%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Lua变量以及赋值，索引操作"><a href="#Lua变量以及赋值，索引操作" class="headerlink" title="Lua变量以及赋值，索引操作"></a>Lua变量以及赋值，索引操作</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">--变量类型：全局变量，局部变量，表中的域</span><br><span class="line">--[[</span><br><span class="line">--Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 <span class="keyword">local</span> 显式声明为局部变量。</span><br><span class="line">--局部变量的作用域为从声明位置开始到所在语句块结束。</span><br><span class="line">--变量的默认值均为 nil</span><br><span class="line">a=<span class="number">5</span>            --全局变量</span><br><span class="line"><span class="keyword">local</span> b=<span class="number">6</span>      --局部变量</span><br><span class="line"></span><br><span class="line">function joke()</span><br><span class="line">c=<span class="number">4</span>          --尽管在函数中，也是全局变量，除非用<span class="keyword">local</span>声明</span><br><span class="line"><span class="keyword">local</span> d=<span class="number">7</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">joke()</span><br><span class="line"><span class="keyword">print</span>(c,d)      --输出结果为<span class="number">4</span> nil ，则<span class="keyword">local</span>表示的是局部变量，d打印出来的值为nil</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="keyword">local</span> a=<span class="number">6</span></span><br><span class="line">   b=<span class="number">6</span>          --为局部变量重新赋值</span><br><span class="line">   <span class="keyword">print</span>(a,b)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">a=<span class="number">3</span>  --为全局变量重新赋值</span><br><span class="line"><span class="keyword">print</span>(a,b)</span><br><span class="line">--]]</span><br><span class="line"></span><br><span class="line">--赋值语句</span><br><span class="line">--[[</span><br><span class="line">--<span class="number">1</span>,Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。</span><br><span class="line">a,b=<span class="number">6</span>,<span class="number">7</span></span><br><span class="line"><span class="keyword">print</span>(a,b)</span><br><span class="line">--<span class="number">2</span>.交换变量的值</span><br><span class="line">  -- <span class="keyword">x</span>,<span class="keyword">y</span>=<span class="keyword">y</span>,<span class="keyword">x</span></span><br><span class="line">  -- a[i],a[j]=a[j],a[i]</span><br><span class="line">--<span class="number">3</span>,</span><br><span class="line">  --a. 变量个数 &gt; 值的个数             按变量个数补足nil</span><br><span class="line">  --b. 变量个数 &lt; 值的个数             多余的值会被忽略</span><br><span class="line">a,b,c=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">print</span>(a,b,c)</span><br><span class="line">c,d=<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span></span><br><span class="line"><span class="keyword">print</span>(c,d)</span><br><span class="line">--多值赋值经常用来交换变量，或将函数调用返回给变量：</span><br><span class="line">--a,b=f()</span><br><span class="line"></span><br><span class="line">f()返回两个值，第一个赋给a，第二个赋给b。</span><br><span class="line"></span><br><span class="line">应该尽可能的使用局部变量，有两个好处：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 避免命名冲突。</span><br><span class="line"><span class="number">2</span>. 访问局部变量的速度比全局变量更快。</span><br><span class="line">--]]</span><br><span class="line"></span><br><span class="line">--索引  对table的索引使用方括号[]，也可使用. 来操作</span><br><span class="line">--[[</span><br><span class="line">site=&#123;&#125;</span><br><span class="line">site[<span class="string">&quot;key&quot;</span>]=<span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line"><span class="keyword">print</span>(site[<span class="string">&quot;key&quot;</span>])</span><br><span class="line"><span class="keyword">print</span>(site.key)</span><br><span class="line">--]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua 基本数据类型</title>
      <link href="2019/12/06/Lua%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>2019/12/06/Lua%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">--type函数 判断数据类型</span><br><span class="line">--[[</span><br><span class="line"><span class="keyword">print</span>(type(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line"><span class="keyword">print</span>(type(<span class="number">10.4</span>*<span class="number">3</span>))</span><br><span class="line"><span class="keyword">print</span>(type(<span class="keyword">print</span>))</span><br><span class="line"><span class="keyword">print</span>(type(type))</span><br><span class="line"><span class="keyword">print</span>(type(true))</span><br><span class="line"><span class="keyword">print</span>(type(nil))</span><br><span class="line"><span class="keyword">print</span>(type(type(<span class="keyword">x</span>)))</span><br><span class="line">--]]</span><br><span class="line"></span><br><span class="line">--nil类型</span><br><span class="line">--[[</span><br><span class="line"></span><br><span class="line">--nil 表示空值</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(type(a))  --打印一个没有赋值的变量，会输出nil</span><br><span class="line"></span><br><span class="line">--删除变量 ，用nil给变量赋值</span><br><span class="line"></span><br><span class="line">tab1 = &#123; key1=<span class="string">&quot;val1&quot;</span>,key2=<span class="string">&quot;val2&quot;</span>,<span class="string">&quot;val3&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k,v in pairs(tab1) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">print</span>(k ..<span class="string">&quot;-&quot;</span>.. v)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">tab1.key1=nil</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v in pairs(tab1) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">print</span>(k ..<span class="string">&quot;-&quot;</span>.. v)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">--nil做比较时应该加双引号<span class="string">&quot;，此话的意思应放在适当情景，转换成相同类型，再进行比较</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">type(x)</span></span><br><span class="line"><span class="string">print(type(x))</span></span><br><span class="line"><span class="string">print(type(type(x)))</span></span><br><span class="line"><span class="string">print(type(x)==nil)  --当不加双引号时，此时判断的结果为false,  type(type(x))为string</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(type(x)==&quot;</span>nil<span class="string">&quot;)  --当加上双引号时，判断结果为true，”“表示字符串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(x==nil)       --直接比较值,结果为true</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(x==&quot;</span>nil<span class="string">&quot;)      --结果为false，x为nil类型，而&quot;</span>nil<span class="string">&quot;为string类型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--boolean类型</span></span><br><span class="line"><span class="string">--[[</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--Lua 把 false 和 nil 看作是 false，其他的都为 true，数字 0 也是 true.</span></span><br><span class="line"><span class="string">print(type(true))</span></span><br><span class="line"><span class="string">print(type(false))</span></span><br><span class="line"><span class="string">print(type(nil))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--对以下代码有点不懂，没有理解</span></span><br><span class="line"><span class="string">if false or nil then</span></span><br><span class="line"><span class="string">    print(&quot;</span>至少有一个是true<span class="string">&quot;)</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">print(&quot;</span>false 和 nil 都为 false<span class="string">&quot;)</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if 0 then</span></span><br><span class="line"><span class="string">    print(&quot;</span>数字<span class="number">0</span>是true<span class="string">&quot;)</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">    print(&quot;</span>数字<span class="number">0</span>是false<span class="string">&quot;)</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">--]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--number (数字）类似于整数，浮点；但这里统一称为number</span></span><br><span class="line"><span class="string">--[[</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(2)</span></span><br><span class="line"><span class="string">print(type(2))</span></span><br><span class="line"><span class="string">print(type(2.2))</span></span><br><span class="line"><span class="string">print(type(2e+1))</span></span><br><span class="line"><span class="string">print(type(0.3e-1))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--结果显示都为number类型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--string 字符串类型</span></span><br><span class="line"><span class="string">--[[</span></span><br><span class="line"><span class="string">--       可以用一对双引号或单引号表示</span></span><br><span class="line"><span class="string">string1=&quot;</span>liuzhifeng<span class="string">&quot;</span></span><br><span class="line"><span class="string">string2=&#x27;lzf&#x27;</span></span><br><span class="line"><span class="string">print(string1)</span></span><br><span class="line"><span class="string">print(string2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--       也可以使用两对方括号 来表示“一块”字符串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--在进行算数运算，lua会将数字字符串转换为number</span></span><br><span class="line"><span class="string">print(&quot;</span><span class="number">2</span><span class="string">&quot;+6)   --结果为8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--print(&quot;</span>error<span class="string">&quot;+1)   这时会报错，不能将&quot;</span>error<span class="string">&quot;转为number类型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--字符串连接符：..</span></span><br><span class="line"><span class="string">print(&quot;</span>liuzhifeng <span class="string">&quot;..&quot;</span>is handsome<span class="string">&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--字符串长度：#</span></span><br><span class="line"><span class="string">string=&quot;</span>liuzhifeng<span class="string">&quot;</span></span><br><span class="line"><span class="string">print(#string)    --结果为10</span></span><br><span class="line"><span class="string">print(#&quot;</span>lizuhifeng<span class="string">&quot;)   --结果为10</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--table(表)，lua里面的一种数据结构 ,类似于c++ stl中的vector</span></span><br><span class="line"><span class="string">--[[</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   --创建table，通过构造表达式。&#123; &#125;相当于C++里面的构造表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">local table=&#123;&#125;</span></span><br><span class="line"><span class="string">local table=&#123;&quot;</span>appple<span class="string">&quot;,&quot;</span>pear<span class="string">&quot;,&quot;</span>orange<span class="string">&quot;,&quot;</span>grape<span class="string">&quot;&#125;</span></span><br><span class="line"><span class="string">for i,j in pairs(table) do</span></span><br><span class="line"><span class="string">    print(i..&quot;</span>:<span class="string">&quot;..j)</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">--Lua 中的表（table）其实是一个&quot;</span>关联数组<span class="string">&quot;（associative arrays），数组的索引可以是数字或者是字符串。</span></span><br><span class="line"><span class="string">a=&#123;&#125;</span></span><br><span class="line"><span class="string">a[&quot;</span>key<span class="string">&quot;]=&quot;</span>value<span class="string">&quot;</span></span><br><span class="line"><span class="string">key=1</span></span><br><span class="line"><span class="string">a[key]=3</span></span><br><span class="line"><span class="string">a[key]=a[key]+4</span></span><br><span class="line"><span class="string">for i,j in pairs(a) do</span></span><br><span class="line"><span class="string">print(i..&quot;</span>:<span class="string">&quot;..j)</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--lua中table里面的默认索引以1开始 ，不同于c，c++</span></span><br><span class="line"><span class="string">local table=&#123;&quot;</span>appple<span class="string">&quot;,&quot;</span>pear<span class="string">&quot;,&quot;</span>orange<span class="string">&quot;,&quot;</span>grape<span class="string">&quot;&#125;</span></span><br><span class="line"><span class="string">for key,val in pairs(table) do</span></span><br><span class="line"><span class="string">   print(key..&quot;</span>:<span class="string">&quot;..val)</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--table大小不固定，根据添加减少自动变化，没初识的都为nil，   这点就像c++stl里的vector</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--function 函数</span></span><br><span class="line"><span class="string">--[[</span></span><br><span class="line"><span class="string">--在 Lua 中，函数是被看作是&quot;</span>第一类值（First-Class Value）<span class="string">&quot;，函数可以存在变量里:</span></span><br><span class="line"><span class="string">function factorial1(n)   --function 函数名（参数）</span></span><br><span class="line"><span class="string">    if n == 0 then</span></span><br><span class="line"><span class="string">        return 1</span></span><br><span class="line"><span class="string">    else</span></span><br><span class="line"><span class="string">        return n * factorial1(n - 1)</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">print(factorial1(5))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">factorial2 = factorial1</span></span><br><span class="line"><span class="string">print(factorial2(5))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--function可以以匿名函数的方式通过参数传递</span></span><br><span class="line"><span class="string"> function testFun(tab,fun)</span></span><br><span class="line"><span class="string">for  k,v in pairs(tab) do</span></span><br><span class="line"><span class="string">print(fun(k,v))</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">tab=&#123;key1=&quot;</span>val1<span class="string">&quot;,key2=&quot;</span>val2<span class="string">&quot;&#125;</span></span><br><span class="line"><span class="string">testFun(tab,function(key,val)  --重点，竟然还可以这样使用</span></span><br><span class="line"><span class="string">   return key..&quot;</span>=<span class="string">&quot;..val          --直接return返回参数</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string">--]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--thread 线程</span></span><br><span class="line"><span class="string">--[[</span></span><br><span class="line"><span class="string">在 Lua 里，最主要的线程是协同程序（coroutine）。</span></span><br><span class="line"><span class="string">它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--userdata  用户自定义类型</span></span><br><span class="line"><span class="string">--[[</span></span><br><span class="line"><span class="string">userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，</span></span><br><span class="line"><span class="string">可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。</span></span><br><span class="line"><span class="string">--]]</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua基础</title>
      <link href="2019/12/06/Lua%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BB%A5%E5%8F%8ASCITE%E7%BC%96%E8%BE%91%E5%99%A8UTF-8%E8%AE%BE%E7%BD%AE/"/>
      <url>2019/12/06/Lua%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BB%A5%E5%8F%8ASCITE%E7%BC%96%E8%BE%91%E5%99%A8UTF-8%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Lua基础"><a href="#Lua基础" class="headerlink" title="Lua基础"></a>Lua基础</h2><p>初学Lua</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;hello world&quot;)</span><br><span class="line">print(&quot;www.liuzhifeng.com&quot;)</span><br><span class="line"></span><br><span class="line">--单行注释</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--[[</span><br><span class="line"></span><br><span class="line">多行注释</span><br><span class="line"></span><br><span class="line">--]]</span><br><span class="line"></span><br><span class="line">--[[</span><br><span class="line"> 默认状态下，变量总认为是全局的。</span><br><span class="line"> 给一个变量赋值后即创建了这个变量</span><br><span class="line"> 删除变量：将其赋值为nil</span><br><span class="line"></span><br><span class="line">--]]</span><br><span class="line"></span><br><span class="line">b&#x3D;10</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">b&#x3D;nil</span><br><span class="line"></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">--当变量为nil时，则变量不存在；当变量不为nil时，则这个变量即存在</span><br><span class="line"></span><br><span class="line">--设置SCiTE默认编码格式UTF-8：Options-&gt;Open User Options File-&gt;输入</span><br><span class="line">--        code.page&#x3D;65001</span><br><span class="line">--        output.code.page&#x3D;65001</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua字符串操作</title>
      <link href="2019/12/06/Lua%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
      <url>2019/12/06/Lua%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Lua字符串操作"><a href="#Lua字符串操作" class="headerlink" title="Lua字符串操作"></a>Lua字符串操作</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">--Lua字符串</span><br><span class="line"></span><br><span class="line">--[[</span><br><span class="line">  <span class="number">1</span>、stirng.upper(str) 转化为大写</span><br><span class="line">  <span class="number">2</span>、string.lower(str) 转化为小写</span><br><span class="line">  <span class="number">3</span>、string.gsub(mainStr,findStr,replaceStr,num)  替换字符</span><br><span class="line">    <span class="keyword">print</span>(string.gsub(<span class="string">&quot;aaaa&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;z&quot;</span>,<span class="number">3</span>))</span><br><span class="line">  <span class="number">4</span>、string.find(Str,<span class="keyword">substr</span>,(init,[end]))  在目标字符串中搜索从指定索引后的内容（第三个数为索引），返回开始和结束的索引</span><br><span class="line"><span class="keyword">print</span>(string.find(<span class="string">&quot;hello lua user&quot;</span>,<span class="string">&quot;lua&quot;</span>,<span class="number">1</span>))</span><br><span class="line">  <span class="number">5</span>、string.<span class="keyword">reverse</span>(str)   反转字符串</span><br><span class="line"><span class="keyword">print</span>(string.<span class="keyword">reverse</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">  <span class="number">6</span>、string.fomat(...)   相当于c中的<span class="keyword">printf</span></span><br><span class="line">  <span class="number">7</span>、string.char(str)   将整形数字转换为字符并连接</span><br><span class="line"></span><br><span class="line">       <span class="keyword">print</span>(string.char(<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">   string.byte(str,<span class="keyword">int</span>)   转换字符为整数值（可以指定索引，默认第一个字符）</span><br><span class="line">      <span class="keyword">print</span>(string.byte(<span class="string">&quot;ABCD&quot;</span>))</span><br><span class="line">      <span class="keyword">print</span>(string.byte(<span class="string">&quot;ABCD&quot;</span>,<span class="number">3</span>))</span><br><span class="line">  <span class="number">8</span>、 string.len(str)     计算字符串的长度</span><br><span class="line">  <span class="number">9</span>、 string.rep(str,n)   返回字符串的n个拷贝</span><br><span class="line">  <span class="number">10</span>、string.gmatch(str, pattern)</span><br><span class="line">回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。</span><br><span class="line">  <span class="keyword">for</span> word in string.gmatch(<span class="string">&quot;hello Lua user&quot;</span>,<span class="string">&quot;%a+&quot;</span>)           --%a+是什么意思？输出什么类型的？</span><br><span class="line"><span class="keyword">do</span> <span class="keyword">print</span>(word)</span><br><span class="line"> end</span><br><span class="line">  <span class="number">11</span>、string.match(str, pattern, init)</span><br><span class="line">  string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为<span class="number">1</span>。在成功配对时,函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。</span><br><span class="line">      <span class="keyword">print</span>(string.match(<span class="string">&quot;i have 2 questions for you.&quot;</span>,<span class="string">&quot;%d+ %a+&quot;</span>))</span><br><span class="line">  <span class="keyword">print</span>(string.format(<span class="string">&quot;%d,%q&quot;</span>,string.match(<span class="string">&quot;i have 2 questions for you&quot;</span>,<span class="string">&quot;(%d+) (%a+)&quot;</span>)))</span><br><span class="line">--]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--字符串格式化</span><br><span class="line">--[[</span><br><span class="line">    %g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式</span><br><span class="line">    %q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式</span><br><span class="line">    %s - 接受一个字符串并按照给定的参数格式化该字符串</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) 符号: 一个+号表示其后的数字转义符将让正数显示正号.       默认情况下只有负数显示符号.</span><br><span class="line">    (<span class="number">2</span>) 占位符: 一个<span class="number">0</span>, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.</span><br><span class="line">    (<span class="number">3</span>) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.</span><br><span class="line">    (<span class="number">4</span>) 宽度数值</span><br><span class="line">    (<span class="number">5</span>) 小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.<span class="number">3</span>f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.<span class="number">3</span>s)则设定该字符串只显示前n位.</span><br><span class="line">--]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua数组，打印九九乘法口诀</title>
      <link href="2019/12/06/Lua%E6%95%B0%E7%BB%84%EF%BC%8C%E6%89%93%E5%8D%B0%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E5%8F%A3%E8%AF%80/"/>
      <url>2019/12/06/Lua%E6%95%B0%E7%BB%84%EF%BC%8C%E6%89%93%E5%8D%B0%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E5%8F%A3%E8%AF%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Lua数组，打印九九乘法口诀"><a href="#Lua数组，打印九九乘法口诀" class="headerlink" title="Lua数组，打印九九乘法口诀"></a>Lua数组，打印九九乘法口诀</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">--lua数组</span><br><span class="line"></span><br><span class="line">--九九乘法口诀表</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">9</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span>,i <span class="keyword">do</span></span><br><span class="line">        io.write(j,<span class="string">&quot;*&quot;</span>,i,<span class="string">&quot;=&quot;</span>,i*j,<span class="string">&quot; &quot;</span>)  </span><br><span class="line">    end</span><br><span class="line">    <span class="keyword">print</span>()</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 初始化数组</span><br><span class="line">--[[</span><br><span class="line">array = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">   array[i] = &#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> j=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">         array[i][j] = i*j</span><br><span class="line">      end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 访问数组</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">   <span class="keyword">for</span> j=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">print</span>(array[i][j])</span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line">--]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>值传递，引用传递，指针传递</title>
      <link href="2019/12/06/%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%8C%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92/"/>
      <url>2019/12/06/%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%8C%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<h1 id="值传递，引用传递，指针传递"><a href="#值传递，引用传递，指针传递" class="headerlink" title="值传递，引用传递，指针传递"></a>值传递，引用传递，指针传递</h1><p>&emsp;&emsp;<strong>值传递，引用传递，指针传递</strong>：</p><p>&emsp;&emsp;1、值传递：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;传值传的是原来实参的一份拷贝，对形参进行操作不会改变实参的值。函数返回后，函数栈帧销毁，这份拷贝也会自动被回收。</p><p>&emsp;&emsp;2、引用传递：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; x)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;传引用什么也没创建，只是给实参起个别名，就像同学之间取外号一样，张三是一个同学，别人给他取名就二狗，那么张三，二狗就是同一个人。在这也是一样的，对引用进行操作就等于对实参的操作，对引用的操作会影响原来的实参。</p><p>&emsp;&emsp;3、指针传递：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* &amp;x)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果传入的指针型变量，并且在函数体内要对传入的指针进行改变，则可以按照上述编写参数。</p><p>&emsp;&emsp;传指针就是为实参传建一个指针变量，指针变量里面存的就是实参的地址，对形参进行操作也会通过指针的间接访问对实参进行修改，所以对形参的操作会影响原来的值。</p><p>如果觉得本文对你有所帮助的话，不妨关注作者一波。更多高质量内容和资料请访问：<a href="https://xiuxin.gitbook.io/datastructre/">https://xiuxin.gitbook.io/datastructre/</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可变分区内存动态分配模拟</title>
      <link href="2019/12/06/%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E6%A8%A1%E6%8B%9F/"/>
      <url>2019/12/06/%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="可变分区内存动态分配模拟"><a href="#可变分区内存动态分配模拟" class="headerlink" title="可变分区内存动态分配模拟"></a>可变分区内存动态分配模拟</h1><p>可变分区是指在进程装入内存时，把可用的内存空间“切出”一个连续的区域分配给进程，以适应进程大小的需要。整个内存分区的大小和分区的个数不是固定不变的，而是根据装入进程的大小动态划分。</p><h2 id="可变分区中的数据结构：空闲分区表和空闲分区链。"><a href="#可变分区中的数据结构：空闲分区表和空闲分区链。" class="headerlink" title="可变分区中的数据结构：空闲分区表和空闲分区链。"></a>可变分区中的数据结构：空闲分区表和空闲分区链。</h2><p>   空闲分区表为每个尚未分配出去的分区设置一个表项，每个表项包括分区的序号，分区大小，分区起始地址。<br>       空闲分区链在每个分区中设置用于控制分区分配的信息以及用于链接各个分区的指针，将内存中的空闲分区链成一个链表。</p><h2 id="可变分区中的算法"><a href="#可变分区中的算法" class="headerlink" title="可变分区中的算法"></a>可变分区中的算法</h2><p>   1）首次适应算法（First Fit)</p><p>   该算法要求空闲分区以地址递增的次序排序，分配时从表头开始顺序查找，直到找到一个能够满足进程大小的空闲分区为止，然后从进程中切出一块内存空间分配给进程，余下的空间仍然留在内存中。<br>优点：优先使用低地址的空闲空间，高地址部分很少利用，保证了高地址的留有较大的空闲分区<br>缺点：低地址部分不断“切割”，使留下许多难以利用的空闲分区，而每次又都从低地址开始，这就会影响查找的速度。</p><p>2）下次适应算法（Next Fit)<br>该算法从首次适应算法演变过来，为了避免低地址小空闲部分分区的不断增加，在给进程分配空间时，不再每次从表头开始，而是从上次找到的空闲分区的下一个空闲分区开始，直到找到一个满足要求的空闲分区，并从中“切出”一块分配给进程。为了实现，要设置起始查询指针，链表的链接采用循环链表。<br>优点：使内存得到比较均衡的使用，减少了查找的开销<br>缺点：会使内存缺少大的内存分区，导致大的进程运行不了</p><p>3）最佳适应算法（Best Fit)<br>最佳适应算法就是在剩下的空闲空间中按空闲的大小递增的顺序查找满足条件的最小的空闲分区分配给进程。<br>优点：第一次找到的空闲分区一定是最优的，系统中也可能保留较大的空闲空间<br>缺点：链表的表头会留下许多难以利用的小空闲区，而影响分配速度。</p><p>4）最坏适应算法（Worst Fit）<br>最坏适应算法和最佳适应算法正好相反，按大小递减的顺序查找<br>优点：基本上不会留下小空闲区，不会形成碎片<br>缺点：大的空闲区被切割，导致较大的进程不能满足，无法运行</p><h2 id="下面我主要讲的是首次适应算法和最佳适应算法："><a href="#下面我主要讲的是首次适应算法和最佳适应算法：" class="headerlink" title="下面我主要讲的是首次适应算法和最佳适应算法："></a>下面我主要讲的是首次适应算法和最佳适应算法：</h2><p>设置空闲分区的数据结构为空闲分区表：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span>   addr;         <span class="comment">//块的起始地址</span></span><br><span class="line"><span class="keyword">int</span>  size;          <span class="comment">// 块的大小</span></span><br><span class="line"><span class="keyword">int</span>  flag;          <span class="comment">//块的分配状态     1：代表已分配 0：代表未分配；</span></span><br><span class="line">&#125;block[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p>初始化表头的起始地址以及所有空闲分区大小的总和</p><p>设置首次适应算法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">shoucishiyin</span><span class="params">()</span>           </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*采用首次适应算法</span></span><br><span class="line"><span class="comment">     首先输入要调入内存的进程的大小。然后在block数组中找未分配且比该进程大的块，</span></span><br><span class="line"><span class="comment">   如找到的块和进程一样大，直接将该块设为已分配，如比进程大，该块要分为两块，</span></span><br><span class="line"><span class="comment">  一块已分配，一块空闲，并且后面的块依次后移一位。*/</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要调入内存的进程大小:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;size);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=count;i++)</span><br><span class="line">    <span class="keyword">if</span>(block[i].flag==<span class="number">0</span>&amp;&amp;block[i].size&gt;=size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(block[i].size==size)</span><br><span class="line">block[i].flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;  </span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=count;j&gt;i+<span class="number">1</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line">block[j]=block[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新的第i+1块</span></span><br><span class="line">block[i+<span class="number">1</span>].flag=<span class="number">0</span>;</span><br><span class="line">block[i+<span class="number">1</span>].addr=block[i].addr+size;</span><br><span class="line">block[i+<span class="number">1</span>].size=block[i].size-size;</span><br><span class="line">             <span class="comment">//新的第i块</span></span><br><span class="line">            block[i].flag=<span class="number">1</span>;</span><br><span class="line">block[i].size=size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此算法运行的效果如下：</p><p>设置最佳适应算法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zuijiashiyin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要调入内存的进程大小:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;size);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=count;i++)</span><br><span class="line"><span class="keyword">if</span>(block[i].flag==<span class="number">0</span>&amp;&amp;block[i].size&gt;=size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(block[i].flag==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> minneicun=size,index=count;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=count;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(block[j].flag==<span class="number">0</span>&amp;&amp;block[j].size&lt;=minneicun)</span><br><span class="line">&#123;</span><br><span class="line">minneicun=block[j].size;</span><br><span class="line">index=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(block[index].size==size)</span><br><span class="line">&#123;   block[index].flag=<span class="number">1</span>;</span><br><span class="line">            block[index].size=size;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">&#123;   block[index+<span class="number">1</span>].addr=block[index].addr+size;</span><br><span class="line">      block[index+<span class="number">1</span>].size=block[index].size-size;</span><br><span class="line">    block[index+<span class="number">1</span>].flag=<span class="number">0</span>;</span><br><span class="line">     block[index].size=size;</span><br><span class="line">     block[index].flag=<span class="number">1</span>;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;            </span><br><span class="line">    <span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上设计算法的过程中，讨论块调出后内存的变化情况是最重要的，只有把全部情况考虑进去之后，才能将最佳适应算法正确的设计出来</p><p>下面是我运行的一些结果：<br><img src="https://img-blog.csdnimg.cn/20191118160211729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Mjg1NTUx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>         重在理解，代码实现方法有很多种。由于过了一段时间再做改动，就潦草结尾了，对不住各位了。一起加油！！！</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 动态分配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可变分区内存动态分配模拟</title>
      <link href="2019/12/06/%E5%A6%82%E4%BD%95%E4%BB%8Ewindows%E5%A4%8D%E5%88%B6%E5%88%B0linux%E4%B8%8A%EF%BC%88%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88%EF%BC%81%EF%BC%89/"/>
      <url>2019/12/06/%E5%A6%82%E4%BD%95%E4%BB%8Ewindows%E5%A4%8D%E5%88%B6%E5%88%B0linux%E4%B8%8A%EF%BC%88%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88%EF%BC%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>如何从windows复制到linux上</strong></p><h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><p>下载软件：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt-get autoremove open-vm-tools</span><br><span class="line">sudo apt-get install open-vm-tools-desktop</span><br></pre></td></tr></table></figure><p>重启linux。<br>一种方法我不适用，不知道大家的可不可以，试一试。</p><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>步骤有点繁琐，但是最后的确成功有效<br><img src="https://img-blog.csdnimg.cn/20200515232158308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Mjg1NTUx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面点击 是  。<br>linux下载好之后会弹出一个VmwareTools ，点开，你会发现一个tar.gz的一个压缩包。在主目录新建一个myfile文件夹，将这个.tar.gz复制到myfile文件夹中，打开终端，进入myfile路径下，解压压缩包。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tar -xzvf VMwareTools<span class="number">-10.1</span><span class="number">.15</span><span class="number">-6627299.</span>tar.gz</span><br></pre></td></tr></table></figure><p>这里可能安装包不一样，所以相应的数字也不一样，注意文件名要与你的压缩包要相同<br>解压后myfile文件夹中就会多出一个vmware-to-ols-distrib文件夹，进入该文件夹，在空白处右键，在终端打开，而不是新打开一个终端<br><img src="https://img-blog.csdnimg.cn/20200515233358517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Mjg1NTUx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>运行下面指令：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo ./vmware-install.pl</span><br></pre></td></tr></table></figure><p>这时可能提示要你选择安装目录，你就回车回车两次就行，有些需要你确认的 ，你就输入y    。系统会自动帮你建立。<br>安装成功会显示 ，enjoy  。<br>成功之后，重启虚拟机，大功告成！</p><p>   亲测有效！希望大家看了之后都能安装成功！</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁道调度算法(满满的干货)</title>
      <link href="2019/12/06/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E6%BB%A1%E6%BB%A1%E7%9A%84%E5%B9%B2%E8%B4%A7%EF%BC%89/"/>
      <url>2019/12/06/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E6%BB%A1%E6%BB%A1%E7%9A%84%E5%B9%B2%E8%B4%A7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="磁道调度算法"><a href="#磁道调度算法" class="headerlink" title="磁道调度算法"></a>磁道调度算法</h2><p> 四种磁盘调度算法FCFS，SSTF，SCAN，CSCAN的基本思想在这就不多说了。<br> 下面直接附上代码实现过程：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*磁盘调度算法:</span></span><br><span class="line"><span class="comment">  先来先服务：按进程的先后顺序进行调度</span></span><br><span class="line"><span class="comment">  最短寻道：对磁道距离最短的磁道进行访问</span></span><br><span class="line"><span class="comment">  扫描算法：沿着一个方向，由里向外扫描磁道，到最外层磁道，然后变换为由外向里扫描磁道</span></span><br><span class="line"><span class="comment">  循环扫描算法：只能沿着一个方向，有里向外扫描磁道，到最外层磁道时转换为最里层的磁道</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  测试数据：</span></span><br><span class="line"><span class="comment">  9个磁道：55 58 39 18 90 160 150 38 184</span></span><br><span class="line"><span class="comment">  9个磁道：67 92 79 64 130 150 45 28 12</span></span><br><span class="line"><span class="comment">  8个磁道：90 87 101 76 12 64 73 23</span></span><br><span class="line"><span class="comment">  8个磁道：87 90 76 101 12 64 73 120</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Disk_Schedule</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> NextTrack;</span><br><span class="line"><span class="keyword">int</span> MovedTrack;</span><br><span class="line">&#125;Disk;</span><br><span class="line"></span><br><span class="line">Disk *Track;</span><br><span class="line"><span class="keyword">float</span> SumMovedTrack=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> TrackNum;</span><br><span class="line"><span class="keyword">int</span> NowTrack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入当前的磁道号:&quot;</span>;</span><br><span class="line">cin&gt;&gt;NowTrack;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入进程要访问的磁盘数:&quot;</span>;</span><br><span class="line">cin&gt;&gt;TrackNum;</span><br><span class="line">Track=<span class="keyword">new</span> Disk[TrackNum];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请依次输入进程要访问的磁盘号：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;TrackNum;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;Track[i].NextTrack;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;输入完毕!&quot;</span>&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;输出磁道访问信息:&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;下一个被访问磁道&quot;</span>&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;<span class="string">&quot;移动的磁道数&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;TrackNum;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;Track[i].NextTrack&lt;&lt;<span class="string">&quot;\t\t&quot;</span>&lt;&lt;Track[i].MovedTrack&lt;&lt;endl;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">float</span> SumMovedTrack=<span class="number">0</span>;      <span class="comment">//初始化SumMovedTrack为0</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TrackNum;i++)</span><br><span class="line">&#123;</span><br><span class="line">SumMovedTrack+=Track[i].MovedTrack;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;磁头移动总距离:&quot;</span>&lt;&lt;SumMovedTrack&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;平均磁盘移动长度:&quot;</span>&lt;&lt;SumMovedTrack/TrackNum&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;输出完毕！&quot;</span>&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FCFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Input</span>();</span><br><span class="line">Track[<span class="number">0</span>].MovedTrack=<span class="built_in">abs</span>(NowTrack-Track[<span class="number">0</span>].NextTrack);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;TrackNum;i++)</span><br><span class="line">&#123;</span><br><span class="line">Track[i].MovedTrack=<span class="built_in">abs</span>(Track[i<span class="number">-1</span>].NextTrack-Track[i].NextTrack);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;FCFS调度算法:&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">Output</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSTF</span><span class="params">()</span>                       <span class="comment">//定义最短寻道算法 </span></span></span><br><span class="line"><span class="function"></span>&#123;      </span><br><span class="line"><span class="built_in">Input</span>();</span><br><span class="line"><span class="keyword">int</span> NewTrack[<span class="number">50</span>],Moved[<span class="number">50</span>];     <span class="comment">//定义两个数组，分别存放下次要访问的磁道数和磁道移动数</span></span><br><span class="line"><span class="keyword">int</span> i,j,k,t,n,m=<span class="number">0</span>,temp;</span><br><span class="line"><span class="comment">/*for(i=0;i&lt;TrackNum-1;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">for(j=i+1;j&lt;TrackNum;j++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if(Track[i].NextTrack&gt;Track[j].NextTrack)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">int temp;</span></span><br><span class="line"><span class="comment">temp=Track[i].NextTrack;</span></span><br><span class="line"><span class="comment">Track[i].NextTrack=Track[j].NextTrack;</span></span><br><span class="line"><span class="comment">Track[j].NextTrack=temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">&#125;*/</span>                           <span class="comment">//对存放下次要访问磁道数的数组进行冒泡排序</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TrackNum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=m;j&lt;TrackNum;j++)</span><br><span class="line">Moved[j]=<span class="built_in">abs</span>(Track[j].NextTrack-NowTrack);         <span class="comment">//计算出移动磁道数，并赋值到数组</span></span><br><span class="line">    n=<span class="number">1000</span>;                          <span class="comment">//最大移动磁道数为1000</span></span><br><span class="line"><span class="keyword">for</span>(k=m;k&lt;TrackNum;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Moved[k]&lt;n)           </span><br><span class="line">&#123;</span><br><span class="line">n=Moved[k];</span><br><span class="line">    t=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;           <span class="comment">//找出移动磁道数最小的磁道序号并赋值给t                              </span></span><br><span class="line">NewTrack[m]=Track[t].NextTrack;               <span class="comment">//根据最短寻道算法，对每次下次要访问的磁道赋值</span></span><br><span class="line">Track[m].MovedTrack=Moved[t];           <span class="comment">//计算移动的磁道数</span></span><br><span class="line">NowTrack=Track[t].NextTrack;           <span class="comment">//改变当前所在磁道数</span></span><br><span class="line"></span><br><span class="line">temp=Track[m].NextTrack;                  </span><br><span class="line">Track[m].NextTrack=Track[t].NextTrack;</span><br><span class="line">Track[t].NextTrack=temp;                 <span class="comment">//交换</span></span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TrackNum;i++)</span><br><span class="line">Track[i].NextTrack=NewTrack[i];</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;SSTF调度算法:&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">Output</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SCAN</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,key,index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> NewTrack[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">Input</span>();</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; TrackNum; i++)          <span class="comment">//对磁道进行降序排序</span></span><br><span class="line">&#123;</span><br><span class="line">key= Track[i].NextTrack; </span><br><span class="line"><span class="keyword">for</span>(j=i<span class="number">-1</span>;j &gt;=<span class="number">0</span> &amp;&amp; key &gt; Track[j].NextTrack;j--)</span><br><span class="line">&#123;</span><br><span class="line">Track[j + <span class="number">1</span>].NextTrack = Track[j].NextTrack;</span><br><span class="line">&#125;</span><br><span class="line">Track[j+<span class="number">1</span>].NextTrack = key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TrackNum;i++)           <span class="comment">//找出当前磁道所在的位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Track[i].NextTrack&gt;NowTrack)</span><br><span class="line">&#123; index++;  &#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;index;i++)                     <span class="comment">//由里向外，从当前磁道开始依次访问</span></span><br><span class="line">NewTrack[i]=Track[index-i<span class="number">-1</span>].NextTrack;</span><br><span class="line"><span class="keyword">for</span>(i=index;i&lt;TrackNum;i++)             <span class="comment">//到达最外层磁道，则由最外层磁道向里，依次访问内部磁道</span></span><br><span class="line">NewTrack[i]=Track[i].NextTrack;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TrackNum;i++)             <span class="comment">//将排好序的下一个被访问的磁道的中间变量数组赋给原始数组</span></span><br><span class="line">Track[i].NextTrack=NewTrack[i];</span><br><span class="line">    Track[<span class="number">0</span>].MovedTrack=<span class="built_in">abs</span>(NowTrack-Track[<span class="number">0</span>].NextTrack);    <span class="comment">//计算每一磁道的移动数</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;TrackNum;i++)</span><br><span class="line">&#123;</span><br><span class="line">Track[i].MovedTrack=<span class="built_in">abs</span>(Track[i<span class="number">-1</span>].NextTrack-Track[i].NextTrack);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;SCAN调度算法:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">Output</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSCAN</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,key,index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> NewTrack[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">Input</span>();</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; TrackNum; i++)           <span class="comment">//对磁道进行降序排序</span></span><br><span class="line">&#123;</span><br><span class="line">key= Track[i].NextTrack; </span><br><span class="line"><span class="keyword">for</span>(j=i<span class="number">-1</span>;j &gt;=<span class="number">0</span> &amp;&amp; key &gt; Track[j].NextTrack;j--)</span><br><span class="line">&#123;</span><br><span class="line">Track[j + <span class="number">1</span>].NextTrack = Track[j].NextTrack;</span><br><span class="line">&#125;</span><br><span class="line">Track[j+<span class="number">1</span>].NextTrack = key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TrackNum;i++)            <span class="comment">//找出当前磁道所在的位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Track[i].NextTrack&gt;NowTrack)</span><br><span class="line">&#123; index++;  &#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;index;i++)       <span class="comment">//由里向外，从当前磁道开始依次访问</span></span><br><span class="line">NewTrack[i]=Track[index<span class="number">-1</span>-i].NextTrack;</span><br><span class="line"><span class="comment">/*for(i=index;i&lt;(TrackNum-index)/2;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">t=Track[i].NextTrack;</span></span><br><span class="line"><span class="comment">Track[i].NextTrack=Track[TrackNum-1-i].NextTrack;</span></span><br><span class="line"><span class="comment">Track[TrackNum-1-i].NextTrack=t;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">/*for(i=index,j=TrackNum-1;Track[i].NextTrack&gt;Track[j].NextTrack;i++,j--)</span></span><br><span class="line"><span class="comment">&#123;    key=Track[i].NextTrack;</span></span><br><span class="line"><span class="comment">    Track[i].NextTrack=Track[j].NextTrack;</span></span><br><span class="line"><span class="comment">Track[j].NextTrack=key;   &#125;*/</span></span><br><span class="line"><span class="keyword">for</span>(i=index;i&lt;TrackNum;i++)            <span class="comment">//到达最外层磁道，则由最内层磁道向外，依次访问剩余磁道</span></span><br><span class="line">NewTrack[i]=Track[TrackNum+(index<span class="number">-1</span>)-i].NextTrack;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TrackNum;i++)</span><br><span class="line">Track[i].NextTrack=NewTrack[i];</span><br><span class="line">    Track[<span class="number">0</span>].MovedTrack=<span class="built_in">abs</span>(NowTrack-Track[<span class="number">0</span>].NextTrack);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;TrackNum;i++)</span><br><span class="line">&#123;</span><br><span class="line">Track[i].MovedTrack=<span class="built_in">abs</span>(Track[i<span class="number">-1</span>].NextTrack-Track[i].NextTrack);</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;CSCAN调度算法:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">Output</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;*************************磁盘调度系统*******************************&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\t┣  0:退出系统            ┫&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\t┣  1:FCFS调度算法        ┫&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\t┣  2:SSTF调度算法        ┫&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\t┣  3:SCAN调度算法        ┫&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\t┣  4:CSCAN调度算法       ┫&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> choice;</span><br><span class="line">choice=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(choice!=<span class="number">0</span>)</span><br><span class="line">&#123;   <span class="built_in">Menu</span>();</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入你的选择:&quot;</span>;</span><br><span class="line">     cin&gt;&gt;choice;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span>(choice)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">FCFS</span>();<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">SSTF</span>();<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">SCAN</span>();<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">CSCAN</span>();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然上述算法还有一些方面没有考虑到，不满足所有情况。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 磁道调度算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anagrams问题</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94Anagrams%E9%97%AE%E9%A2%98/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94Anagrams%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-Anagrams问题"><a href="#试题-算法训练-Anagrams问题" class="headerlink" title="试题 算法训练 Anagrams问题"></a>试题 算法训练 Anagrams问题</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：512.0MB<br>问题描述<br>　　Anagrams指的是具有如下特性的两个单词：在这两个单词当中，每一个英文字母（不区分大小写）所出现的次数都是相同的。例如，“Unclear”和“Nuclear”、“Rimon”和“MinOR”都是Anagrams。编写一个程序，输入两个单词，然后判断一下，这两个单词是否是Anagrams。每一个单词的长度不会超过80个字符，而且是大小写无关的。<br>　　输入格式：输入有两行，分别为两个单词。<br>　　输出格式：输出只有一个字母Y或N，分别表示Yes和No。<br>　　输入输出样例<br>样例输入<br>Unclear<br>Nuclear<br>样例输出<br>Y</p><p>最开始的想法是两个字符串的字符逐一进行比较，个人实现起来却。。。<br>借鉴了一下大佬的想法，可以先对字符串进行操作，这样比较起来就是十分地方便了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Anagrams问题</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(a.<span class="built_in">length</span>()!=b.<span class="built_in">length</span>())&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;N&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//将字符串全部转换为小写</span></span><br><span class="line"><span class="built_in">transform</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),a.<span class="built_in">begin</span>(),::tolower);</span><br><span class="line"><span class="built_in">transform</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>(),b.<span class="built_in">begin</span>(),::tolower);</span><br><span class="line"><span class="comment">//重新排序</span></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">while</span>(i&lt;a.<span class="built_in">length</span>())&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]!=b[i])&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;N&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Y&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Torry的困惑(基本型)</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94Torry%E7%9A%84%E5%9B%B0%E6%83%91%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%9E%8B%EF%BC%89/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94Torry%E7%9A%84%E5%9B%B0%E6%83%91%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%9E%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-Torry的困惑-基本型"><a href="#试题-算法训练-Torry的困惑-基本型" class="headerlink" title="试题 算法训练 Torry的困惑(基本型)"></a>试题 算法训练 Torry的困惑(基本型)</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：512.0MB<br>问题描述<br>　　Torry从小喜爱数学。一天，老师告诉他，像2、3、5、7……这样的数叫做质数。Torry突然想到一个问题，前10、100、1000、10000……个质数的乘积是多少呢？他把这个问题告诉老师。老师愣住了，一时回答不出来。于是Torry求助于会编程的你，请你算出前n个质数的乘积。不过，考虑到你才接触编程不久，Torry只要你算出这个数模上50000的值。<br>输入格式<br>　　仅包含一个正整数n，其中n&lt;=100000。<br>输出格式<br>　　输出一行，即前n个质数的乘积模50000的值。<br>样例输入<br>1</p><p>样例输出</p><p>2</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ZHISHU</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">2</span>||a==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;a;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a%i==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;  <span class="comment">//质数的个数</span></span><br><span class="line">cin&gt;&gt;num;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;     <span class="comment">//用于统计质数个数</span></span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;count&lt;num;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">ZHISHU</span>(i))&#123;</span><br><span class="line">result*=i;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;result%<span class="number">50000</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200822171847828.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>出现次数最多的整数</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%95%B4%E6%95%B0/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-出现次数最多的整数"><a href="#试题-算法训练-出现次数最多的整数" class="headerlink" title="试题 算法训练 出现次数最多的整数"></a>试题 算法训练 出现次数最多的整数</h2><p>资源限制<br>时间限制：1.0s   内存限制：512.0MB<br>　　﻿问题描述<br>　　编写一个程序，读入一组整数，这组整数是按照从小到大的顺序排列的，它们的个数N也是由用户输入的，最多不会超过20。然后程序将对这个数组进行统计，把出现次数最多的那个数组元素值打印出来。如果有两个元素值出现的次数相同，即并列第一，那么只打印比较小的那个值。<br>　　输入格式：第一行是一个整数N，N £ 20；接下来有N行，每一行表示一个整数，并且按照从小到大的顺序排列。<br>　　输出格式：输出只有一行，即出现次数最多的那个元素值。<br>输入输出样例<br>样例输入<br>5<br>100<br>150<br>150<br>200<br>250<br>样例输出<br>150</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;  <span class="comment">//整数个数</span></span><br><span class="line">cin&gt;&gt;N;</span><br><span class="line"><span class="keyword">if</span>(N&lt;=<span class="number">0</span>)&#123;     <span class="comment">//输入为零或负数，直接退出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> b[N]=&#123;<span class="number">0</span>&#125;;   <span class="comment">//用于存储数组每一个数的重复的次数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(k&lt;N)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==a[k])&#123;</span><br><span class="line">b[k]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max=b[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;  <span class="comment">//找到出现数组中出现次数最多的数组下标</span></span><br><span class="line"><span class="keyword">if</span>(b[i]&gt;b[<span class="number">0</span>])&#123;</span><br><span class="line">max=b[i];</span><br><span class="line">index=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;a[index];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分解质因数</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法提高-分解质因数"><a href="#试题-算法提高-分解质因数" class="headerlink" title="试题 算法提高 分解质因数"></a>试题 算法提高 分解质因数</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：256.0MB<br>问题描述<br>　　给定一个正整数n，尝试对其分解质因数<br>输入格式<br>　　仅一行，一个正整数，表示待分解的质因数<br>输出格式<br>　　仅一行，从小到大依次输出其质因数，相邻的数用空格隔开<br>样例输入<br>100<br>样例输出<br>2 2 5 5<br>数据规模和约定<br>　　n&lt;=2147483647</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, n2;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    n2 = n;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;                <span class="comment">//小于2的数不合法，若n为质数则输出它本身</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= n2; i++)        <span class="comment">//根号n复杂度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (n2%i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n2 = n2 / i;</span><br><span class="line">            cout &lt;&lt; i;</span><br><span class="line">            <span class="keyword">if</span> (n2 != <span class="number">1</span>)cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n2 != <span class="number">1</span>)    cout &lt;&lt; n2;        <span class="comment">//当n为质数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除数组零元素</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E9%9B%B6%E5%85%83%E7%B4%A0/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E9%9B%B6%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-删除数组零元素"><a href="#试题-算法训练-删除数组零元素" class="headerlink" title="试题 算法训练 删除数组零元素"></a>试题 算法训练 删除数组零元素</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：512.0MB<br>从键盘读入n个整数放入数组中，编写函数CompactIntegers，删除数组中所有值为0的元素，其后元素向数组首端移动。注意，CompactIntegers函数需要接受数组及其元素个数作为参数，函数返回值应为删除操作执行后数组的新元素个数。输出删除后数组中元素的个数并依次输出数组元素。<br>样例输入: （输入格式说明：5为输入数据的个数，3 4 0 0 2 是以空格隔开的5个整数）<br>5<br>3 4 0 0 2<br>样例输出:（输出格式说明：3为非零数据的个数，3 4 2 是以空格隔开的3个非零整数）<br>3<br>3 4 2<br>样例输入:<br>7<br>0 0 7 0 0 9 0<br>样例输出:<br>2<br>7 9<br>样例输入:<br>3<br>0 0 0<br>样例输出:<br>0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompactIntergers</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123;  <span class="comment">//这里我直接用void 返回类型的函数，直接在函数中输出结果</span></span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">k++;</span><br><span class="line">b[index]=a[i];</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k!=<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">cout&lt;&lt;b[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;       <span class="comment">//元素个数</span></span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">500</span>];  <span class="comment">//数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CompactIntergers</span>(a,n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态数组使用</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-动态数组使用"><a href="#试题-算法训练-动态数组使用" class="headerlink" title="试题 算法训练 动态数组使用"></a>试题 算法训练 动态数组使用</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：512.0MB<br>从键盘读入n个整数，使用动态数组存储所读入的整数，并计算它们的和与平均值分别输出。要求尽可能使用函数实现程序代码。平均值为小数的只保留其整数部分。<br>样例输入:<br>5<br>3 4 0 0 2<br>样例输出:<br>9  1<br>样例输入:<br>7<br>3 2 7 5 2 9 1<br>样例输出:<br>29  4</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态数组使用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;b;</span><br><span class="line">a.<span class="built_in">push_back</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="built_in">accumulate</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">0</span>); <span class="comment">//vector元素求和函数，必须引入头文件mumeric</span></span><br><span class="line"><span class="keyword">float</span> average=sum/n;</span><br><span class="line">cout&lt;&lt;sum&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;average;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀表达式</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-前缀表达式"><a href="#试题-算法训练-前缀表达式" class="headerlink" title="试题 算法训练 前缀表达式"></a>试题 算法训练 前缀表达式</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：512.0MB<br>问题描述<br>　　编写一个程序，以字符串方式输入一个前缀表达式，然后计算它的值。输入格式为：“运算符 对象1 对象2”，其中，运算符为“+”（加法）、“-”（减法）、“*”（乘法）或“/”（除法），运算对象为不超过10的整数，它们之间用一个空格隔开。要求：对于加、减、乘、除这四种运算，分别设计相应的函数来实现。<br>　　输入格式：输入只有一行，即一个前缀表达式字符串。<br>　　输出格式：输出相应的计算结果（如果是除法，直接采用c语言的“/”运算符，结果为整数）。<br>　　输入输出样例<br>样例输入</p><ul><li>5 2<br>样例输出<br>7<br>第一次写的是这样，没有按照题目做法来，直接按照自己的想法来的</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mutiply</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Except</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Substruct</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string a;</span><br><span class="line"><span class="keyword">int</span> b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="built_in">Add</span>(b,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="built_in">Substruct</span>(b,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="built_in">Mutiply</span>(b,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="built_in">Except</span>(b,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以更简单，改完之后cpu使用时间0ms</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string a;</span><br><span class="line"><span class="keyword">int</span> b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line">cout&lt;&lt;b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line">cout&lt;&lt;b-c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line">cout&lt;&lt;b*c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">cout&lt;&lt;b/c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我这种做法并不是本题要求的做法，看看就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十进制转2进制输出</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-十进制转2进制输出"><a href="#试题-算法训练-十进制转2进制输出" class="headerlink" title="试题 算法训练 十进制转2进制输出"></a>试题 算法训练 十进制转2进制输出</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：256.0MB<br>问题描述<br>　　编写递归函数，实现将一个十进制的正整数以二进制的形式输出。<br>　　注：不考虑符号位，仅从二进制数不为0的最高位开始输出。<br>输入格式<br>　　一个十进制正整数<br>输出格式<br>　　该整数对应的二进制数<br>样例输入<br>一个满足题目要求的输入范例。<br>例：<br>96<br>样例输出<br>与上面的样例输入对应的输出。<br>例：<br>1100000<br>数据规模和约定<br>　　输入为正整数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transform</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">Transform</span>(n/<span class="number">2</span>);</span><br><span class="line">cout&lt;&lt;n%<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line"><span class="built_in">Transform</span>(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形显示</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-图形显示"><a href="#试题-算法训练-图形显示" class="headerlink" title="试题 算法训练 图形显示"></a>试题 算法训练 图形显示</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：512.0MB<br>问题描述<br>　　编写一个程序，首先输入一个整数，例如5，然后在屏幕上显示如下的图形（5表示行数）：</p><hr><hr><hr><p>　　* *<br>　　*</p><p>这里要注意最后一行，以及*中间有空格</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=a-i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;* &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i!=a<span class="number">-1</span>)&#123;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大小写转换</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><p>资源限制<br>时间限制：1.0s   内存限制：512.0MB<br>问题描述<br>　　编写一个程序，输入一个字符串（长度不超过20），然后把这个字符串内的每一个字符进行大小写变换，即将大写字母变成小写，小写字母变成大写，然后把这个新的字符串输出。<br>　　输入格式：输入一个字符串，而且这个字符串当中只包含英文字母，不包含其他类型的字符，也没有空格。<br>　　输出格式：输出经过转换后的字符串。<br>输入输出样例<br>样例输入<br>AeDb<br>样例输出<br>aEdB</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大小写转换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string a;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;=<span class="number">65</span>&amp;&amp;a[i]&lt;=<span class="number">90</span>)&#123;</span><br><span class="line">a[i]+=<span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;=<span class="number">97</span>&amp;&amp;a[i]&lt;=<span class="number">122</span>)&#123;</span><br><span class="line">a[i]-=<span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串的操作</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法提高-字符串的操作"><a href="#试题-算法提高-字符串的操作" class="headerlink" title="试题 算法提高 字符串的操作"></a>试题 算法提高 字符串的操作</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：256.0MB<br>问题描述<br>　　给出一个字符串S，然后给出q条指令，分别有4种：</p><p>　　1. Append str<br>　　表示在S的最后追加一个字符串str。<br>　　例：<br>　　原字符串：ABCDE<br>　　执行 Append FGHIJ 后<br>　　字符串变为：ABCDEFGHIJ</p><p>　　2. Insert x str<br>　　表示在位置x处插入一个字符串str。（输入保证0&lt;x&lt;=当前字符串长度）<br>　　例：<br>　　原字符串：ABCGHIJ<br>　　执行 Insert 4 DEF 后<br>　　字符串变为：ABCDEFGHIJ</p><p>　　3. Swap a b c d<br>　　表示交换从第a位到第b位的字符串与从第c位到第d位的字符串。（输入保证0&lt;a&lt;b&lt;c&lt;d&lt;=当前字符串长度）<br>　　例：<br>　　原字符串：ABGHIFCDEJ<br>　　执行 Swap 3 5 7 9后<br>　　字符串变为：ABCDEFGHIJ</p><p>　　4. Reverse a b<br>　　表示将从第a位到第b位的字符串反转。（输入保证0&lt;a&lt;b&lt;=当前字符串长度）<br>　　例：<br>　　原字符串：ABGFEDCHIJ<br>　　执行 Reverse 3 7 后<br>　　字符串变为：ABCDEFGHIJ</p><p>　　最后输出按顺序执行完指令后的字符串。<br>输入格式<br>　　输入第一行包含字符串S，第二行包含一个整数q，接下来q行分别为q个指令。<br>输出格式<br>　　输出为1行，为按顺序执行完输入指令后的字符串。<br>样例输入<br>My<br>5<br>Append Hello<br>Insert 3 dlroW<br>Reverse 3 7<br>Swap 3 7 8 12<br>Swap 1 2 3 7<br>样例输出<br>HelloMyWorld<br>样例说明<br>　　原字符串：My<br>　　执行 Append Hello 后：MyHello<br>　　执行 Insert 3 dlroW 后：MydlroWHello<br>　　执行 Reverse 3 7 后：MyWorldHello<br>　　执行 Swap 3 7 8 12 后：MyHelloWorld<br>　　执行 Swap 1 2 3 7 后：HelloMyWorld<br>数据规模和约定<br>　　对于30%的数据，q=1；</p><p>　　对于70%的数据，如有Swap指令，Swap指令中b-a=d-c；</p><p>　　对于100%的数据，最终字符串长度不大于40000，1&lt;=q&lt;=150<br>　　<br><strong>PS:注意要对字符串本身进行操作，而不是截取字符串出来操作，这样是不会改变输出结果的。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string S;</span><br><span class="line"><span class="keyword">int</span> Qn;</span><br><span class="line">cin&gt;&gt;S&gt;&gt;Qn;</span><br><span class="line">string command[Qn];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Qn;i++)&#123;</span><br><span class="line">cin&gt;&gt;command[i];</span><br><span class="line"><span class="keyword">if</span>(command[i]==<span class="string">&quot;Append&quot;</span>)&#123;</span><br><span class="line">string str1;</span><br><span class="line">cin&gt;&gt;str1;</span><br><span class="line">S.<span class="built_in">append</span>(str1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(command[i]==<span class="string">&quot;Insert&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line">string str2;</span><br><span class="line">cin&gt;&gt;index&gt;&gt;str2;</span><br><span class="line">S.<span class="built_in">insert</span>(index<span class="number">-1</span>,str2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(command[i]==<span class="string">&quot;Swap&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">string s1,s2,s3,s4,s5;</span><br><span class="line">s1=S.<span class="built_in">substr</span>(<span class="number">0</span>,a<span class="number">-1</span>);</span><br><span class="line">s2=S.<span class="built_in">substr</span>(a<span class="number">-1</span>,b-a+<span class="number">1</span>);</span><br><span class="line">s3=S.<span class="built_in">substr</span>(b,c-b<span class="number">-1</span>);</span><br><span class="line">s4=S.<span class="built_in">substr</span>(c<span class="number">-1</span>,d-c+<span class="number">1</span>);</span><br><span class="line">s5=S.<span class="built_in">substr</span>(d,S.<span class="built_in">length</span>()-d);</span><br><span class="line">S=s1+s4+s3+s2+s5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(command[i]==<span class="string">&quot;Reverse&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> e,f;</span><br><span class="line">cin&gt;&gt;e&gt;&gt;f;</span><br><span class="line">string s1,s2,s3;</span><br><span class="line">s1=S.<span class="built_in">substr</span>(<span class="number">0</span>,e<span class="number">-1</span>);</span><br><span class="line">s2=S.<span class="built_in">substr</span>(e<span class="number">-1</span>,f-e+<span class="number">1</span>);</span><br><span class="line">s3=S.<span class="built_in">substr</span>(f,S.<span class="built_in">length</span>()-f);</span><br><span class="line">            <span class="built_in">reverse</span>(s2.<span class="built_in">begin</span>(),s2.<span class="built_in">end</span>());</span><br><span class="line">            S=s1+s2+s3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;S;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找数组中最大值</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-寻找数组中最大值"><a href="#试题-算法训练-寻找数组中最大值" class="headerlink" title="试题 算法训练 寻找数组中最大值"></a>试题 算法训练 寻找数组中最大值</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：512.0MB<br>问题描述<br>　　对于给定整数数组a[],寻找其中最大值，并返回下标。<br>输入格式<br>　　整数数组a[],数组元素个数小于1等于100。输出数据分作两行：第一行只有一个数，表示数组元素个数；第二行为数组的各个元素。<br>输出格式<br>　　输出最大值，及其下标<br>样例输入<br>3<br>3 2 1</p><p>样例输出</p><p>3 0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">cin&gt;&gt;num;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max=a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;=max)&#123;</span><br><span class="line">max=a[i];</span><br><span class="line">index=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;max&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;index;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-排序"><a href="#试题-算法训练-排序" class="headerlink" title="试题 算法训练 排序"></a>试题 算法训练 排序</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：512.0MB<br>问题描述<br>　　编写一个程序，输入3个整数，然后程序将对这三个整数按照从大到小进行排列。<br>　　输入格式：输入只有一行，即三个整数，中间用空格隔开。<br>　　输出格式：输出只有一行，即排序后的结果。<br>　　输入输出样例<br>样例输入<br>9 2 30<br>样例输出<br>30 9 2</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">cin&gt;&gt;b;</span><br><span class="line">a.<span class="built_in">push_back</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字分组</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%88%86%E7%BB%84/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%88%86%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法提高-数字分组"><a href="#试题-算法提高-数字分组" class="headerlink" title="试题 算法提高 数字分组"></a>试题 算法提高 数字分组</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：256.0MB<br>问题描述<br>　　输入任意10个浮点数，根据它们的聚集程度划分为3组，输出每一组的平均值。<br>　　提供老师上课讲的一种思路：将10个数字进行在数轴上排序，然后计算每两个点间的距离，在所有的距离中选取两个最大距离处断开，这样就把10个数字分为了3组。<br>　　本题难度较大，如果深入讨论会比较复杂，大家可以只考虑如下面样例所示的分组情况非常简单的情况，只要简单情况能够成功计算，本题就能得分。</p><p>　　另外，本题内容有些超前，推荐大家自学一下数组那一章中第一节一维数组，然后使用一维数组来做。排序算法可以参考trustie平台上传的冒泡排序法参考资料。<br>输入格式<br>　　十个待输入的浮点数，使用空格隔开<br>输出格式<br>　　三组数的平均数，每输出一个需要换行<br>样例输入<br>一个满足题目要求的输入范例。<br>例1：<br>50.4 51.3 52.3 9.5 10.4 11.6 19.1 20.8 21.9 49.6</p><p>例2：<br>8.6 7.4 3.5 17.9 19.1 18.5 37.6 40.4 38.5 40.0<br>样例输出<br>与上面的样例输入对应的输出。<br>例1：<br>10.5<br>20.6<br>50.9</p><p>例2:<br>6.5<br>18.5<br>39.125<br>数据规模和约定<br>　　仅考虑如样例一样简单情况、分组明显的输入</p><p><strong>ps：将两数之间的距离存在两个数组中，一个数组进行操作找出两个最大的距离，一个数组用来找到对应的下标。</strong>　　</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">float</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>-i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">float</span> temp=a[j+<span class="number">1</span>];</span><br><span class="line">a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">a[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    for(int i=0;i&lt;10;i++)&#123;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">float</span> b[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">float</span> c[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">b[i]=a[i+<span class="number">1</span>]-a[i];</span><br><span class="line">c[i]=b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>-i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b[j]&gt;b[j+<span class="number">1</span>])</span><br><span class="line"><span class="built_in">swap</span>(b[j],b[j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">float</span>  index1,index2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i]==b[<span class="number">8</span>])</span><br><span class="line">index1=i;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c[i]==b[<span class="number">7</span>])</span><br><span class="line">index2=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(index1&gt;=index2)</span><br><span class="line"><span class="built_in">swap</span>(index1,index2);</span><br><span class="line"><span class="keyword">double</span> sum1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> sum2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> sum3=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=index1;i++)&#123;</span><br><span class="line">sum1+=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=index1+<span class="number">1</span>;i&lt;=index2;i++)&#123;</span><br><span class="line">sum2+=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=index2+<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">sum3+=a[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;sum1/(index1+<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;sum2/(index2-index1)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;sum3/(<span class="number">10</span>-index2<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章翻转</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E6%96%87%E7%AB%A0%E7%BF%BB%E8%BD%AC/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E6%96%87%E7%AB%A0%E7%BF%BB%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-文章翻转"><a href="#试题-算法训练-文章翻转" class="headerlink" title="试题 算法训练 文章翻转"></a>试题 算法训练 文章翻转</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：128.0MB<br>问题描述<br>　　输入一段英文，不含标点，将这一段英文以单词为单位倒序输出<br>输入格式<br>　　一段英文（段内不含换行），以换行符结尾。<br>输出格式<br>　　一段英文（段内不含换行），以换行符结尾。<br>样例输入<br>aab TTR bbc loV DDE Znr CCD<br>样例输出<br>CCD Znr DDE loV bbc TTR aab<br>数据规模和约定<br>　　60%的数据保证单词长度不超过20，字符长度不超过10^3<br>　　100%的数据保证单词长度不超过10^5，字符长度不超过10^6</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string A;</span><br><span class="line"><span class="built_in">getline</span>(cin,A);</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=A.<span class="built_in">length</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">l++;</span><br><span class="line"><span class="keyword">if</span>(A[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">cout&lt;&lt;A.<span class="built_in">substr</span>(i+<span class="number">1</span>,l)&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">l=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;A.<span class="built_in">substr</span>(<span class="number">0</span>,l);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大质因数</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E8%B4%A8%E5%9B%A0%E6%95%B0/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E8%B4%A8%E5%9B%A0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-最大质因数"><a href="#试题-算法训练-最大质因数" class="headerlink" title="试题 算法训练 最大质因数"></a>试题 算法训练 最大质因数</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：256.0MB<br>问题描述<br>　　给出N个数字，求出有最大的最大质因数的那个数<br>输入格式<br>　　第一行：一个整数N。<br>　　接下来的N行，每行一个整数A_i，表示给出的那N个数字。<br>输出格式<br>　　第一行：一个整数，拥有最大的最大质因数的那个数。<br>样例输入<br>4<br>36<br>38<br>40<br>42<br>样例输出<br>38<br>数据规模和约定<br>　　60%的数据满足：N&lt;=100<br>　　100%的数据满足：N&lt;=2500,A_i&lt;=20000　　</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (n%i == <span class="number">0</span>) &#123;</span><br><span class="line">n /= i;</span><br><span class="line">res = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max=<span class="built_in">GetMaxPrime</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">GetMaxPrime</span>(a[j])&gt;max)&#123;</span><br><span class="line">max=<span class="built_in">GetMaxPrime</span>(a[j]);</span><br><span class="line">index=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;a[index];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小乘积(基本型)</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E4%B9%98%E7%A7%AF%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%9E%8B%EF%BC%89/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E4%B9%98%E7%A7%AF%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%9E%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-最小乘积-基本型"><a href="#试题-算法训练-最小乘积-基本型" class="headerlink" title="试题 算法训练 最小乘积(基本型)"></a>试题 算法训练 最小乘积(基本型)</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：512.0MB<br>问题描述<br>　　给两组数，各n个。<br>　　请调整每组数的排列顺序，使得两组数据相同下标元素对应相乘，然后相加的和最小。要求程序输出这个最小值。<br>　　例如两组数分别为:1 3　　-5和-2 4 1</p><p>　　那么对应乘积取和的最小值应为：<br>　　(-5) * 4 + 3 * (-2) + 1 * 1 = -25<br>输入格式<br>　　第一个行一个数T表示数据组数。后面每组数据，先读入一个n，接下来两行每行n个数，每个数的绝对值小于等于1000。<br>　　n&lt;=8,T&lt;=1000<br>输出格式<br>　　一个数表示答案。<br>样例输入<br>2<br>3<br>1 3 -5<br>-2 4 1<br>5<br>1 2 3 4 5<br>1 0 1 0 1</p><p>样例输出</p><p>-25<br>6</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,i,n,sum,a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            cin&gt;&gt;b[i];</span><br><span class="line">        <span class="built_in">sort</span>(a,a+n);</span><br><span class="line">        <span class="built_in">sort</span>(b,b+n);</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            sum+=a[i]*b[n<span class="number">-1</span>-i];</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,i,n,sum,a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            cin&gt;&gt;b[i];</span><br><span class="line">        <span class="built_in">sort</span>(a,a+n);</span><br><span class="line">        <span class="built_in">sort</span>(b,b+n,cmp);</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            sum+=a[i]*b[i];</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sort （a,a+n） 默认为从小到大排列<br>sort（a,a+n,cmp）  第三个参数是控制数组排列方式，是按从小到大还是从大到小排列<br>添加另一个函数<br>bool cmp(int a,int b)<br>{<br>    return a&gt;b;<br>}            则sort函数是按照从大到小的顺序排列的。</p>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求1000以内的完数</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E6%B1%821000%E4%BB%A5%E5%86%85%E7%9A%84%E5%AE%8C%E6%95%B0/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E6%B1%821000%E4%BB%A5%E5%86%85%E7%9A%84%E5%AE%8C%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-求1000以内的完数"><a href="#试题-算法训练-求1000以内的完数" class="headerlink" title="试题 算法训练 求1000以内的完数"></a>试题 算法训练 求1000以内的完数</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：256.0MB<br>问题描述<br>　　如果一个数恰好等于它的所有因子（包括1但不包括自身）之和，则称之为“完数”。例如6的因子是1，2，3，且6=1+2+3，因此6是完数。编写程序找出1000之内的所有完数。注意1不是完数。<br>输入格式<br>　　无<br>输出格式<br>　　如有多个完数，则分行输出，每行输出一个完数。（注意，不要输出其他任何多余字符）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</span><br><span class="line">    sum+=j;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==i)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200916113114623.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵乘法</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>试题 算法训练 矩阵乘法</p><p>资源限制<br>时间限制：1.0s   内存限制：512.0MB<br>问题描述<br>　　输入两个矩阵，分别是m<em>s，s</em>n大小。输出两个矩阵相乘的结果。<br>输入格式<br>　　第一行，空格隔开的三个正整数m,s,n（均不超过200）。<br>　　接下来m行，每行s个空格隔开的整数，表示矩阵A（i，j）。<br>　　接下来s行，每行n个空格隔开的整数，表示矩阵B（i，j）。<br>输出格式<br>　　m行，每行n个空格隔开的整数，输出相乘後的矩阵C（i，j）的值。<br>样例输入<br>2 3 2<br>1 0 -1<br>1 1 -3<br>0 3<br>1 2<br>3 1<br>样例输出<br>-3 2<br>-8 2</p><p>提示<br>矩阵C应该是m行n列，其中C(i,j)等于矩阵A第i行行向量与矩阵B第j列列向量的内积。<br>例如样例中C(1,1)=(1,0,-1)<em>(0,1,3) = 1 * 0 +0</em>1+(-1)*3=-3</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> m,s,n;</span><br><span class="line">cin&gt;&gt;m&gt;&gt;s&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s;j++)&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">cin&gt;&gt;b[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;s;k++)&#123;   <span class="comment">//连加用for循环表示</span></span><br><span class="line">  c[i][j]+=(a[i][k]*b[k][j]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            cout&lt;&lt;c[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数问题</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法提高-计数问题"><a href="#试题-算法提高-计数问题" class="headerlink" title="试题 算法提高 计数问题"></a>试题 算法提高 计数问题</h2><p>   资源限制<br>时间限制：1.0s   内存限制：128.0MB<br>问题描述<br>　　试计算在区间 1 到 n 的所有整数中，数字 x（0 ≤ x ≤ 9）共出现了多少次？例如，在 1到 11 中，即在 1、2、3、4、5、6、7、8、9、10、11 中，数字 1 出现了 4 次。<br>输入格式<br>　　输入文件名为 count.in。<br>　　输入共 1 行，包含 2 个整数 n、x，之间用一个空格隔开。<br>输出格式<br>　　输出文件名为 count.out。<br>　　输出共 1 行，包含一个整数，表示 x 出现的次数。<br>输入输出样例<br>count.in<br>11 1<br>count.out<br>4<br>数据说明<br>　　对于 100%的数据，1≤ n ≤ 1,000,000，0 ≤ x ≤ 9。　　</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Tongji</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(N%<span class="number">10</span>==x) k++;</span><br><span class="line">            N/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">sum+=<span class="built_in">Tongji</span>(i,x);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;sum;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>送分啦</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E9%80%81%E5%88%86%E5%95%A6/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E9%80%81%E5%88%86%E5%95%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-送分啦"><a href="#试题-算法训练-送分啦" class="headerlink" title="试题 算法训练 送分啦"></a>试题 算法训练 送分啦</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：512.0MB<br>问题描述<br>　　这题想得分吗？想，请输出“yes”；不想，请输出“no”。<br>输出格式<br>　　输出包括一行，为“yes”或“no”。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//送分啦</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">rand</span>();</span><br><span class="line"><span class="keyword">if</span>(a%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;yes&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;no&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>首字母变大写</title>
      <link href="2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E9%A6%96%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%86%99/"/>
      <url>2019/12/06/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AE%AD%E7%BB%83%E2%80%94%E2%80%94%E9%A6%96%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h2 id="试题-算法训练-首字母变大写"><a href="#试题-算法训练-首字母变大写" class="headerlink" title="试题 算法训练 首字母变大写"></a>试题 算法训练 首字母变大写</h2><p>​<br>资源限制<br>时间限制：1.0s   内存限制：512.0MB<br>问题描述<br>　　对一个字符串中的所有单词，如果单词的首字母不是大写字母，则把单词的首字母变成大写字母。在字符串中，单词之间通过空白符分隔，空白符包括：空格(‘ ‘)、制表符(‘\t’)、回车符(‘\r’)、换行符(‘\n’)<br>输入格式<br>　　输入一行：待处理的字符串（长度小于80）<br>输出格式<br>　　输出一行：转换后的字符串。<br>样例输入<br>if so, you already have a google account. you can sign in on the right.<br>样例输出<br>If So, You Already Have A Google Account. You Can Sign In On The Right.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string A;</span><br><span class="line"><span class="built_in">getline</span>(cin,A);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">length</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i]==<span class="number">32</span>||A[i]==<span class="number">44</span>||A[i]==<span class="number">46</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i+<span class="number">1</span>]&gt;=<span class="number">97</span>&amp;&amp;i!=A.<span class="built_in">length</span>())&#123;</span><br><span class="line">A[i+<span class="number">1</span>]-=<span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(A[<span class="number">0</span>]&gt;=<span class="number">97</span>)&#123;</span><br><span class="line">A[<span class="number">0</span>]-=<span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;A;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200916100533722.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短作业（进程）优先调度算法</title>
      <link href="2019/10/27/SJF%E7%9F%AD%E4%BD%9C%E4%B8%9A%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
      <url>2019/10/27/SJF%E7%9F%AD%E4%BD%9C%E4%B8%9A%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="短作业（进程）优先调度算法"><a href="#短作业（进程）优先调度算法" class="headerlink" title="短作业（进程）优先调度算法"></a>短作业（进程）优先调度算法</h1><ol><li>短作业（进程）优先（Shortest Job First，SJF或Shortest Process  Next，SPN）是指对短作业或短进程优先调度的算法。该算法可分别用于作业调度和进程调度。该算法的设计目标是改进FCFS算法，减少作业或进程的平均周转时间。</li><li>SJF算法要求作业在开始执行之前预计作业的执行时间，对预计执行时间短的作业优先调入内存。</li><li>SJF算法和FCFS算法进行比较，SJF有以下优点：<pre><code>      1）改善了平均周转时间和平均带权周转时间，缩短了等待时间；      2）有利于提高系统的吞吐量。 同样具有以下几个缺点： 1）对长作业或进程不利； 2）该算法没有考虑作业或进程的紧迫程度，因而不能保证紧迫的作业或进程得到及时处理或相应； 3）由于作业或进程的执行时间是用户估计的，因而准确性不高，从而影响调度性能； 4）如果系统中持续有更短作业或最短进程出现，可能导致长作业或进程被饿死，即永远得不到执行。 </code></pre></li></ol><h3 id="SJF算法的具体实现"><a href="#SJF算法的具体实现" class="headerlink" title="SJF算法的具体实现"></a>SJF算法的具体实现</h3><ol><li><p>SJF的代码（个人的思想不同所以写出来的代码也不一样，仅供参考学习）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SJF</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;SJF调度算法:&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">int</span> i,j,min_time,index;</span><br><span class="line">    <span class="keyword">int</span>  last_finishedPCB_index;    <span class="comment">//记录上一次已经运行的进程的数组下标</span></span><br><span class="line">   </span><br><span class="line">     <span class="comment">// 运行第一个到达的进程  得到它的完成时间、周转时间等,并设置为已访问</span></span><br><span class="line"> pcb[<span class="number">0</span>].finish_time=pcb[<span class="number">0</span>].arrive_time+pcb[<span class="number">0</span>].run_time;</span><br><span class="line"> pcb[<span class="number">0</span>].zhouzhuan_time=pcb[<span class="number">0</span>].finish_time-pcb[<span class="number">0</span>].arrive_time;</span><br><span class="line"> pcb[<span class="number">0</span>].daiquan_time=(<span class="keyword">float</span>)pcb[<span class="number">0</span>].zhouzhuan_time/pcb[<span class="number">0</span>].run_time;</span><br><span class="line">      pcb[<span class="number">0</span>].finished=<span class="literal">true</span>;</span><br><span class="line">     last_finishedPCB_index=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">     <span class="comment">//下面在剩下的进程中循环找出运行时间最小的进程，</span></span><br><span class="line">     <span class="comment">//计算它的完成时间、周转时间等，并设置为已访问。 </span></span><br><span class="line"> <span class="comment">//先找出没有访问过的运行时间最小的进程的下标</span></span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">   &#123;     </span><br><span class="line">    index=<span class="number">-1</span>;</span><br><span class="line">    min_time=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(min_time&gt;pcb[j].run_time&amp;&amp;pcb[j].finished==<span class="literal">false</span>&amp;&amp;pcb[j].arrive_time&lt;=pcb[last_finishedPCB_index].finish_time)</span><br><span class="line">&#123;</span><br><span class="line">min_time=pcb[j].run_time;</span><br><span class="line">index=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pcb[index].arrive_time&lt;=pcb[last_finishedPCB_index].finish_time)</span><br><span class="line">&#123;</span><br><span class="line">pcb[index].finish_time=pcb[last_finishedPCB_index].finish_time+pcb[index].run_time;</span><br><span class="line">pcb[index].zhouzhuan_time=pcb[index].finish_time-pcb[index].arrive_time;</span><br><span class="line">pcb[index].daiquan_time=(<span class="keyword">float</span>)pcb[index].zhouzhuan_time/pcb[index].run_time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pcb[index].arrive_time&gt;pcb[last_finishedPCB_index].finish_time)</span><br><span class="line">&#123;</span><br><span class="line">pcb[index].finish_time=pcb[index].arrive_time+pcb[index].run_time;</span><br><span class="line">pcb[index].zhouzhuan_time=pcb[index].run_time;</span><br><span class="line">pcb[index].daiquan_time=(<span class="keyword">float</span>)pcb[index].zhouzhuan_time/pcb[index].run_time; </span><br><span class="line">&#125;</span><br><span class="line">pcb[index].finished =<span class="literal">true</span>;</span><br><span class="line">last_finishedPCB_index=index;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">sumzhouzhuantime+=pcb[i].zhouzhuan_time;</span><br><span class="line">sumdaiquanzhouzhuantime+=pcb[i].daiquan_time;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先计算第一个进程的各项时间，将时间全部求解出来。在结构体里设置一个标志，初始化将进程的标志全部设为false，访问过的进程设为ture，在下一次选择运行时间最短的进程时不访问它。在选择最短进程时，优先访问运行时间最小的进程，并比较到达时间与上一个进程完成时间，如果小于，则完成时间等于运行时间加上一个进程的完成时间；如果下一个进程的到达时间大于上一个进程的完成时间，则此进程的完成时间为到达时间加运行时间。</p></li><li><p>考虑到某进程的运行时间最短，但它还没有到达的情况，设计一个循环限制条件为程序的到达时间小于上一个进程的完成时间，在剩下的进程里面找到运行时间最短的进程，将此进程设置为index。这时计算时间有两种情况：<br>1）下一个进程的到达时间小于上一个进程的完成时间，则各时间正常计算。<br>2）下一个进程的到达时间大于上一个进程的完成时间，则完成时间等于到达时间加运行时间，周转时间等于运行时间。</p></li></ol><h2 id="以下是我的输出结果："><a href="#以下是我的输出结果：" class="headerlink" title="以下是我的输出结果："></a>以下是我的输出结果：</h2><p>  <img src="https://img-blog.csdnimg.cn/20191027233824320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Mjg1NTUx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20191027233712603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Mjg1NTUx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在SJF中的排序算法，if(min_time&gt;pcb[j].run_time&amp;&amp;pcb[j].finished==false&amp;&amp;pcb[j].arrive_time&lt;=pcb[last_finishedPCB_index].finish_time)，这样其实并没有将最后一个进程考虑进去，导致最后一个进程的时间可能会输出为0。</p><p> 总结：以上便是我对此算法的粗略理解，仅供参考。以后会不断改进以及编辑出更优秀的博客出来！！！</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 作业调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统:FCFS调度算法简单实现</title>
      <link href="2019/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9AFCFS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%88c++)/"/>
      <url>2019/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9AFCFS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%88c++)/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="操作系统：FCFS调度算法简单实现"><a href="#操作系统：FCFS调度算法简单实现" class="headerlink" title="操作系统：FCFS调度算法简单实现"></a>操作系统：FCFS调度算法简单实现</h2><hr><ol><li>由于本人（小白一个）一直以来想要写博客，加上最近学习操作系统，为了巩固自己的学习成果以及加深印象，现在决定开始写博客，可以说这是我的第一篇博客。</li><li>这篇文章主要描述的计算机操作系统的FCFS(先来先服务）的调度算法，可以用在进程调度和作业调度中。它的基本思想是按进程或作业到达的时间先后顺序进行调度。</li><li>下面就详细讲下本小白实现此简单算法的基本功能，过程以及思想。<br>   基本功能：<br>   1、输出每个进程的调度时间表<pre><code>   2、上一个进程结束前，下一个进程还没有到达，程序计算周转时间仍然正确   3、进程可以不按到达时间大小排列输入，输出的调度时间表依然正确</code></pre></li></ol><hr><p>​     </p><p>   首先我们得知道进程是怎么构造的，在这篇文章中我是以结构体数组的形式来构造多个进程，结构体里的各个成分分别表示进程的基本信息，数组的大小为常数 5。<br>       以下是我的进程具体构造：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">PCB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">char</span> name[<span class="number">8</span>];     <span class="comment">//进程名称</span></span><br><span class="line">     <span class="keyword">int</span>  arrive_time;  <span class="comment">//到达时间</span></span><br><span class="line">     <span class="keyword">int</span>  run_time;   <span class="comment">//运行时间</span></span><br><span class="line">     <span class="keyword">int</span> finish_time;    <span class="comment">//完成时间</span></span><br><span class="line">     <span class="keyword">int</span>  zhouzhuan_time;    <span class="comment">//周转时间</span></span><br><span class="line">     <span class="keyword">float</span> daiquan_time;      <span class="comment">// 带权周转时间</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  N  5</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCB</span> <span class="title">pcb</span>[<span class="title">N</span>],<span class="title">temp</span>;</span></span><br></pre></td></tr></table></figure><p>输入进程功能：自定义一个输入函数，设置for循环语句，循环输入，很容易实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;--------------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;             FCFS调度算法     &quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;      输入五个进程信息:&quot;</span>&lt;&lt;endl;</span><br><span class="line"> <span class="keyword">for</span> ( i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入进程名:\n&quot;</span> );</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,pcb[i].name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入到达时间:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pcb[i].arrive_time);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入要运行时间:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pcb[i].run_time);  </span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;各进程:&quot;</span>&lt;&lt;endl;</span><br><span class="line"> <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"> &#123;    <span class="built_in">printf</span>(<span class="string">&quot;%s    &quot;</span>,pcb[i].name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d    &quot;</span>,pcb[i].arrive_time);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,pcb[i].run_time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现进程无需按到达时间先后输入，则需要将输入的进程按照到达时间先后进行排序，然后计算各个进程的各个时间。这里我设置了一个排序自定义函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span><span class="comment">//按照到达时间对进程进行排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;N;j++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(pcb[i].arrive_time&gt;pcb[j].arrive_time)</span><br><span class="line">   &#123;</span><br><span class="line">    temp=pcb[i];</span><br><span class="line">    pcb[i]=pcb[j];</span><br><span class="line">    pcb[j]=temp;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出调度时间顺序时间表则设置一个进程输出函数，具体实现如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;FCFS调度算法:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    pcb[<span class="number">0</span>].finish_time=pcb[<span class="number">0</span>].arrive_time+pcb[<span class="number">0</span>].run_time;</span><br><span class="line">     pcb[<span class="number">0</span>].zhouzhuan_time=pcb[<span class="number">0</span>].finish_time-pcb[<span class="number">0</span>].arrive_time;</span><br><span class="line">pcb[<span class="number">0</span>].daiquan_time=(<span class="keyword">float</span>)pcb[<span class="number">0</span>].zhouzhuan_time/pcb[<span class="number">0</span>].run_time;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">if</span>(pcb[i].arrive_time&gt;pcb[i<span class="number">-1</span>].finish_time)  <span class="comment">//如果下一个进程在上一个进程完成后到达，则用以下算法计算调度时间</span></span><br><span class="line">&#123;</span><br><span class="line">              pcb[i].finish_time=pcb[i].arrive_time+pcb[i].run_time;</span><br><span class="line">              pcb[i].zhouzhuan_time=pcb[i].run_time;</span><br><span class="line">              pcb[i].daiquan_time=(<span class="keyword">float</span>)pcb[i].zhouzhuan_time/pcb[i].run_time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>       <span class="comment">//下一个进程在上一个进程结束前就已经到达</span></span><br><span class="line">&#123;</span><br><span class="line">            pcb[i].finish_time=pcb[i<span class="number">-1</span>].finish_time+pcb[i].run_time;</span><br><span class="line">            pcb[i].zhouzhuan_time=pcb[i].finish_time-pcb[i].arrive_time;</span><br><span class="line">pcb[i].daiquan_time=(<span class="keyword">float</span>)pcb[i].zhouzhuan_time/pcb[i].run_time;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">sumzhouzhuantime+=pcb[i].zhouzhuan_time;</span><br><span class="line">sumdaiquanzhouzhuantime+=pcb[i].daiquan_time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程名   到达时间  运行时间  完成时间  周转时间    带权周转时间  \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; %s        %d         %d         %d         %d         %.2f\n&quot;</span>,pcb[i].name,pcb[i].arrive_time,pcb[i].run_time,pcb[i].finish_time,pcb[i].zhouzhuan_time,pcb[i].daiquan_time);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;平均周转时间:&quot;</span>&lt;&lt;sumzhouzhuantime/N&lt;&lt;endl;     <span class="comment">//定义一个全局变量（总的进程的周转时间）/进程数</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;平均带权周转时间:&quot;</span>&lt;&lt;sumdaiquanzhouzhuantime/N&lt;&lt;endl;    <span class="comment">//总的进程的带权周转时间/进程数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这就大功告成了，在主函数中执行这些函数就行了。<br>下面是总的代码（方便大家学习）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  N  5</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">PCB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span>  arrive_time;</span><br><span class="line"><span class="keyword">int</span>  run_time;</span><br><span class="line">    <span class="keyword">int</span> finish_time;</span><br><span class="line"><span class="keyword">int</span>  zhouzhuan_time;</span><br><span class="line"><span class="keyword">float</span> daiquan_time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> sumzhouzhuantime,sumdaiquanzhouzhuantime;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCB</span> <span class="title">pcb</span>[<span class="title">N</span>],<span class="title">temp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>;  <span class="comment">//输入进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>;      <span class="comment">//对输入的进程按到达时间进行排序执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>;   <span class="comment">//输出算法调度时间表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">input</span>();</span><br><span class="line"><span class="built_in">sort</span>( );</span><br><span class="line"><span class="built_in">output</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;--------------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;             FCFS调度算法     &quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;      输入五个进程信息:&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入进程名:\n&quot;</span> );</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,pcb[i].name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入到达时间:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pcb[i].arrive_time);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要运行时间:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pcb[i].run_time);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;各进程:&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;  <span class="built_in">printf</span>(<span class="string">&quot;%s    &quot;</span>,pcb[i].name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d    &quot;</span>,pcb[i].arrive_time);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,pcb[i].run_time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span><span class="comment">//按照到达时间对进程进行排序 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;N;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pcb[i].arrive_time&gt;pcb[j].arrive_time)</span><br><span class="line">&#123;</span><br><span class="line">temp=pcb[i];</span><br><span class="line">pcb[i]=pcb[j];</span><br><span class="line">pcb[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;FCFS调度算法:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    pcb[<span class="number">0</span>].finish_time=pcb[<span class="number">0</span>].arrive_time+pcb[<span class="number">0</span>].run_time;</span><br><span class="line">     pcb[<span class="number">0</span>].zhouzhuan_time=pcb[<span class="number">0</span>].finish_time-pcb[<span class="number">0</span>].arrive_time;</span><br><span class="line">pcb[<span class="number">0</span>].daiquan_time=(<span class="keyword">float</span>)pcb[<span class="number">0</span>].zhouzhuan_time/pcb[<span class="number">0</span>].run_time;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">if</span>(pcb[i].arrive_time&gt;pcb[i<span class="number">-1</span>].finish_time)</span><br><span class="line">&#123;</span><br><span class="line">              pcb[i].finish_time=pcb[i].arrive_time+pcb[i].run_time;</span><br><span class="line">              pcb[i].zhouzhuan_time=pcb[i].run_time;</span><br><span class="line">              pcb[i].daiquan_time=(<span class="keyword">float</span>)pcb[i].zhouzhuan_time/pcb[i].run_time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">            pcb[i].finish_time=pcb[i<span class="number">-1</span>].finish_time+pcb[i].run_time;</span><br><span class="line">            pcb[i].zhouzhuan_time=pcb[i].finish_time-pcb[i].arrive_time;</span><br><span class="line">pcb[i].daiquan_time=(<span class="keyword">float</span>)pcb[i].zhouzhuan_time/pcb[i].run_time;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">sumzhouzhuantime+=pcb[i].zhouzhuan_time;</span><br><span class="line">sumdaiquanzhouzhuantime+=pcb[i].daiquan_time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程名   到达时间  运行时间  完成时间  周转时间    带权周转时间  \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; %s        %d         %d         %d         %d         %.2f\n&quot;</span>,pcb[i].name,pcb[i].arrive_time,pcb[i].run_time,pcb[i].finish_time,pcb[i].zhouzhuan_time,pcb[i].daiquan_time);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;平均周转时间:&quot;</span>&lt;&lt;sumzhouzhuantime/N&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;平均带权周转时间:&quot;</span>&lt;&lt;sumdaiquanzhouzhuantime/N&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20191015221704838.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Mjg1NTUx,size_16,color_FFFFFF,t_70" alt="五个进程的无序输入"><br>     这段程序有个问题不能实现任意数量进程的输入，不就我就会更新。<br>     小白还在学习阶段，有很多问题，希望大家能够指出，谢谢大家，一起加油！</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> FCFS调度 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
